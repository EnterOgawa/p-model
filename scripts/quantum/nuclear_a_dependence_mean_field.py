from __future__ import annotations

import argparse
import csv
import json
import math
from pathlib import Path


def _sha256(path: Path, *, chunk_bytes: int = 8 * 1024 * 1024) -> str:
    import hashlib

    h = hashlib.sha256()
    with path.open("rb") as f:
        while True:
            b = f.read(chunk_bytes)
            if not b:
                break
            h.update(b)
    return h.hexdigest()


def _load_json(path: Path) -> dict:
    return json.loads(path.read_text(encoding="utf-8"))


def _load_nndc_e2plus_keV_by_zn(path: Path) -> dict[tuple[int, int], float]:
    extracted = _load_json(path)
    rows = extracted.get("rows")
    if not isinstance(rows, list) or not rows:
        raise ValueError(f"invalid NNDC E(2+1) extracted dataset: rows missing/empty: {path}")
    out: dict[tuple[int, int], float] = {}
    for r in rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        e = r.get("e2plus_keV")
        try:
            e_val = float(e)
        except Exception:
            continue
        if Z < 1 or N < 0 or not math.isfinite(e_val):
            continue
        out[(int(Z), int(N))] = float(e_val)
    return out


def _load_nudat3_spectroscopy_maps(path: Path) -> dict[str, dict[tuple[int, int], float]]:
    """
    Load NuDat 3.0 low-lying spectroscopy maps from extracted_spectroscopy.json.

    Returns:
      - e2plus_keV: (Z,N)->keV
      - e4plus_keV: (Z,N)->keV
      - e3minus_keV: (Z,N)->keV
      - r42: (Z,N)->dimensionless (E4/E2)
    """
    extracted = _load_json(path)
    rows = extracted.get("rows")
    if not isinstance(rows, list) or not rows:
        raise ValueError(f"invalid NuDat3 spectroscopy extracted dataset: rows missing/empty: {path}")
    out: dict[str, dict[tuple[int, int], float]] = {
        "e2plus_keV": {},
        "e4plus_keV": {},
        "e3minus_keV": {},
        "r42": {},
    }
    for r in rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        if Z < 1 or N < 0:
            continue
        for k in ["e2plus_keV", "e4plus_keV", "e3minus_keV", "r42"]:
            v = r.get(k)
            if v is None:
                continue
            try:
                v_f = float(v)
            except Exception:
                continue
            if not math.isfinite(v_f):
                continue
            out[str(k)][(int(Z), int(N))] = float(v_f)
    return out


def _beta2_for_zn(
    *,
    Z: int,
    N: int,
    beta2_by_zn: dict[tuple[int, int], float],
    include_beta2: bool,
    imputation: str = "neighbors",
) -> tuple[float, str]:
    """
    Return (beta2, mode).

    Source: NNDC B(E2) adopted entries provide β2 for even-even nuclei.

    Imputation policies:
      - neighbors (default): for odd-A / odd-odd, impute β2 as the mean of available nearest even-even
        neighbors (Z±1, N±1); if none available, use 0.
      - direct_only: use direct even-even entries only; otherwise use 0.

    Modes:
      - direct: present in the adopted even-even list
      - imputed: neighbor-average imputation (neighbors policy only)
      - missing: no usable β2 (direct_only policy, or neighbors with no available neighbors)
    """
    if not include_beta2:
        return 0.0, "not_used"
    if str(imputation) not in {"neighbors", "direct_only"}:
        raise ValueError(f"unsupported beta2 imputation policy: {imputation}")
    v = beta2_by_zn.get((int(Z), int(N)))
    if v is not None:
        return float(v), "direct"
    if str(imputation) == "direct_only":
        return 0.0, "missing"
    z_opts = [int(Z)] if (int(Z) % 2 == 0) else [int(Z) - 1, int(Z) + 1]
    n_opts = [int(N)] if (int(N) % 2 == 0) else [int(N) - 1, int(N) + 1]
    vals: list[float] = []
    for z0 in z_opts:
        for n0 in n_opts:
            if z0 < 1 or n0 < 0:
                continue
            v0 = beta2_by_zn.get((int(z0), int(n0)))
            if v0 is not None:
                vals.append(float(v0))
    if vals:
        return float(sum(vals) / float(len(vals))), "imputed"
    return 0.0, "missing"


def _volume_conserving_spheroid_axes_from_beta2(*, beta2: float, include_beta2: bool) -> tuple[float, float]:
    """
    Return (a, c) for a volume-conserving axisymmetric spheroid derived from β2.

    Mapping: R(θ)=R0(1+β2 Y20(θ)); take polar/equatorial radii at θ={0,π/2}, then rescale to conserve volume.
    Since B(E2)-derived β2 is a magnitude, we use |β2|.

    The returned axes are normalized such that the equal-volume sphere has radius 1 (up to rounding).
    """
    if not include_beta2:
        return 1.0, 1.0
    b = abs(float(beta2))
    if not (math.isfinite(b) and b > 0):
        return 1.0, 1.0

    y0 = math.sqrt(5.0 / (4.0 * math.pi))  # Y20 at θ=0
    y90 = -math.sqrt(5.0 / (16.0 * math.pi))  # Y20 at θ=π/2
    rp = 1.0 + float(b) * float(y0)
    re = 1.0 + float(b) * float(y90)
    if not (rp > 0 and re > 0):
        return 1.0, 1.0

    # Scale to conserve volume: (re^2 * rp) -> 1.
    s = (1.0 / (float(re) * float(re) * float(rp))) ** (1.0 / 3.0)
    a = float(s) * float(re)
    c = float(s) * float(rp)
    if not (math.isfinite(a) and math.isfinite(c) and a > 0 and c > 0):
        return 1.0, 1.0
    return float(a), float(c)


def _coulomb_shape_factor_from_beta2(*, beta2: float, include_beta2: bool) -> float:
    """
    Dimensionless Coulomb shape factor f(β2) for an axisymmetric, volume-conserving ellipsoid.

    Mapping: R(θ)=R0(1+β2 Y20(θ)); then scale radii to conserve volume and compute the self-energy factor
    relative to a sphere of equal volume. Since B(E2)-derived β2 is a magnitude, we use |β2|.
    """
    if not include_beta2:
        return 1.0
    b = abs(float(beta2))
    if not (math.isfinite(b) and b > 0):
        return 1.0

    y0 = math.sqrt(5.0 / (4.0 * math.pi))  # Y20 at θ=0
    y90 = -math.sqrt(5.0 / (16.0 * math.pi))  # Y20 at θ=π/2
    rp = 1.0 + float(b) * float(y0)
    re = 1.0 + float(b) * float(y90)
    if not (rp > 0 and re > 0):
        return 1.0

    s = (1.0 / (float(re) * float(re) * float(rp))) ** (1.0 / 3.0)
    a = float(s) * float(re)
    c = float(s) * float(rp)
    if not (math.isfinite(a) and math.isfinite(c) and a > 0 and c > 0):
        return 1.0
    q = float(c) / float(a)
    if not (math.isfinite(q) and q > 0):
        return 1.0
    if abs(float(q) - 1.0) < 1e-12:
        return 1.0

    if q > 1.0:
        e = math.sqrt(max(0.0, 1.0 - 1.0 / (float(q) * float(q))))
        if e < 1e-12:
            return 1.0
        return (1.0 / (2.0 * (float(q) ** (2.0 / 3.0)) * float(e))) * math.log((1.0 + float(e)) / (1.0 - float(e)))
    else:
        e = math.sqrt(max(0.0, 1.0 - float(q) * float(q)))
        if e < 1e-12:
            return 1.0
        return (float(q) ** (1.0 / 3.0)) * (math.asin(float(e)) / float(e))


def _surface_area_factor_from_beta2(*, beta2: float, include_beta2: bool) -> float:
    """
    Dimensionless surface-area factor g(beta2)=S(ellipsoid)/S(sphere) for a volume-conserving spheroid.

    Used to apply a deterministic deformation correction to the surface term. Uses |beta2|.
    """
    if not include_beta2:
        return 1.0
    a, c = _volume_conserving_spheroid_axes_from_beta2(beta2=float(beta2), include_beta2=include_beta2)
    if not (math.isfinite(a) and math.isfinite(c) and a > 0 and c > 0):
        return 1.0
    if abs(float(c) - float(a)) < 1e-12:
        return 1.0

    r0 = (float(a) * float(a) * float(c)) ** (1.0 / 3.0)  # equal-volume sphere radius
    if not (math.isfinite(r0) and r0 > 0):
        return 1.0

    if c > a:
        # prolate spheroid
        e = math.sqrt(max(0.0, 1.0 - (float(a) * float(a)) / (float(c) * float(c))))
        if e < 1e-12:
            return 1.0
        S = 2.0 * math.pi * (float(a) ** 2) * (1.0 + (float(c) / (float(a) * float(e))) * math.asin(float(e)))
    else:
        # oblate spheroid
        e = math.sqrt(max(0.0, 1.0 - (float(c) * float(c)) / (float(a) * float(a))))
        if e < 1e-12:
            return 1.0
        atanh_e = 0.5 * math.log((1.0 + float(e)) / (1.0 - float(e)))
        S = 2.0 * math.pi * (float(a) ** 2) * (1.0 + ((1.0 - float(e) * float(e)) / float(e)) * float(atanh_e))

    S0 = 4.0 * math.pi * (float(r0) ** 2)
    if not (math.isfinite(S) and S > 0 and math.isfinite(S0) and S0 > 0):
        return 1.0
    return float(S) / float(S0)


def _extract_potential_sets(*, metrics_7138: dict) -> dict[int, dict[str, object]]:
    """
    Extract Step 7.13.8 candidate potentials for eq18/eq19.

    Returns per-eq dict:
      - geometry: R1,R2,Rb,R3 (fm)
      - triplet:  V1,V2 (attractive depths, MeV), Vb (repulsive height, MeV), Vt (attractive tail depth, MeV)
      - singlet:  V1,V2 (attractive depths, MeV), Vb (repulsive height, MeV), Vt (attractive tail depth, MeV)
    """
    results = metrics_7138.get("results_by_dataset")
    if not isinstance(results, list) or not results:
        raise SystemExit("[fail] invalid 7.13.8 metrics: results_by_dataset missing/empty")

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    out: dict[int, dict[str, object]] = {}
    for r in results:
        if not isinstance(r, dict):
            continue
        eq = r.get("eq_label")
        if not isinstance(eq, int):
            continue

        ft = r.get("fit_triplet")
        fs = r.get("fit_singlet")
        if not isinstance(ft, dict) or not isinstance(fs, dict):
            continue
        geo = ft.get("geometry")
        if not isinstance(geo, dict):
            continue

        geometry = {
            "R1_fm": fnum(geo.get("R1_fm"), ctx=f"eq{eq} geometry.R1_fm"),
            "R2_fm": fnum(geo.get("R2_fm"), ctx=f"eq{eq} geometry.R2_fm"),
            "Rb_fm": fnum(geo.get("Rb_fm"), ctx=f"eq{eq} geometry.Rb_fm"),
            "R3_fm": fnum(geo.get("R3_fm"), ctx=f"eq{eq} geometry.R3_fm"),
        }

        triplet = {
            "V1_MeV": fnum(ft.get("V1_t_MeV"), ctx=f"eq{eq} V1_t_MeV"),
            "V2_MeV": fnum(ft.get("V2_t_MeV"), ctx=f"eq{eq} V2_t_MeV"),
            "Vb_MeV": fnum(ft.get("V3_barrier_t_MeV"), ctx=f"eq{eq} V3_barrier_t_MeV"),
            "Vt_MeV": fnum(ft.get("V3_tail_t_MeV"), ctx=f"eq{eq} V3_tail_t_MeV"),
        }

        singlet = {
            "V1_MeV": fnum(fs.get("V1_s_MeV"), ctx=f"eq{eq} V1_s_MeV"),
            "V2_MeV": fnum(fs.get("V2_s_MeV"), ctx=f"eq{eq} V2_s_MeV"),
            "Vb_MeV": fnum(fs.get("Vb_s_MeV"), ctx=f"eq{eq} Vb_s_MeV"),
            "Vt_MeV": fnum(fs.get("Vt_s_MeV"), ctx=f"eq{eq} Vt_s_MeV"),
        }

        out[int(eq)] = {"geometry": geometry, "triplet": triplet, "singlet": singlet}

    if not out:
        raise SystemExit("[fail] could not extract any datasets from 7.13.8 metrics")
    return out


def _sharp_radius_from_rms(r_rms_fm: float) -> float:
    """
    For a uniform sphere of radius R, rms radius is sqrt(3/5) R.
    So R = sqrt(5/3) r_rms.
    """
    return math.sqrt(5.0 / 3.0) * float(r_rms_fm)


def _hf_base_energy_uniform_sphere_mev_per_a(
    *,
    A: int,
    Z: int,
    N: int,
    R_sharp_fm: float,
    pot_sets: dict[int, dict[str, object]],
    eq: int,
    pn_triplet_weight: float,
    hbarc_mev_fm: float,
    m_nucleon_c2_mev: float,
) -> dict[str, float]:
    if not (A > 0 and Z >= 0 and N >= 0 and (Z + N) == A):
        return {"T": float("nan"), "U_H": float("nan"), "U_F": float("nan"), "Coul": float("nan"), "E_base": float("nan")}
    if not (math.isfinite(R_sharp_fm) and R_sharp_fm > 0):
        return {"T": float("nan"), "U_H": float("nan"), "U_F": float("nan"), "Coul": float("nan"), "E_base": float("nan")}

    V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp_fm) ** 3
    rho = float(A) / float(V_sphere)
    rho_p = float(Z) / float(V_sphere)
    rho_n = float(N) / float(V_sphere)

    # Two-component kinetic (already includes Pauli via Fermi momentum).
    kin = _fermi_kinetic_energy_two_component_mev_per_a(Z=Z, N=N, volume_fm3=V_sphere, hbarc_mev_fm=hbarc_mev_fm, m_nucleon_c2_mev=m_nucleon_c2_mev)
    t_total = float(kin["T_total_MeV_per_A"])

    e_coul = _coulomb_energy_uniform_sphere_mev_per_a(Z=Z, A=A, R_sharp_fm=float(R_sharp_fm))

    # HF potential: pp/nn use singlet channel; pn uses a fixed mix in Hartree only.
    s = pot_sets[int(eq)]
    geom = s["geometry"]
    tri = s["triplet"]
    sin = s["singlet"]

    I0_s = _integral_I0_mev_fm3(geometry=geom, V1_MeV=float(sin["V1_MeV"]), V2_MeV=float(sin["V2_MeV"]), Vb_MeV=float(sin["Vb_MeV"]), Vt_MeV=float(sin["Vt_MeV"]))
    I0_t = _integral_I0_mev_fm3(geometry=geom, V1_MeV=float(tri["V1_MeV"]), V2_MeV=float(tri["V2_MeV"]), Vb_MeV=float(tri["Vb_MeV"]), Vt_MeV=float(tri["Vt_MeV"]))
    I0_pn = float(pn_triplet_weight) * float(I0_t) + (1.0 - float(pn_triplet_weight)) * float(I0_s)

    # Exchange integrals for like species (spin degeneracy g=2 -> factor 1/2).
    kf_p = float(kin["kf_p_fm1"])
    kf_n = float(kin["kf_n_fm1"])
    Iex_p = _integral_Iex_mev_fm3(
        geometry=geom,
        V1_MeV=float(sin["V1_MeV"]),
        V2_MeV=float(sin["V2_MeV"]),
        Vb_MeV=float(sin["Vb_MeV"]),
        Vt_MeV=float(sin["Vt_MeV"]),
        kf_fm1=kf_p,
    )
    Iex_n = _integral_Iex_mev_fm3(
        geometry=geom,
        V1_MeV=float(sin["V1_MeV"]),
        V2_MeV=float(sin["V2_MeV"]),
        Vb_MeV=float(sin["Vb_MeV"]),
        Vt_MeV=float(sin["Vt_MeV"]),
        kf_fm1=kf_n,
    )

    # Hartree per-particle (pair counting; distinguishable pn has no 1/2).
    u_h = (rho_p * rho_p / (2.0 * rho)) * float(I0_s) + (rho_n * rho_n / (2.0 * rho)) * float(I0_s) + (rho_p * rho_n / rho) * float(I0_pn)

    # Fock per-particle (only identical species; factor 1/(2g) with g=2 -> 1/4).
    u_f = -0.25 * (rho_p * rho_p / rho) * float(Iex_p) - 0.25 * (rho_n * rho_n / rho) * float(Iex_n)

    e_base = float(t_total) + float(u_h) + float(u_f) + float(e_coul)
    return {"T": float(t_total), "U_H": float(u_h), "U_F": float(u_f), "Coul": float(e_coul), "E_base": float(e_base)}


def _overlap_integral_J(*, a: float, b: float, R: float) -> float:
    """
    J(a,b;R) = ∫_a^b r^2 * V_overlap(r;R) dr, where
      V_overlap(r;R) = π/12 * (16 R^3 - 12 R^2 r + r^3)   for 0<=r<=2R, else 0.
    """
    if b <= a:
        return 0.0
    if not (R > 0 and math.isfinite(R)):
        return float("nan")

    a2 = max(0.0, min(float(a), 2.0 * R))
    b2 = max(0.0, min(float(b), 2.0 * R))
    if b2 <= a2:
        return 0.0

    def F(x: float) -> float:
        # ∫ r^2 V_overlap dr = π/12 * (16/3 R^3 r^3 - 3 R^2 r^4 + r^6/6)
        return (math.pi / 12.0) * ((16.0 / 3.0) * R**3 * x**3 - 3.0 * R**2 * x**4 + x**6 / 6.0)

    return float(F(b2) - F(a2))


def _mean_field_accum_mev_fm6(
    *,
    R_sharp_fm: float,
    geometry: dict[str, float],
    V1_MeV: float,
    V2_MeV: float,
    Vb_MeV: float,
    Vt_MeV: float,
) -> float:
    """
    Return the geometric overlap integral (accumulator) used in the uniform-sphere mean-field:

      accum = ∫_0^{2R} V(r) r^2 V_overlap(r;R) dr    [MeV·fm^6]

    where V(r) is the Step 7.13.8 piecewise potential.
    """
    if not (math.isfinite(R_sharp_fm) and R_sharp_fm > 0):
        return float("nan")

    r1 = float(geometry["R1_fm"])
    r2 = float(geometry["R2_fm"])
    rb = float(geometry["Rb_fm"])
    r3 = float(geometry["R3_fm"])

    segs = [
        (0.0, r1, -float(V1_MeV)),
        (r1, r2, -float(V2_MeV)),
        (r2, rb, +float(Vb_MeV)),
        (rb, r3, -float(Vt_MeV)),
    ]

    accum = 0.0
    for a, b, v in segs:
        j = _overlap_integral_J(a=a, b=b, R=R_sharp_fm)
        accum += float(v) * float(j)
    return float(accum)


def _mean_field_potential_energy_per_particle_mev(
    *,
    R_sharp_fm: float,
    rho_fm3: float,
    geometry: dict[str, float],
    V1_MeV: float,
    V2_MeV: float,
    Vb_MeV: float,
    Vt_MeV: float,
) -> float:
    """
    Uniform-sphere mean-field (pairwise) potential energy per particle:

      U/A = (ρ / (2V)) ∫∫ V(|r1-r2|) d^3r1 d^3r2
          = (2π ρ / V) ∫_0^{2R} V(r) r^2 V_overlap(r;R) dr

    Potential convention (from Step 7.13.8):
      -V1   (0<=r<R1)         attractive
      -V2   (R1<=r<R2)        attractive
      +Vb   (R2<=r<Rb)        repulsive barrier
      -Vt   (Rb<=r<R3)        attractive tail (coarse-grained)
       0    (r>=R3)
    """
    if not (math.isfinite(R_sharp_fm) and R_sharp_fm > 0 and math.isfinite(rho_fm3) and rho_fm3 > 0):
        return float("nan")
    V_sphere = (4.0 / 3.0) * math.pi * R_sharp_fm**3
    accum = _mean_field_accum_mev_fm6(
        R_sharp_fm=R_sharp_fm, geometry=geometry, V1_MeV=V1_MeV, V2_MeV=V2_MeV, Vb_MeV=Vb_MeV, Vt_MeV=Vt_MeV
    )
    return float((2.0 * math.pi * float(rho_fm3) / float(V_sphere)) * float(accum))


def _fermi_kinetic_energy_per_particle_mev(*, rho_fm3: float, hbarc_mev_fm: float, m_nucleon_c2_mev: float) -> tuple[float, float]:
    """
    Non-relativistic symmetric Fermi gas (degeneracy g=4):
      ρ = g kF^3 / (6π^2)  ->  kF = (6π^2 ρ / g)^(1/3)
      E_F = (ħc)^2 kF^2 / (2 m c^2)
      <T>/A = 3/5 E_F
    """
    if not (math.isfinite(rho_fm3) and rho_fm3 > 0):
        return float("nan"), float("nan")
    g = 4.0
    kf = (6.0 * math.pi**2 * float(rho_fm3) / g) ** (1.0 / 3.0)
    ef = (float(hbarc_mev_fm) ** 2) * (kf**2) / (2.0 * float(m_nucleon_c2_mev))
    return float(kf), float((3.0 / 5.0) * ef)


def _fermi_kinetic_energy_two_component_mev_per_a(
    *,
    Z: int,
    N: int,
    volume_fm3: float,
    hbarc_mev_fm: float,
    m_nucleon_c2_mev: float,
) -> dict[str, float]:
    """
    Two-component (proton/neutron) non-relativistic Fermi gas with degeneracy g=2 each.

    Returns:
      - rho_p, rho_n, kf_p, kf_n
      - T_p_per_A, T_n_per_A, T_total_per_A
    """
    if not (Z >= 0 and N >= 0 and (Z + N) > 0 and math.isfinite(volume_fm3) and volume_fm3 > 0):
        return {
            "rho_p_fm3": float("nan"),
            "rho_n_fm3": float("nan"),
            "kf_p_fm1": float("nan"),
            "kf_n_fm1": float("nan"),
            "T_p_MeV_per_A": float("nan"),
            "T_n_MeV_per_A": float("nan"),
            "T_total_MeV_per_A": float("nan"),
        }

    A = int(Z + N)
    rho_p = float(Z) / float(volume_fm3)
    rho_n = float(N) / float(volume_fm3)

    def comp(*, rho: float) -> tuple[float, float]:
        # g=2 -> kF=(6π^2 ρ / g)^(1/3) = (3π^2 ρ)^(1/3)
        if not (math.isfinite(rho) and rho > 0):
            return 0.0, 0.0
        kf = (3.0 * math.pi**2 * rho) ** (1.0 / 3.0)
        ef = (float(hbarc_mev_fm) ** 2) * (kf**2) / (2.0 * float(m_nucleon_c2_mev))
        t = (3.0 / 5.0) * ef
        return float(kf), float(t)

    kf_p, t_p = comp(rho=rho_p)
    kf_n, t_n = comp(rho=rho_n)

    t_total = (float(Z) * t_p + float(N) * t_n) / float(A)
    return {
        "rho_p_fm3": float(rho_p),
        "rho_n_fm3": float(rho_n),
        "kf_p_fm1": float(kf_p),
        "kf_n_fm1": float(kf_n),
        "T_p_MeV_per_A": float(float(Z) * t_p / float(A)),
        "T_n_MeV_per_A": float(float(N) * t_n / float(A)),
        "T_total_MeV_per_A": float(t_total),
    }


def _coulomb_energy_uniform_sphere_mev_per_a(*, Z: int, A: int, R_sharp_fm: float) -> float:
    """
    Coulomb self-energy of a uniformly-charged sphere (very rough):
      E_C ≈ (3/5) (e^2) Z(Z-1) / R
    where e^2 (in MeV·fm) ≈ 1.43996448.
    """
    if not (A > 0 and Z >= 0 and math.isfinite(R_sharp_fm) and R_sharp_fm > 0):
        return float("nan")
    if Z <= 1:
        return 0.0
    e2_mev_fm = 1.43996448
    e_total = (3.0 / 5.0) * e2_mev_fm * float(Z * (Z - 1)) / float(R_sharp_fm)
    return float(e_total / float(A))


def _mean_field_potential_energy_two_component_mev_per_a(
    *,
    Z: int,
    N: int,
    volume_fm3: float,
    R_sharp_fm: float,
    geometry: dict[str, float],
    triplet: dict[str, float],
    singlet: dict[str, float],
    pn_triplet_weight: float,
) -> dict[str, float]:
    """
    Two-component (p/n) Hartree mean-field with minimal channel bookkeeping:

      - pp and nn: use the singlet channel as a minimal antisymmetry proxy (S-wave).
      - pn: use a fixed mixture of triplet/singlet, controlled by pn_triplet_weight.

    Notes:
      - This is still a declared approximation (consistency check), not a full many-body solve.
      - Exchange/Fock terms are not included here.
    """
    if not (Z >= 0 and N >= 0 and (Z + N) > 0 and math.isfinite(volume_fm3) and volume_fm3 > 0):
        return {"rho_p_fm3": float("nan"), "rho_n_fm3": float("nan"), "U_pot_MeV_per_A": float("nan")}
    if not (math.isfinite(pn_triplet_weight) and 0.0 <= pn_triplet_weight <= 1.0):
        return {"rho_p_fm3": float("nan"), "rho_n_fm3": float("nan"), "U_pot_MeV_per_A": float("nan")}

    A = int(Z + N)
    rho_p = float(Z) / float(volume_fm3)
    rho_n = float(N) / float(volume_fm3)
    rho = float(A) / float(volume_fm3)

    acc_s = _mean_field_accum_mev_fm6(
        R_sharp_fm=R_sharp_fm,
        geometry=geometry,
        V1_MeV=float(singlet["V1_MeV"]),
        V2_MeV=float(singlet["V2_MeV"]),
        Vb_MeV=float(singlet["Vb_MeV"]),
        Vt_MeV=float(singlet["Vt_MeV"]),
    )
    acc_t = _mean_field_accum_mev_fm6(
        R_sharp_fm=R_sharp_fm,
        geometry=geometry,
        V1_MeV=float(triplet["V1_MeV"]),
        V2_MeV=float(triplet["V2_MeV"]),
        Vb_MeV=float(triplet["Vb_MeV"]),
        Vt_MeV=float(triplet["Vt_MeV"]),
    )
    acc_pn = float(pn_triplet_weight) * float(acc_t) + (1.0 - float(pn_triplet_weight)) * float(acc_s)

    # Per-particle energy (divide energy density by total density ρ).
    term = 0.5 * (rho_p**2 + rho_n**2) * float(acc_s) + (rho_p * rho_n) * float(acc_pn)
    u_per_a = (4.0 * math.pi / (rho * float(volume_fm3))) * float(term)

    return {"rho_p_fm3": float(rho_p), "rho_n_fm3": float(rho_n), "U_pot_MeV_per_A": float(u_per_a)}


def _j1(x: float) -> float:
    # spherical Bessel j1(x)
    ax = abs(float(x))
    if ax < 1e-6:
        return float(x) / 3.0
    return math.sin(float(x)) / float(x) ** 2 - math.cos(float(x)) / float(x)


def _slater_f(x: float) -> float:
    # f(x) = 3 j1(x) / x, with f(0)=1
    ax = abs(float(x))
    if ax < 1e-6:
        return 1.0
    return float(3.0 * _j1(float(x)) / float(x))


def _integral_I0_mev_fm3(*, geometry: dict[str, float], V1_MeV: float, V2_MeV: float, Vb_MeV: float, Vt_MeV: float) -> float:
    """
    I0 = ∫ V(r) d^3r   [MeV·fm^3]  (infinite uniform-matter integral)
    """
    r1 = float(geometry["R1_fm"])
    r2 = float(geometry["R2_fm"])
    rb = float(geometry["Rb_fm"])
    r3 = float(geometry["R3_fm"])
    segs = [
        (0.0, r1, -float(V1_MeV)),
        (r1, r2, -float(V2_MeV)),
        (r2, rb, +float(Vb_MeV)),
        (rb, r3, -float(Vt_MeV)),
    ]
    return float(4.0 * math.pi * sum(v * (b**3 - a**3) / 3.0 for a, b, v in segs))


def _integral_Iex_mev_fm3(*, geometry: dict[str, float], V1_MeV: float, V2_MeV: float, Vb_MeV: float, Vt_MeV: float, kf_fm1: float) -> float:
    """
    Iex(kF) = ∫ V(r) [f(kF r)]^2 d^3r   [MeV·fm^3]
    with f(x)=3 j1(x)/x (Slater function).

    Numerical Simpson integration per segment (piecewise-constant V).
    """
    if not (math.isfinite(kf_fm1) and kf_fm1 >= 0):
        return float("nan")

    r1 = float(geometry["R1_fm"])
    r2 = float(geometry["R2_fm"])
    rb = float(geometry["Rb_fm"])
    r3 = float(geometry["R3_fm"])
    segs = [
        (0.0, r1, -float(V1_MeV)),
        (r1, r2, -float(V2_MeV)),
        (r2, rb, +float(Vb_MeV)),
        (rb, r3, -float(Vt_MeV)),
    ]

    total = 0.0
    for a, b, v in segs:
        if b <= a:
            continue
        # Simpson with fixed resolution (fast enough; segments are short)
        n = 2000
        h = (b - a) / n
        s = 0.0
        for i in range(n + 1):
            r = a + i * h
            w = 4.0 if (i % 2 == 1) else 2.0
            if i == 0 or i == n:
                w = 1.0
            fr = _slater_f(float(kf_fm1) * float(r))
            s += w * (r**2) * float(v) * (fr**2)
        total += s * h / 3.0
    return float(4.0 * math.pi * total)


def _resolve_effective_potential_metrics_path(*, out_dir: Path) -> Path:
    """
    Resolve the canonical effective-potential metrics used as the fixed nuclear-scale u-profile.

    Prefer the stable canonical alias, then the current best-surviving candidate (7.13.8.5),
    and finally fall back to the legacy (7.13.8) file for backward compatibility.
    """
    candidates: list[Path] = [
        out_dir / "nuclear_effective_potential_canonical_metrics.json",
        out_dir / "nuclear_effective_potential_pion_constrained_barrier_tail_channel_split_kq_scan_triplet_barrier_fraction_scan_metrics.json",
        out_dir / "nuclear_effective_potential_pion_constrained_barrier_tail_kq_scan_metrics.json",
    ]
    for p in candidates:
        if p.exists():
            return p
    raise SystemExit(
        "[fail] missing nuclear effective-potential metrics (fixed u-profile).\n"
        "Run (recommended):\n"
        "  python -B scripts/quantum/nuclear_effective_potential_two_range.py --step 7.13.8.5\n"
        "Expected one of:\n"
        + "\n".join(f"  - {p}" for p in candidates)
    )


def _potential_metrics_input_entry(*, metrics_path: Path, metrics_obj: dict | None = None) -> dict[str, object]:
    entry: dict[str, object] = {"path": str(metrics_path), "sha256": _sha256(metrics_path)}
    if isinstance(metrics_obj, dict):
        step = metrics_obj.get("step")
        if isinstance(step, str) and step.strip():
            entry["step"] = step.strip()
        canon = metrics_obj.get("canonical")
        if isinstance(canon, dict):
            selected_step = canon.get("selected_step")
            selected_metrics = canon.get("selected_metrics_json")
            if selected_step is not None or selected_metrics is not None:
                entry["canonical"] = {"selected_step": selected_step, "selected_metrics_json": selected_metrics}
    return entry


def _load_common_inputs(*, out_dir: Path) -> dict[str, object]:
    metrics_7138_path = _resolve_effective_potential_metrics_path(out_dir=out_dir)
    metrics_7138 = _load_json(metrics_7138_path)
    potential_metrics_input = _potential_metrics_input_entry(metrics_path=metrics_7138_path, metrics_obj=metrics_7138)

    rep_path = out_dir / "nuclear_binding_representative_nuclei_metrics.json"
    if not rep_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.11 baseline metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_binding_representative_nuclei.py\n"
            f"Expected: {rep_path}"
        )
    rep = _load_json(rep_path)
    nuclei = rep.get("nuclei")
    if not isinstance(nuclei, list) or not nuclei:
        raise SystemExit(f"[fail] invalid baseline metrics: nuclei missing/empty: {rep_path}")

    consts = metrics_7138.get("constants") if isinstance(metrics_7138.get("constants"), dict) else {}
    hbarc = float(consts.get("hbarc_MeV_fm", 197.3269804))
    mu_c2 = float(consts.get("mu_c2_MeV", 469.4591551497099))
    m_nucleon_c2 = 2.0 * mu_c2

    pot_sets = _extract_potential_sets(metrics_7138=metrics_7138)
    eq_labels = sorted(pot_sets.keys())

    return {
        "metrics_7138_path": metrics_7138_path,
        "potential_metrics_input": potential_metrics_input,
        "rep_path": rep_path,
        "nuclei": nuclei,
        "constants": {"hbarc_MeV_fm": hbarc, "m_nucleon_c2_MeV": m_nucleon_c2},
        "pot_sets": pot_sets,
        "eq_labels": eq_labels,
    }


def _run_step_7_13_13(*, out_dir: Path, calibrate_key: str, pn_triplet_weight: float) -> None:
    common = _load_common_inputs(out_dir=out_dir)
    metrics_7138_path = Path(str(common["metrics_7138_path"]))
    potential_metrics_input = dict(common.get("potential_metrics_input") or {})
    rep_path = Path(str(common["rep_path"]))
    nuclei = common["nuclei"]
    consts = common["constants"]
    pot_sets = common["pot_sets"]
    eq_labels = common["eq_labels"]

    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    repulsion_power = 2.0

    rows: list[dict[str, object]] = []
    for nuc in nuclei:
        if not isinstance(nuc, dict):
            continue
        a = int(nuc["A"])
        z = int(nuc["Z"])
        n = int(nuc["N"])
        key = str(nuc["key"])
        label = str(nuc["label"])
        ba_obs = float(nuc["binding_energy_per_nucleon_MeV"])
        r_charge = float(nuc["charge_radius_fm"])

        R_sharp = _sharp_radius_from_rms(r_charge)
        V_sphere = (4.0 / 3.0) * math.pi * R_sharp**3
        rho = float(a) / float(V_sphere)

        kin = _fermi_kinetic_energy_two_component_mev_per_a(Z=z, N=n, volume_fm3=V_sphere, hbarc_mev_fm=hbarc, m_nucleon_c2_mev=m_nucleon_c2)
        t_total = float(kin["T_total_MeV_per_A"])
        e_coul = _coulomb_energy_uniform_sphere_mev_per_a(Z=z, A=a, R_sharp_fm=R_sharp)

        per_eq: dict[int, dict[str, float]] = {}
        for eq in eq_labels:
            s = pot_sets[eq]
            geom = s["geometry"]
            tri = s["triplet"]
            sin = s["singlet"]

            u2 = _mean_field_potential_energy_two_component_mev_per_a(
                Z=z,
                N=n,
                volume_fm3=V_sphere,
                R_sharp_fm=R_sharp,
                geometry=geom,
                triplet=tri,
                singlet=sin,
                pn_triplet_weight=pn_triplet_weight,
            )
            u_mev = float(u2["U_pot_MeV_per_A"])
            e_base = float(t_total) + float(u_mev) + float(e_coul)

            per_eq[int(eq)] = {
                "kf_p_fm1": float(kin["kf_p_fm1"]),
                "kf_n_fm1": float(kin["kf_n_fm1"]),
                "T_kin_MeV_per_A": float(t_total),
                "U_pot_MeV_per_A": float(u_mev),
                "E_coul_MeV_per_A": float(e_coul),
                "E_base_MeV_per_A": float(e_base),
            }

        rows.append(
            {
                "key": key,
                "label": label,
                "A": a,
                "Z": z,
                "N": n,
                "r_charge_fm": r_charge,
                "R_sharp_fm": R_sharp,
                "rho_fm3": rho,
                "B_over_A_obs_MeV": ba_obs,
                "kin": kin,
                "per_eq": per_eq,
            }
        )

    calib = next((r for r in rows if str(r["key"]) == str(calibrate_key)), None)
    if calib is None:
        raise SystemExit(f"[fail] calibrate_key not found in nuclei list: {calibrate_key}")

    rho_calib = float(calib["rho_fm3"])
    e_target = -float(calib["B_over_A_obs_MeV"])

    repulsion_coeffs: dict[int, float] = {}
    for eq in eq_labels:
        e_base = float(calib["per_eq"][eq]["E_base_MeV_per_A"])
        denom = rho_calib**repulsion_power
        if not (math.isfinite(denom) and denom > 0):
            raise SystemExit("[fail] invalid calibration density")
        repulsion_coeffs[int(eq)] = float((e_target - e_base) / denom)

    stats: dict[int, dict[str, float]] = {}
    for eq in eq_labels:
        c = float(repulsion_coeffs[eq])
        res: list[float] = []
        for r in rows:
            rho = float(r["rho_fm3"])
            e_base = float(r["per_eq"][eq]["E_base_MeV_per_A"])
            e_rep = float(c) * (rho**repulsion_power)
            e_total = e_base + e_rep
            ba_pred = -float(e_total)
            ba_obs = float(r["B_over_A_obs_MeV"])
            r["per_eq"][eq].update(
                {
                    "E_rep_MeV_per_A": float(e_rep),
                    "E_total_MeV_per_A": float(e_total),
                    "B_over_A_pred_MeV": float(ba_pred),
                    "B_over_A_residual_MeV": float(ba_pred - ba_obs),
                }
            )
            res.append(float(ba_pred - ba_obs))

        rms = math.sqrt(sum(x * x for x in res) / len(res)) if res else float("nan")
        mean = sum(res) / len(res) if res else float("nan")
        stats[int(eq)] = {"residual_mean_MeV": float(mean), "residual_rms_MeV": float(rms)}

    best_eq = min(eq_labels, key=lambda eq: float(stats[eq]["residual_rms_MeV"]))

    # Plot
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    ba_obs_vals = [float(r["B_over_A_obs_MeV"]) for r in rows]
    labels = [str(r["label"]) for r in rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.scatter(a13, ba_obs_vals, s=45, label="obs (AME2020)")
    for eq in eq_labels:
        ba_pred = [float(r["per_eq"][eq]["B_over_A_pred_MeV"]) for r in rows]
        ax.plot(a13, ba_pred, marker="o", linestyle="--", label=f"pred (+rep; eq{eq})")
    ax.set_title("B/A: obs vs mean-field(+repulsion) pred")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab in zip(a13, ba_obs_vals, labels, strict=True):
        ax.annotate(lab, (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8)

    ax = axes[0][1]
    t_vals = [float(r["per_eq"][best_eq]["T_kin_MeV_per_A"]) for r in rows]
    u_vals = [float(r["per_eq"][best_eq]["U_pot_MeV_per_A"]) for r in rows]
    c_vals = [float(r["per_eq"][best_eq]["E_coul_MeV_per_A"]) for r in rows]
    rep_vals = [float(r["per_eq"][best_eq]["E_rep_MeV_per_A"]) for r in rows]
    ax.plot(a13, t_vals, marker=".", linestyle="-", label="T (2-comp Fermi)")
    ax.plot(a13, u_vals, marker=".", linestyle="--", label="U (Hartree)")
    ax.plot(a13, c_vals, marker=".", linestyle=":", label="Coulomb")
    ax.plot(a13, rep_vals, marker=".", linestyle="-.", label="repulsion")
    ax.set_title(f"Contributions (best RMS: eq{best_eq})")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("MeV per nucleon")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8, ncol=2)

    ax = axes[1][0]
    rho_vals = [float(r["rho_fm3"]) for r in rows]
    ax.plot(a13, rho_vals, marker="o", linestyle="-", color="tab:purple")
    ax.set_title("Density estimate from charge radii")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("ρ (fm^-3)")
    ax.grid(True, alpha=0.3)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "Model: 2-comp Fermi + Hartree + Coulomb + density repulsion (one-point calib)",
        "Pair channels: pp/nn -> singlet; pn -> mix(triplet/singlet)",
        f"pn_triplet_weight={pn_triplet_weight:.2f}",
        f"Repulsion: E_rep/A = C * ρ^{repulsion_power:.0f}",
        f"Calibrate: key={calibrate_key}",
        "",
        "Calibrated C (per eq):",
    ]
    for eq in eq_labels:
        lines.append(f"  - eq{eq}: C={repulsion_coeffs[eq]:.6g} (RMS={stats[eq]['residual_rms_MeV']:.3g} MeV)")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_mean_field_density_repulsion.png"
    fig.suptitle("Phase 7 / Step 7.13.13: A-dependence (minimal many-body repulsion proxy)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    # CSV
    out_csv = out_dir / "nuclear_a_dependence_mean_field_density_repulsion.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "r_charge_fm",
            "R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
        ]
        for eq in eq_labels:
            header.extend(
                [
                    f"T_kin_eq{eq}_MeV_per_A",
                    f"U_pot_eq{eq}_MeV_per_A",
                    f"E_coul_eq{eq}_MeV_per_A",
                    f"E_rep_eq{eq}_MeV_per_A",
                    f"B_over_A_pred_eq{eq}_MeV",
                    f"residual_eq{eq}_MeV",
                ]
            )
        w.writerow(header)
        for r in rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                f"{float(r['r_charge_fm']):.12g}",
                f"{float(r['R_sharp_fm']):.12g}",
                f"{float(r['rho_fm3']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
            ]
            for eq in eq_labels:
                pe = r["per_eq"][eq]
                row.extend(
                    [
                        f"{float(pe['T_kin_MeV_per_A']):.12g}",
                        f"{float(pe['U_pot_MeV_per_A']):.12g}",
                        f"{float(pe['E_coul_MeV_per_A']):.12g}",
                        f"{float(pe['E_rep_MeV_per_A']):.12g}",
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_mean_field_density_repulsion_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.13",
                "inputs": {
                    "potential_metrics": potential_metrics_input,
                    "potential_metrics_7_13_8": potential_metrics_input,
                    "targets_7_13_11": {"path": str(rep_path), "sha256": _sha256(rep_path)},
                },
                "model": {
                    "type": "uniform_sphere_mean_field_density_repulsion",
                    "pair_channels": {"pp_nn": "singlet", "pn_triplet_weight": pn_triplet_weight},
                    "kinetic": "nonrelativistic 2-component Fermi gas",
                    "coulomb": "(3/5)e^2 Z(Z-1)/R",
                    "repulsion": {"form": "E_rep/A = C*rho^n", "n": repulsion_power, "calibrate_key": calibrate_key, "coeffs_by_eq": repulsion_coeffs},
                },
                "constants": {"hbarc_MeV_fm": hbarc, "m_nucleon_c2_MeV": m_nucleon_c2},
                "stats": stats,
                "rows": rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_14(*, out_dir: Path, pn_triplet_weight: float, freeze_min_a: int, derivative_eps_rel: float) -> None:
    common = _load_common_inputs(out_dir=out_dir)
    metrics_7138_path = Path(str(common["metrics_7138_path"]))
    potential_metrics_input = dict(common.get("potential_metrics_input") or {})
    rep_path = Path(str(common["rep_path"]))
    nuclei = common["nuclei"]
    consts = common["constants"]
    pot_sets = common["pot_sets"]
    eq_labels = common["eq_labels"]

    if not (math.isfinite(derivative_eps_rel) and 0.0 < derivative_eps_rel < 0.05):
        raise SystemExit("[fail] derivative_eps_rel must be in (0, 0.05)")
    if freeze_min_a < 1:
        raise SystemExit("[fail] freeze_min_a must be >= 1")

    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    repulsion_power = 2.0

    def eval_base(*, A: int, Z: int, N: int, R_sharp_fm: float, eq: int) -> dict[str, float]:
        if not (A > 0 and Z >= 0 and N >= 0 and (Z + N) == A):
            return {"T": float("nan"), "U": float("nan"), "Coul": float("nan"), "E_base": float("nan")}
        if not (math.isfinite(R_sharp_fm) and R_sharp_fm > 0):
            return {"T": float("nan"), "U": float("nan"), "Coul": float("nan"), "E_base": float("nan")}

        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp_fm) ** 3
        kin = _fermi_kinetic_energy_two_component_mev_per_a(Z=Z, N=N, volume_fm3=V_sphere, hbarc_mev_fm=hbarc, m_nucleon_c2_mev=m_nucleon_c2)
        t_total = float(kin["T_total_MeV_per_A"])
        e_coul = _coulomb_energy_uniform_sphere_mev_per_a(Z=Z, A=A, R_sharp_fm=float(R_sharp_fm))

        s = pot_sets[int(eq)]
        geom = s["geometry"]
        tri = s["triplet"]
        sin = s["singlet"]
        u2 = _mean_field_potential_energy_two_component_mev_per_a(
            Z=Z,
            N=N,
            volume_fm3=V_sphere,
            R_sharp_fm=float(R_sharp_fm),
            geometry=geom,
            triplet=tri,
            singlet=sin,
            pn_triplet_weight=pn_triplet_weight,
        )
        u_mev = float(u2["U_pot_MeV_per_A"])
        e_base = float(t_total) + float(u_mev) + float(e_coul)
        return {"T": float(t_total), "U": float(u_mev), "Coul": float(e_coul), "E_base": float(e_base)}

    rows: list[dict[str, object]] = []
    for nuc in nuclei:
        if not isinstance(nuc, dict):
            continue
        A = int(nuc["A"])
        Z = int(nuc["Z"])
        N = int(nuc["N"])
        key = str(nuc["key"])
        label = str(nuc["label"])
        ba_obs = float(nuc["binding_energy_per_nucleon_MeV"])
        r_charge = float(nuc["charge_radius_fm"])

        R_sharp = _sharp_radius_from_rms(r_charge)
        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho = float(A) / float(V_sphere)

        per_eq: dict[int, dict[str, float]] = {}
        for eq in eq_labels:
            base = eval_base(A=A, Z=Z, N=N, R_sharp_fm=R_sharp, eq=int(eq))
            # dE_base/dR at fixed A (central difference)
            dR = float(derivative_eps_rel) * float(R_sharp)
            base_p = eval_base(A=A, Z=Z, N=N, R_sharp_fm=float(R_sharp) + dR, eq=int(eq))
            base_m = eval_base(A=A, Z=Z, N=N, R_sharp_fm=float(R_sharp) - dR, eq=int(eq))
            dE_dR = (float(base_p["E_base"]) - float(base_m["E_base"])) / (2.0 * float(dR)) if dR > 0 else float("nan")

            # If E_rep/A = C * rho^n, then equilibrium at R implies:
            #   dE_base/dR - 3 n C rho^n / R = 0  ->  C = (R dE_base/dR)/(3 n rho^n)
            denom = 3.0 * float(repulsion_power) * (float(rho) ** float(repulsion_power))
            c_est = (float(R_sharp) * float(dE_dR) / denom) if (math.isfinite(denom) and denom > 0) else float("nan")

            per_eq[int(eq)] = {
                "T_kin_MeV_per_A": float(base["T"]),
                "U_pot_MeV_per_A": float(base["U"]),
                "E_coul_MeV_per_A": float(base["Coul"]),
                "E_base_MeV_per_A": float(base["E_base"]),
                "dEbase_dR_MeV_per_fm": float(dE_dR),
                "C_est_from_radii": float(c_est),
            }

        rows.append(
            {
                "key": key,
                "label": label,
                "A": int(A),
                "Z": int(Z),
                "N": int(N),
                "r_charge_fm": float(r_charge),
                "R_sharp_fm": float(R_sharp),
                "rho_fm3": float(rho),
                "B_over_A_obs_MeV": float(ba_obs),
                "per_eq": per_eq,
            }
        )

    # Freeze C per-eq as the median over nuclei with A>=freeze_min_a.
    c_frozen: dict[int, float] = {}
    for eq in eq_labels:
        vals = [
            float(r["per_eq"][eq]["C_est_from_radii"])
            for r in rows
            if int(r["A"]) >= int(freeze_min_a) and math.isfinite(float(r["per_eq"][eq]["C_est_from_radii"]))
        ]
        if not vals:
            raise SystemExit(f"[fail] no valid C estimates for eq{eq} with A>=freeze_min_a={freeze_min_a}")
        vals2 = sorted(vals)
        mid = len(vals2) // 2
        c_med = vals2[mid] if (len(vals2) % 2 == 1) else 0.5 * (vals2[mid - 1] + vals2[mid])
        c_frozen[int(eq)] = float(c_med)

    stats: dict[int, dict[str, float]] = {}
    for eq in eq_labels:
        c = float(c_frozen[int(eq)])
        res: list[float] = []
        for r in rows:
            rho = float(r["rho_fm3"])
            e_base = float(r["per_eq"][eq]["E_base_MeV_per_A"])
            e_rep = float(c) * (rho**repulsion_power)
            e_total = e_base + e_rep
            ba_pred = -float(e_total)
            ba_obs = float(r["B_over_A_obs_MeV"])
            r["per_eq"][eq].update(
                {
                    "C_frozen": float(c),
                    "E_rep_MeV_per_A": float(e_rep),
                    "E_total_MeV_per_A": float(e_total),
                    "B_over_A_pred_MeV": float(ba_pred),
                    "B_over_A_residual_MeV": float(ba_pred - ba_obs),
                }
            )
            res.append(float(ba_pred - ba_obs))

        rms = math.sqrt(sum(x * x for x in res) / len(res)) if res else float("nan")
        mean = sum(res) / len(res) if res else float("nan")
        stats[int(eq)] = {"residual_mean_MeV": float(mean), "residual_rms_MeV": float(rms)}

    best_eq = min(eq_labels, key=lambda eq: float(stats[eq]["residual_rms_MeV"]))

    # Plot
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    ba_obs_vals = [float(r["B_over_A_obs_MeV"]) for r in rows]
    labels = [str(r["label"]) for r in rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.scatter(a13, ba_obs_vals, s=45, label="obs (AME2020)")
    for eq in eq_labels:
        ba_pred = [float(r["per_eq"][eq]["B_over_A_pred_MeV"]) for r in rows]
        ax.plot(a13, ba_pred, marker="o", linestyle="--", label=f"pred (C frozen by radii; eq{eq})")
    ax.set_title("B/A: obs vs pred (C frozen by radii equilibrium)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab in zip(a13, ba_obs_vals, labels, strict=True):
        ax.annotate(lab, (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8)

    ax = axes[0][1]
    t_vals = [float(r["per_eq"][best_eq]["T_kin_MeV_per_A"]) for r in rows]
    u_vals = [float(r["per_eq"][best_eq]["U_pot_MeV_per_A"]) for r in rows]
    c_vals = [float(r["per_eq"][best_eq]["E_coul_MeV_per_A"]) for r in rows]
    rep_vals = [float(r["per_eq"][best_eq]["E_rep_MeV_per_A"]) for r in rows]
    ax.plot(a13, t_vals, marker=".", linestyle="-", label="T (2-comp Fermi)")
    ax.plot(a13, u_vals, marker=".", linestyle="--", label="U (Hartree)")
    ax.plot(a13, c_vals, marker=".", linestyle=":", label="Coulomb")
    ax.plot(a13, rep_vals, marker=".", linestyle="-.", label=f"repulsion (eq{best_eq})")
    ax.set_title(f"Contributions (best RMS: eq{best_eq})")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("MeV per nucleon")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8, ncol=2)

    ax = axes[1][0]
    rho_vals = [float(r["rho_fm3"]) for r in rows]
    ax.plot(a13, rho_vals, marker="o", linestyle="-", color="tab:purple")
    ax.set_title("Density estimate from charge radii")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("ρ (fm^-3)")
    ax.grid(True, alpha=0.3)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "Model: 2-comp Fermi + Hartree + Coulomb + density repulsion",
        "Repulsion: E_rep/A = C * ρ^2",
        f"Freeze C: radii equilibrium (median over A>={freeze_min_a})",
        f"pn_triplet_weight={pn_triplet_weight:.2f}, dE/dR eps_rel={derivative_eps_rel:.3g}",
        "",
        "Frozen C (per eq):",
    ]
    for eq in eq_labels:
        lines.append(f"  - eq{eq}: C={c_frozen[eq]:.6g} (RMS={stats[eq]['residual_rms_MeV']:.3g} MeV)")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_mean_field_repulsion_radii_frozen.png"
    fig.suptitle("Phase 7 / Step 7.13.14: A-dependence (C frozen by radii equilibrium)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    # CSV
    out_csv = out_dir / "nuclear_a_dependence_mean_field_repulsion_radii_frozen.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "r_charge_fm",
            "R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
        ]
        for eq in eq_labels:
            header.extend(
                [
                    f"C_frozen_eq{eq}",
                    f"C_est_from_radii_eq{eq}",
                    f"dEbase_dR_eq{eq}_MeV_per_fm",
                    f"T_kin_eq{eq}_MeV_per_A",
                    f"U_pot_eq{eq}_MeV_per_A",
                    f"E_coul_eq{eq}_MeV_per_A",
                    f"E_rep_eq{eq}_MeV_per_A",
                    f"B_over_A_pred_eq{eq}_MeV",
                    f"residual_eq{eq}_MeV",
                ]
            )
        w.writerow(header)
        for r in rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                f"{float(r['r_charge_fm']):.12g}",
                f"{float(r['R_sharp_fm']):.12g}",
                f"{float(r['rho_fm3']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
            ]
            for eq in eq_labels:
                pe = r["per_eq"][eq]
                row.extend(
                    [
                        f"{float(pe['C_frozen']):.12g}",
                        f"{float(pe['C_est_from_radii']):.12g}",
                        f"{float(pe['dEbase_dR_MeV_per_fm']):.12g}",
                        f"{float(pe['T_kin_MeV_per_A']):.12g}",
                        f"{float(pe['U_pot_MeV_per_A']):.12g}",
                        f"{float(pe['E_coul_MeV_per_A']):.12g}",
                        f"{float(pe['E_rep_MeV_per_A']):.12g}",
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_mean_field_repulsion_radii_frozen_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.14",
                "inputs": {
                    "potential_metrics": potential_metrics_input,
                    "potential_metrics_7_13_8": potential_metrics_input,
                    "targets_7_13_11": {"path": str(rep_path), "sha256": _sha256(rep_path)},
                },
                "model": {
                    "type": "uniform_sphere_mean_field_repulsion_radii_frozen",
                    "pair_channels": {"pp_nn": "singlet", "pn_triplet_weight": pn_triplet_weight},
                    "kinetic": "nonrelativistic 2-component Fermi gas",
                    "coulomb": "(3/5)e^2 Z(Z-1)/R",
                    "repulsion": {
                        "form": "E_rep/A = C*rho^n",
                        "n": repulsion_power,
                        "freeze": {"method": "radii equilibrium (dE/dR=0)", "freeze_min_A": freeze_min_a, "derivative_eps_rel": derivative_eps_rel},
                        "C_frozen_by_eq": c_frozen,
                    },
                },
                "constants": {"hbarc_MeV_fm": hbarc, "m_nucleon_c2_MeV": m_nucleon_c2},
                "stats": stats,
                "rows": rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15(*, out_dir: Path, pn_triplet_weight: float, freeze_min_a: int, derivative_eps_rel: float) -> None:
    """
    Step 7.13.15 (initial): Explicitly include an exchange/Fock (Pauli) term for like-nucleon pairs
    (pp/nn) in a uniform-matter Hartree-Fock approximation, and keep the residual many-body repulsion
    as a 3-body proxy E_3/A = C3 * ρ^2 whose C3 is frozen by a radii-equilibrium condition (dE/dR=0).
    """
    common = _load_common_inputs(out_dir=out_dir)
    metrics_7138_path = Path(str(common["metrics_7138_path"]))
    potential_metrics_input = dict(common.get("potential_metrics_input") or {})
    rep_path = Path(str(common["rep_path"]))
    nuclei = common["nuclei"]
    consts = common["constants"]
    pot_sets = common["pot_sets"]
    eq_labels = common["eq_labels"]

    if not (math.isfinite(derivative_eps_rel) and 0.0 < derivative_eps_rel < 0.05):
        raise SystemExit("[fail] derivative_eps_rel must be in (0, 0.05)")
    if freeze_min_a < 1:
        raise SystemExit("[fail] freeze_min_a must be >= 1")

    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    repulsion_power = 2.0

    def eval_base(*, A: int, Z: int, N: int, R_sharp_fm: float, eq: int) -> dict[str, float]:
        if not (A > 0 and Z >= 0 and N >= 0 and (Z + N) == A):
            return {"T": float("nan"), "U_H": float("nan"), "U_F": float("nan"), "Coul": float("nan"), "E_base": float("nan")}
        if not (math.isfinite(R_sharp_fm) and R_sharp_fm > 0):
            return {"T": float("nan"), "U_H": float("nan"), "U_F": float("nan"), "Coul": float("nan"), "E_base": float("nan")}

        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp_fm) ** 3
        rho = float(A) / float(V_sphere)
        rho_p = float(Z) / float(V_sphere)
        rho_n = float(N) / float(V_sphere)

        # Two-component kinetic (already includes Pauli via Fermi momentum).
        kin = _fermi_kinetic_energy_two_component_mev_per_a(Z=Z, N=N, volume_fm3=V_sphere, hbarc_mev_fm=hbarc, m_nucleon_c2_mev=m_nucleon_c2)
        t_total = float(kin["T_total_MeV_per_A"])

        e_coul = _coulomb_energy_uniform_sphere_mev_per_a(Z=Z, A=A, R_sharp_fm=float(R_sharp_fm))

        # HF potential: pp/nn use singlet channel; pn uses a fixed mix in Hartree only.
        s = pot_sets[int(eq)]
        geom = s["geometry"]
        tri = s["triplet"]
        sin = s["singlet"]

        I0_s = _integral_I0_mev_fm3(geometry=geom, V1_MeV=float(sin["V1_MeV"]), V2_MeV=float(sin["V2_MeV"]), Vb_MeV=float(sin["Vb_MeV"]), Vt_MeV=float(sin["Vt_MeV"]))
        I0_t = _integral_I0_mev_fm3(geometry=geom, V1_MeV=float(tri["V1_MeV"]), V2_MeV=float(tri["V2_MeV"]), Vb_MeV=float(tri["Vb_MeV"]), Vt_MeV=float(tri["Vt_MeV"]))
        I0_pn = float(pn_triplet_weight) * float(I0_t) + (1.0 - float(pn_triplet_weight)) * float(I0_s)

        # Exchange integrals for like species (spin degeneracy g=2 -> factor 1/2).
        kf_p = float(kin["kf_p_fm1"])
        kf_n = float(kin["kf_n_fm1"])
        Iex_p = _integral_Iex_mev_fm3(
            geometry=geom,
            V1_MeV=float(sin["V1_MeV"]),
            V2_MeV=float(sin["V2_MeV"]),
            Vb_MeV=float(sin["Vb_MeV"]),
            Vt_MeV=float(sin["Vt_MeV"]),
            kf_fm1=kf_p,
        )
        Iex_n = _integral_Iex_mev_fm3(
            geometry=geom,
            V1_MeV=float(sin["V1_MeV"]),
            V2_MeV=float(sin["V2_MeV"]),
            Vb_MeV=float(sin["Vb_MeV"]),
            Vt_MeV=float(sin["Vt_MeV"]),
            kf_fm1=kf_n,
        )

        # Hartree per-particle (pair counting; distinguishable pn has no 1/2).
        u_h = (rho_p * rho_p / (2.0 * rho)) * float(I0_s) + (rho_n * rho_n / (2.0 * rho)) * float(I0_s) + (rho_p * rho_n / rho) * float(I0_pn)

        # Fock per-particle (only identical species; factor 1/(2g) with g=2 -> 1/4).
        u_f = -0.25 * (rho_p * rho_p / rho) * float(Iex_p) - 0.25 * (rho_n * rho_n / rho) * float(Iex_n)

        e_base = float(t_total) + float(u_h) + float(u_f) + float(e_coul)
        return {"T": float(t_total), "U_H": float(u_h), "U_F": float(u_f), "Coul": float(e_coul), "E_base": float(e_base)}

    rows: list[dict[str, object]] = []
    for nuc in nuclei:
        if not isinstance(nuc, dict):
            continue
        A = int(nuc["A"])
        Z = int(nuc["Z"])
        N = int(nuc["N"])
        key = str(nuc["key"])
        label = str(nuc["label"])
        ba_obs = float(nuc["binding_energy_per_nucleon_MeV"])
        r_charge = float(nuc["charge_radius_fm"])

        R_sharp = _sharp_radius_from_rms(r_charge)
        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho = float(A) / float(V_sphere)

        per_eq: dict[int, dict[str, float]] = {}
        for eq in eq_labels:
            base = eval_base(A=A, Z=Z, N=N, R_sharp_fm=float(R_sharp), eq=int(eq))
            dR = float(derivative_eps_rel) * float(R_sharp)
            base_p = eval_base(A=A, Z=Z, N=N, R_sharp_fm=float(R_sharp) + dR, eq=int(eq))
            base_m = eval_base(A=A, Z=Z, N=N, R_sharp_fm=float(R_sharp) - dR, eq=int(eq))
            dE_dR = (float(base_p["E_base"]) - float(base_m["E_base"])) / (2.0 * float(dR)) if dR > 0 else float("nan")

            denom = 3.0 * float(repulsion_power) * (float(rho) ** float(repulsion_power))
            c3_est = (float(R_sharp) * float(dE_dR) / denom) if (math.isfinite(denom) and denom > 0) else float("nan")

            per_eq[int(eq)] = {
                "T_kin_MeV_per_A": float(base["T"]),
                "U_H_MeV_per_A": float(base["U_H"]),
                "U_F_MeV_per_A": float(base["U_F"]),
                "E_coul_MeV_per_A": float(base["Coul"]),
                "E_base_MeV_per_A": float(base["E_base"]),
                "dEbase_dR_MeV_per_fm": float(dE_dR),
                "C3_est_from_radii": float(c3_est),
            }

        rows.append(
            {
                "key": key,
                "label": label,
                "A": int(A),
                "Z": int(Z),
                "N": int(N),
                "r_charge_fm": float(r_charge),
                "R_sharp_fm": float(R_sharp),
                "rho_fm3": float(rho),
                "B_over_A_obs_MeV": float(ba_obs),
                "per_eq": per_eq,
            }
        )

    c3_frozen: dict[int, float] = {}
    for eq in eq_labels:
        vals = [
            float(r["per_eq"][eq]["C3_est_from_radii"])
            for r in rows
            if int(r["A"]) >= int(freeze_min_a) and math.isfinite(float(r["per_eq"][eq]["C3_est_from_radii"]))
        ]
        if not vals:
            raise SystemExit(f"[fail] no valid C3 estimates for eq{eq} with A>=freeze_min_a={freeze_min_a}")
        vals2 = sorted(vals)
        mid = len(vals2) // 2
        c_med = vals2[mid] if (len(vals2) % 2 == 1) else 0.5 * (vals2[mid - 1] + vals2[mid])
        c3_frozen[int(eq)] = float(c_med)

    stats: dict[int, dict[str, float]] = {}
    for eq in eq_labels:
        c3 = float(c3_frozen[int(eq)])
        res: list[float] = []
        for r in rows:
            rho = float(r["rho_fm3"])
            e_base = float(r["per_eq"][eq]["E_base_MeV_per_A"])
            e_3 = float(c3) * (rho**repulsion_power)
            e_total = e_base + e_3
            ba_pred = -float(e_total)
            ba_obs = float(r["B_over_A_obs_MeV"])
            r["per_eq"][eq].update(
                {
                    "C3_frozen": float(c3),
                    "E_3body_MeV_per_A": float(e_3),
                    "E_total_MeV_per_A": float(e_total),
                    "B_over_A_pred_MeV": float(ba_pred),
                    "B_over_A_residual_MeV": float(ba_pred - ba_obs),
                }
            )
            res.append(float(ba_pred - ba_obs))
        rms = math.sqrt(sum(x * x for x in res) / len(res)) if res else float("nan")
        mean = sum(res) / len(res) if res else float("nan")
        stats[int(eq)] = {"residual_mean_MeV": float(mean), "residual_rms_MeV": float(rms)}

    best_eq = min(eq_labels, key=lambda eq: float(stats[eq]["residual_rms_MeV"]))

    # Plot
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    ba_obs_vals = [float(r["B_over_A_obs_MeV"]) for r in rows]
    labels = [str(r["label"]) for r in rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.scatter(a13, ba_obs_vals, s=45, label="obs (AME2020)")
    for eq in eq_labels:
        ba_pred = [float(r["per_eq"][eq]["B_over_A_pred_MeV"]) for r in rows]
        ax.plot(a13, ba_pred, marker="o", linestyle="--", label=f"pred (HF + 3-body; eq{eq})")
    ax.set_title("B/A: obs vs pred (HF + 3-body; C3 frozen by radii)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab in zip(a13, ba_obs_vals, labels, strict=True):
        ax.annotate(lab, (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8)

    ax = axes[0][1]
    t_vals = [float(r["per_eq"][best_eq]["T_kin_MeV_per_A"]) for r in rows]
    uh_vals = [float(r["per_eq"][best_eq]["U_H_MeV_per_A"]) for r in rows]
    uf_vals = [float(r["per_eq"][best_eq]["U_F_MeV_per_A"]) for r in rows]
    c_vals = [float(r["per_eq"][best_eq]["E_coul_MeV_per_A"]) for r in rows]
    e3_vals = [float(r["per_eq"][best_eq]["E_3body_MeV_per_A"]) for r in rows]
    ax.plot(a13, t_vals, marker=".", linestyle="-", label="T (2-comp Fermi)")
    ax.plot(a13, uh_vals, marker=".", linestyle="--", label="U_H (Hartree)")
    ax.plot(a13, uf_vals, marker=".", linestyle=":", label="U_F (Fock)")
    ax.plot(a13, c_vals, marker=".", linestyle="-.", label="Coulomb")
    ax.plot(a13, e3_vals, marker=".", linestyle=(0, (3, 1, 1, 1)), label="3-body (C3 ρ^2)")
    ax.set_title(f"Contributions (best RMS: eq{best_eq})")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("MeV per nucleon")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8, ncol=2)

    ax = axes[1][0]
    rho_vals = [float(r["rho_fm3"]) for r in rows]
    ax.plot(a13, rho_vals, marker="o", linestyle="-", color="tab:purple")
    ax.set_title("Density estimate from charge radii")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("ρ (fm^-3)")
    ax.grid(True, alpha=0.3)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "Model: uniform-matter Hartree-Fock (pp/nn exchange) + Coulomb + 3-body proxy",
        "3-body: E_3/A = C3 * ρ^2",
        f"Freeze C3: radii equilibrium (median over A>={freeze_min_a})",
        f"pn_triplet_weight={pn_triplet_weight:.2f}, dE/dR eps_rel={derivative_eps_rel:.3g}",
        "",
        "Frozen C3 (per eq):",
    ]
    for eq in eq_labels:
        lines.append(f"  - eq{eq}: C3={c3_frozen[eq]:.6g} (RMS={stats[eq]['residual_rms_MeV']:.3g} MeV)")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen.png"
    fig.suptitle("Phase 7 / Step 7.13.15: A-dependence (HF + 3-body; C3 frozen by radii)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "r_charge_fm",
            "R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
        ]
        for eq in eq_labels:
            header.extend(
                [
                    f"C3_frozen_eq{eq}",
                    f"C3_est_from_radii_eq{eq}",
                    f"dEbase_dR_eq{eq}_MeV_per_fm",
                    f"T_kin_eq{eq}_MeV_per_A",
                    f"U_H_eq{eq}_MeV_per_A",
                    f"U_F_eq{eq}_MeV_per_A",
                    f"E_coul_eq{eq}_MeV_per_A",
                    f"E_3body_eq{eq}_MeV_per_A",
                    f"B_over_A_pred_eq{eq}_MeV",
                    f"residual_eq{eq}_MeV",
                ]
            )
        w.writerow(header)
        for r in rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                f"{float(r['r_charge_fm']):.12g}",
                f"{float(r['R_sharp_fm']):.12g}",
                f"{float(r['rho_fm3']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
            ]
            for eq in eq_labels:
                pe = r["per_eq"][eq]
                row.extend(
                    [
                        f"{float(pe['C3_frozen']):.12g}",
                        f"{float(pe['C3_est_from_radii']):.12g}",
                        f"{float(pe['dEbase_dR_MeV_per_fm']):.12g}",
                        f"{float(pe['T_kin_MeV_per_A']):.12g}",
                        f"{float(pe['U_H_MeV_per_A']):.12g}",
                        f"{float(pe['U_F_MeV_per_A']):.12g}",
                        f"{float(pe['E_coul_MeV_per_A']):.12g}",
                        f"{float(pe['E_3body_MeV_per_A']):.12g}",
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15",
                "inputs": {
                    "potential_metrics": potential_metrics_input,
                    "potential_metrics_7_13_8": potential_metrics_input,
                    "targets_7_13_11": {"path": str(rep_path), "sha256": _sha256(rep_path)},
                },
                "model": {
                    "type": "uniform_matter_hartree_fock_plus_three_body",
                    "pair_channels": {"pp_nn": "singlet (with Fock)", "pn": {"triplet_weight": pn_triplet_weight, "singlet_weight": 1.0 - pn_triplet_weight}},
                    "kinetic": "nonrelativistic 2-component Fermi gas",
                    "coulomb": "(3/5)e^2 Z(Z-1)/R",
                    "fock": {"like_species_only": True, "spin_deg_each": 2, "factor": "1/(2g)=1/4", "integral": "Iex=∫V f(kFr)^2 d^3r"},
                    "three_body": {
                        "form": "E_3/A = C3*rho^n",
                        "n": repulsion_power,
                        "freeze": {"method": "radii equilibrium (dE/dR=0)", "freeze_min_A": freeze_min_a, "derivative_eps_rel": derivative_eps_rel},
                        "C3_frozen_by_eq": c3_frozen,
                    },
                },
                "constants": {"hbarc_MeV_fm": hbarc, "m_nucleon_c2_MeV": m_nucleon_c2},
                "stats": stats,
                "rows": rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_2(*, out_dir: Path) -> None:
    """
    Step 7.13.15.2 (initial): Add a nucleus-by-nucleus uncertainty/systematics view using
    primary σ from representative nuclei (AME2020 B/A σ, IAEA charge radius σ).

    This step does NOT refit to B/A; it post-processes the frozen HF+3-body output and
    quantifies:
      - sensitivity to charge radius uncertainty (via d(B/A)/dR),
      - spread of C3 estimates across heavy nuclei (as a systematic on frozen C3).
    """
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)

    rep_path = out_dir / "nuclear_binding_representative_nuclei_metrics.json"
    if not rep_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.11 baseline metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_binding_representative_nuclei.py\n"
            f"Expected: {rep_path}"
        )
    rep = _load_json(rep_path)
    rep_nuclei = rep.get("nuclei")
    if not isinstance(rep_nuclei, list) or not rep_nuclei:
        raise SystemExit(f"[fail] invalid representative nuclei metrics: nuclei missing/empty: {rep_path}")

    sigma_by_key: dict[str, dict[str, float]] = {}
    for n in rep_nuclei:
        if not isinstance(n, dict):
            continue
        key = str(n.get("key"))
        sigma_by_key[key] = {
            "sigma_ba_obs_MeV": float(n.get("binding_energy_per_nucleon_sigma_MeV", float("nan"))),
            "sigma_r_charge_fm": float(n.get("charge_radius_sigma_fm", float("nan"))),
        }

    rows = hf.get("rows")
    if not isinstance(rows, list) or not rows:
        raise SystemExit(f"[fail] invalid hf metrics: rows missing/empty: {metrics_hf_path}")

    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    three_body = model.get("three_body") if isinstance(model.get("three_body"), dict) else {}
    freeze = three_body.get("freeze") if isinstance(three_body.get("freeze"), dict) else {}
    freeze_min_a = int(freeze.get("freeze_min_A", 40))
    pn_triplet_weight = float((model.get("pair_channels") or {}).get("pn", {}).get("triplet_weight", 0.5)) if isinstance(model.get("pair_channels"), dict) else 0.5

    stats_in = hf.get("stats")
    if not isinstance(stats_in, dict) or not stats_in:
        raise SystemExit(f"[fail] invalid hf metrics: stats missing/empty: {metrics_hf_path}")
    eq_labels = sorted(int(k) for k in stats_in.keys())

    c3_frozen_by_eq = three_body.get("C3_frozen_by_eq")
    if not isinstance(c3_frozen_by_eq, dict) or not c3_frozen_by_eq:
        raise SystemExit(f"[fail] invalid hf metrics: model.three_body.C3_frozen_by_eq missing/empty: {metrics_hf_path}")

    # Robust scatter (MAD) of C3 estimates across heavy nuclei.
    def median(vals: list[float]) -> float:
        v = sorted(vals)
        m = len(v) // 2
        return v[m] if (len(v) % 2 == 1) else 0.5 * (v[m - 1] + v[m])

    c3_sigma_by_eq: dict[int, float] = {}
    c3_heavy_vals_by_eq: dict[int, list[float]] = {}
    for eq in eq_labels:
        k = str(eq)
        vals = [
            float(r["per_eq"][k]["C3_est_from_radii"])
            for r in rows
            if isinstance(r, dict)
            and int(r.get("A", 0)) >= freeze_min_a
            and isinstance(r.get("per_eq"), dict)
            and k in r["per_eq"]
            and math.isfinite(float(r["per_eq"][k]["C3_est_from_radii"]))
        ]
        if not vals:
            raise SystemExit(f"[fail] no valid C3_est_from_radii for eq{eq} with A>=freeze_min_A={freeze_min_a}")
        c3_heavy_vals_by_eq[int(eq)] = vals
        m = median(vals)
        mad = median([abs(x - m) for x in vals])
        c3_sigma_by_eq[int(eq)] = float(1.4826 * mad)

    # Per-nucleus derived uncertainty budget
    out_rows: list[dict[str, object]] = []
    for r in rows:
        if not isinstance(r, dict):
            continue
        key = str(r.get("key"))
        A = int(r.get("A", 0))
        if key not in sigma_by_key:
            raise SystemExit(f"[fail] missing sigma for nucleus key={key} in {rep_path}")
        sig = sigma_by_key[key]
        sigma_r = float(sig["sigma_r_charge_fm"])
        sigma_ba_obs = float(sig["sigma_ba_obs_MeV"])
        sigma_R_sharp = math.sqrt(5.0 / 3.0) * sigma_r if math.isfinite(sigma_r) else float("nan")

        item: dict[str, object] = {
            "key": key,
            "label": str(r.get("label")),
            "A": A,
            "Z": int(r.get("Z", 0)),
            "N": int(r.get("N", 0)),
            "r_charge_fm": float(r.get("r_charge_fm", float("nan"))),
            "R_sharp_fm": float(r.get("R_sharp_fm", float("nan"))),
            "rho_fm3": float(r.get("rho_fm3", float("nan"))),
            "B_over_A_obs_MeV": float(r.get("B_over_A_obs_MeV", float("nan"))),
            "sigma_r_charge_fm": float(sigma_r),
            "sigma_R_sharp_fm": float(sigma_R_sharp),
            "sigma_B_over_A_obs_MeV": float(sigma_ba_obs),
            "per_eq": {},
        }

        per_eq_out: dict[str, dict[str, float]] = {}
        per_eq = r.get("per_eq")
        if not isinstance(per_eq, dict):
            raise SystemExit(f"[fail] invalid per_eq in hf metrics row: key={key}")
        for eq in eq_labels:
            k = str(eq)
            pe = per_eq.get(k)
            if not isinstance(pe, dict):
                raise SystemExit(f"[fail] missing per_eq[{k}] in hf metrics row: key={key}")

            rho = float(item["rho_fm3"])
            R = float(item["R_sharp_fm"])
            c3 = float(c3_frozen_by_eq[k])
            dEbase_dR = float(pe.get("dEbase_dR_MeV_per_fm", float("nan")))

            # dE_total/dR = dE_base/dR - 6 C3 rho^2 / R  (since rho ∝ R^-3)
            dEtotal_dR = float(dEbase_dR) - (6.0 * float(c3) * (rho**2) / float(R)) if (R > 0 and math.isfinite(R)) else float("nan")
            dBA_dR = -float(dEtotal_dR)

            sigma_ba_from_r = abs(float(dBA_dR)) * float(sigma_R_sharp) if math.isfinite(sigma_R_sharp) else float("nan")
            sigma_c3 = float(c3_sigma_by_eq[int(eq)])
            sigma_ba_from_c3 = (rho**2) * float(sigma_c3) if math.isfinite(sigma_c3) else float("nan")
            sigma_tot = math.sqrt(float(sigma_ba_from_r) ** 2 + float(sigma_ba_from_c3) ** 2 + float(sigma_ba_obs) ** 2)

            ba_pred = float(pe.get("B_over_A_pred_MeV", float("nan")))
            ba_obs = float(item["B_over_A_obs_MeV"])
            residual = float(ba_pred - ba_obs)
            z = residual / sigma_tot if (math.isfinite(sigma_tot) and sigma_tot > 0) else float("nan")

            per_eq_out[k] = {
                "B_over_A_pred_MeV": float(ba_pred),
                "B_over_A_residual_MeV": float(residual),
                "sigma_BA_from_radii_MeV": float(sigma_ba_from_r),
                "sigma_BA_from_C3_MeV": float(sigma_ba_from_c3),
                "sigma_total_MeV": float(sigma_tot),
                "z_residual": float(z),
                "C3_frozen": float(c3),
                "C3_sigma_robust": float(sigma_c3),
            }

        item["per_eq"] = per_eq_out
        out_rows.append(item)

    # Aggregate chi2-like diagnostics (using sigma_total).
    diag: dict[str, object] = {
        "freeze_min_A": freeze_min_a,
        "pn_triplet_weight": pn_triplet_weight,
        "C3_sigma_robust_by_eq": c3_sigma_by_eq,
    }
    for eq in eq_labels:
        k = str(eq)
        z2 = [float(r["per_eq"][k]["z_residual"]) ** 2 for r in out_rows if math.isfinite(float(r["per_eq"][k]["z_residual"]))]  # type: ignore[index]
        diag[f"chi2_like_eq{eq}"] = float(sum(z2))
        diag[f"n_eq{eq}"] = int(len(z2))

    # Plot
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in out_rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    ba_obs_vals = [float(r["B_over_A_obs_MeV"]) for r in out_rows]
    labels = [str(r["label"]) for r in out_rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.errorbar(a13, ba_obs_vals, yerr=[float(r["sigma_B_over_A_obs_MeV"]) for r in out_rows], fmt="o", ms=4, label="obs (AME2020)")
    for eq in eq_labels:
        k = str(eq)
        ba_pred = [float(r["per_eq"][k]["B_over_A_pred_MeV"]) for r in out_rows]
        yerr = [float(r["per_eq"][k]["sigma_total_MeV"]) for r in out_rows]
        ax.errorbar(a13, ba_pred, yerr=yerr, fmt="o", ms=4, linestyle="--", label=f"pred ±σ_total (eq{eq})")
    ax.set_title("B/A with uncertainty budget (HF+3-body; C3 frozen by radii)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab in zip(a13, ba_obs_vals, labels, strict=True):
        ax.annotate(lab, (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8)

    ax = axes[0][1]
    for eq in eq_labels:
        k = str(eq)
        heavy = [(int(r["A"]), float(r["per_eq"][k]["C3_est_from_radii"])) for r in rows if isinstance(r, dict) and int(r.get("A", 0)) >= freeze_min_a]  # type: ignore[index]
        xs = [a ** (1.0 / 3.0) for a, _ in heavy]
        ys = [v for _, v in heavy]
        ax.scatter(xs, ys, s=35, label=f"C3_est (eq{eq})")
        c3 = float(c3_frozen_by_eq[k])
        sig = float(c3_sigma_by_eq[int(eq)])
        ax.axhline(c3, linestyle="--")
        ax.fill_between([min(xs), max(xs)], [c3 - sig, c3 - sig], [c3 + sig, c3 + sig], alpha=0.15)
    ax.set_title(f"C3 estimates from radii equilibrium (A>={freeze_min_a})")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("C3 (MeV·fm^6)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][0]
    for eq in eq_labels:
        k = str(eq)
        s_r = [float(r["per_eq"][k]["sigma_BA_from_radii_MeV"]) for r in out_rows]
        s_c = [float(r["per_eq"][k]["sigma_BA_from_C3_MeV"]) for r in out_rows]
        ax.plot(a13, s_r, marker=".", linestyle="-", label=f"σ_radii (eq{eq})")
        ax.plot(a13, s_c, marker=".", linestyle="--", label=f"σ_C3 (eq{eq})")
    ax.set_title("Uncertainty components")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("σ (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8, ncol=2)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "Post-process: Step 7.13.15 output",
        f"freeze_min_A={freeze_min_a}, pn_triplet_weight≈{pn_triplet_weight:.2f}",
        "",
        "Robust C3 scatter (MAD→σ):",
    ]
    for eq in eq_labels:
        lines.append(f"  - eq{eq}: σ_C3≈{c3_sigma_by_eq[int(eq)]:.3g} MeV·fm^6")
    lines.append("")
    for eq in eq_labels:
        lines.append(f"chi2-like(eq{eq})≈{diag[f'chi2_like_eq{eq}']:.3g}  (N={diag[f'n_eq{eq}']})")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty.png"
    fig.suptitle("Phase 7 / Step 7.13.15.2: HF+3-body uncertainty budget (radii-driven)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "r_charge_fm",
            "sigma_r_charge_fm",
            "R_sharp_fm",
            "sigma_R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
            "sigma_B_over_A_obs_MeV",
        ]
        for eq in eq_labels:
            header.extend(
                [
                    f"B_over_A_pred_eq{eq}_MeV",
                    f"residual_eq{eq}_MeV",
                    f"sigma_total_eq{eq}_MeV",
                    f"sigma_radii_eq{eq}_MeV",
                    f"sigma_C3_eq{eq}_MeV",
                    f"z_eq{eq}",
                ]
            )
        w.writerow(header)
        for r in out_rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                f"{float(r['r_charge_fm']):.12g}",
                f"{float(r['sigma_r_charge_fm']):.12g}",
                f"{float(r['R_sharp_fm']):.12g}",
                f"{float(r['sigma_R_sharp_fm']):.12g}",
                f"{float(r['rho_fm3']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
                f"{float(r['sigma_B_over_A_obs_MeV']):.12g}",
            ]
            for eq in eq_labels:
                k = str(eq)
                pe = r["per_eq"][k]
                row.extend(
                    [
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                        f"{float(pe['sigma_total_MeV']):.12g}",
                        f"{float(pe['sigma_BA_from_radii_MeV']):.12g}",
                        f"{float(pe['sigma_BA_from_C3_MeV']):.12g}",
                        f"{float(pe['z_residual']):.12g}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.2",
                "inputs": {
                    "hf_metrics_7_13_15_1": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "targets_7_13_11": {"path": str(rep_path), "sha256": _sha256(rep_path)},
                },
                "diag": diag,
                "C3_frozen_by_eq": c3_frozen_by_eq,
                "C3_heavy_vals_by_eq": c3_heavy_vals_by_eq,
                "rows": out_rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_3(*, out_dir: Path) -> None:
    """
    Step 7.13.15.3 (initial): Add an additional *dataset/systematic* term that represents the
    spread between eq18/eq19 potential sets (ultimately constrained by low-energy np scattering).

    We treat the half-difference of predictions as a conservative systematic:
      sigma_set = 0.5 * |B/A_pred(eq18) - B/A_pred(eq19)|

    Then compare the *mean* prediction to observation using:
      pred_mean = 0.5*(pred18 + pred19)
      sigma_base^2 = 0.5*(sigma_total18^2 + sigma_total19^2)
      sigma_total_with_set = sqrt(sigma_base^2 + sigma_set^2)

    This does NOT refit or choose the better eq; it fixes a rejection-style budget that is robust
    against the (eq18 vs eq19) input-set ambiguity.
    """
    metrics_7152_path = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_metrics.json"
    if not metrics_7152_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.2 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.2\n"
            f"Expected: {metrics_7152_path}"
        )
    m = _load_json(metrics_7152_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.2 metrics: rows missing/empty: {metrics_7152_path}")

    # Require exactly eq18/eq19 for the initial scatter-systematics definition.
    eq_labels = ["18", "19"]
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        per_eq = r.get("per_eq")
        if not isinstance(per_eq, dict) or any(k not in per_eq for k in eq_labels):
            raise SystemExit(f"[fail] 7.13.15.2 row missing per_eq for eq18/eq19: key={r.get('key')}")

    out_rows: list[dict[str, object]] = []
    z_vals: list[float] = []
    sigma_set_vals: list[float] = []

    for r in rows_in:
        assert isinstance(r, dict)
        per_eq = r["per_eq"]
        assert isinstance(per_eq, dict)

        obs = float(r.get("B_over_A_obs_MeV", float("nan")))
        sig_obs = float(r.get("sigma_B_over_A_obs_MeV", float("nan")))

        pe18 = per_eq["18"]
        pe19 = per_eq["19"]
        if not isinstance(pe18, dict) or not isinstance(pe19, dict):
            raise SystemExit(f"[fail] invalid per_eq mapping for key={r.get('key')}")

        pred18 = float(pe18.get("B_over_A_pred_MeV", float("nan")))
        pred19 = float(pe19.get("B_over_A_pred_MeV", float("nan")))
        sig18 = float(pe18.get("sigma_total_MeV", float("nan")))
        sig19 = float(pe19.get("sigma_total_MeV", float("nan")))
        sig_r18 = float(pe18.get("sigma_BA_from_radii_MeV", float("nan")))
        sig_r19 = float(pe19.get("sigma_BA_from_radii_MeV", float("nan")))
        sig_c18 = float(pe18.get("sigma_BA_from_C3_MeV", float("nan")))
        sig_c19 = float(pe19.get("sigma_BA_from_C3_MeV", float("nan")))

        pred_mean = 0.5 * (pred18 + pred19)
        residual_mean = pred_mean - obs
        sigma_set = 0.5 * abs(pred18 - pred19)
        sigma_base_sq = 0.5 * (sig18**2 + sig19**2)
        sigma_total = math.sqrt(sigma_base_sq + sigma_set**2)
        z = residual_mean / sigma_total if (math.isfinite(sigma_total) and sigma_total > 0) else float("nan")

        if math.isfinite(z):
            z_vals.append(float(z))
        if math.isfinite(sigma_set):
            sigma_set_vals.append(float(sigma_set))

        out_rows.append(
            {
                "key": str(r.get("key")),
                "label": str(r.get("label")),
                "A": int(r.get("A", 0)),
                "Z": int(r.get("Z", 0)),
                "N": int(r.get("N", 0)),
                "r_charge_fm": float(r.get("r_charge_fm", float("nan"))),
                "sigma_r_charge_fm": float(r.get("sigma_r_charge_fm", float("nan"))),
                "R_sharp_fm": float(r.get("R_sharp_fm", float("nan"))),
                "sigma_R_sharp_fm": float(r.get("sigma_R_sharp_fm", float("nan"))),
                "rho_fm3": float(r.get("rho_fm3", float("nan"))),
                "B_over_A_obs_MeV": float(obs),
                "sigma_B_over_A_obs_MeV": float(sig_obs),
                "B_over_A_pred_eq18_MeV": float(pred18),
                "B_over_A_pred_eq19_MeV": float(pred19),
                "sigma_total_eq18_MeV": float(sig18),
                "sigma_total_eq19_MeV": float(sig19),
                "sigma_radii_rms_MeV": float(math.sqrt(0.5 * (sig_r18**2 + sig_r19**2))),
                "sigma_C3_rms_MeV": float(math.sqrt(0.5 * (sig_c18**2 + sig_c19**2))),
                "sigma_set_MeV": float(sigma_set),
                "B_over_A_pred_mean_MeV": float(pred_mean),
                "residual_mean_MeV": float(residual_mean),
                "sigma_total_with_set_MeV": float(sigma_total),
                "z_mean": float(z),
            }
        )

    def _median(vals: list[float]) -> float:
        v = sorted(vals)
        if not v:
            return float("nan")
        m = len(v) // 2
        return v[m] if (len(v) % 2 == 1) else 0.5 * (v[m - 1] + v[m])

    n = len(z_vals)
    chi2_like = float(sum(float(z) ** 2 for z in z_vals)) if z_vals else float("nan")
    mean_abs_z = float(sum(abs(float(z)) for z in z_vals) / n) if n else float("nan")
    frac_within_3sigma = float(sum(1 for z in z_vals if abs(float(z)) <= 3.0) / n) if n else float("nan")

    diag = {
        "n": n,
        "chi2_like_mean": chi2_like,
        "mean_abs_z": mean_abs_z,
        "frac_within_3sigma": frac_within_3sigma,
        "sigma_set_median_MeV": float(_median(sigma_set_vals)),
        "sigma_set_max_MeV": float(max(sigma_set_vals)) if sigma_set_vals else float("nan"),
    }

    # Plot (2x2)
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in out_rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    labels = [str(r["label"]) for r in out_rows]
    obs_vals = [float(r["B_over_A_obs_MeV"]) for r in out_rows]
    obs_err = [float(r["sigma_B_over_A_obs_MeV"]) for r in out_rows]
    pred_mean_vals = [float(r["B_over_A_pred_mean_MeV"]) for r in out_rows]
    pred_err = [float(r["sigma_total_with_set_MeV"]) for r in out_rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.errorbar(a13, obs_vals, yerr=obs_err, fmt="o", ms=4, label="obs (AME2020)")
    ax.errorbar(a13, pred_mean_vals, yerr=pred_err, fmt="o", ms=4, linestyle="--", label="pred_mean ±σ_total(with set)")
    ax.set_title("B/A with radii+C3+obs σ plus eq18/eq19 set systematic")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab in zip(a13, obs_vals, labels, strict=True):
        ax.annotate(lab, (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8)

    ax = axes[0][1]
    sig_set = [float(r["sigma_set_MeV"]) for r in out_rows]
    ax.plot(a13, sig_set, marker="o", linestyle="-", color="tab:orange", label="σ_set = 0.5|eq18-eq19|")
    ax.set_title("Set/systematic term from eq18 vs eq19 spread")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("σ_set (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][0]
    sig_r = [float(r["sigma_radii_rms_MeV"]) for r in out_rows]
    sig_c = [float(r["sigma_C3_rms_MeV"]) for r in out_rows]
    ax.plot(a13, sig_r, marker=".", linestyle="-", label="σ_radii (RMS over eq18/eq19)")
    ax.plot(a13, sig_c, marker=".", linestyle="--", label="σ_C3 (RMS over eq18/eq19)")
    ax.plot(a13, obs_err, marker=".", linestyle=":", label="σ_obs (AME2020)")
    ax.plot(a13, sig_set, marker=".", linestyle="-.", label="σ_set (eq spread)")
    ax.set_title("Uncertainty components (RMS over eq sets + σ_set)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("σ (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8, ncol=2)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "Post-process: Step 7.13.15.2 output",
        "",
        "Definition:",
        "  σ_set = 0.5*|pred(eq18) - pred(eq19)|",
        "  pred_mean = 0.5*(pred18 + pred19)",
        "  σ_total = sqrt(0.5*(σ18^2+σ19^2) + σ_set^2)",
        "",
        f"chi2-like(mean)≈{diag['chi2_like_mean']:.3g}  (N={diag['n']})",
        f"mean |z|≈{diag['mean_abs_z']:.3g},  frac(|z|<=3)≈{diag['frac_within_3sigma']:.3g}",
        f"median σ_set≈{diag['sigma_set_median_MeV']:.3g} MeV",
    ]
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_set_systematic.png"
    fig.suptitle("Phase 7 / Step 7.13.15.3: add eq18/eq19 set systematic (scattering-set spread)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_set_systematic.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "r_charge_fm",
            "sigma_r_charge_fm",
            "R_sharp_fm",
            "sigma_R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
            "sigma_B_over_A_obs_MeV",
            "B_over_A_pred_eq18_MeV",
            "sigma_total_eq18_MeV",
            "B_over_A_pred_eq19_MeV",
            "sigma_total_eq19_MeV",
            "B_over_A_pred_mean_MeV",
            "residual_mean_MeV",
            "sigma_set_MeV",
            "sigma_total_with_set_MeV",
            "z_mean",
            "sigma_radii_rms_MeV",
            "sigma_C3_rms_MeV",
        ]
        w.writerow(header)
        for r in out_rows:
            w.writerow(
                [
                    r["key"],
                    r["label"],
                    int(r["A"]),
                    int(r["Z"]),
                    int(r["N"]),
                    f"{float(r['r_charge_fm']):.12g}",
                    f"{float(r['sigma_r_charge_fm']):.12g}",
                    f"{float(r['R_sharp_fm']):.12g}",
                    f"{float(r['sigma_R_sharp_fm']):.12g}",
                    f"{float(r['rho_fm3']):.12g}",
                    f"{float(r['B_over_A_obs_MeV']):.12g}",
                    f"{float(r['sigma_B_over_A_obs_MeV']):.12g}",
                    f"{float(r['B_over_A_pred_eq18_MeV']):.12g}",
                    f"{float(r['sigma_total_eq18_MeV']):.12g}",
                    f"{float(r['B_over_A_pred_eq19_MeV']):.12g}",
                    f"{float(r['sigma_total_eq19_MeV']):.12g}",
                    f"{float(r['B_over_A_pred_mean_MeV']):.12g}",
                    f"{float(r['residual_mean_MeV']):.12g}",
                    f"{float(r['sigma_set_MeV']):.12g}",
                    f"{float(r['sigma_total_with_set_MeV']):.12g}",
                    f"{float(r['z_mean']):.12g}",
                    f"{float(r['sigma_radii_rms_MeV']):.12g}",
                    f"{float(r['sigma_C3_rms_MeV']):.12g}",
                ]
            )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_set_systematic_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.3",
                "inputs": {"metrics_7_13_15_2": {"path": str(metrics_7152_path), "sha256": _sha256(metrics_7152_path)}},
                "definition": {
                    "sigma_set": "0.5*|pred_eq18 - pred_eq19|",
                    "pred_mean": "0.5*(pred_eq18 + pred_eq19)",
                    "sigma_total_with_set": "sqrt(0.5*(sigma_total_eq18^2 + sigma_total_eq19^2) + sigma_set^2)",
                },
                "diag": diag,
                "rows": out_rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_4(*, out_dir: Path) -> None:
    """
    Step 7.13.15.4 (initial): Add an independent radii-source systematic for light nuclei where
    CODATA (NIST Cuu) values exist, while the A-dependence baseline uses the IAEA radii compilation.

    This is a nucleus-by-nucleus "independent systematics" term:
      sigma_r_source = 0.5 * |r_charge(CODATA) - r_charge(IAEA)|

    Propagate via the already-computed |d(B/A)/dR| (inferred from sigma_radii and sigma_R_sharp):
      |d(B/A)/dR| ≈ sigma_BA_from_radii / sigma_R_sharp
      sigma_BA_from_r_source = |d(B/A)/dR| * sigma_R_source

    Then:
      sigma_total_plus_r_source = sqrt(sigma_total^2 + sigma_BA_from_r_source^2)

    This step does not refit any parameter and does not replace the primary radius choice; it
    makes the dependence on radius-source choice explicit (attack-resistant bookkeeping).
    """
    root = out_dir.parents[1]

    metrics_7152_path = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_metrics.json"
    if not metrics_7152_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.2 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.2\n"
            f"Expected: {metrics_7152_path}"
        )
    m = _load_json(metrics_7152_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.2 metrics: rows missing/empty: {metrics_7152_path}")

    # CODATA radii (light nuclei): rp, rd, ral. We need rd (d) and ral (alpha) here.
    codata_path = root / "data" / "quantum" / "sources" / "nist_codata_2022_nuclear_light_nuclei" / "extracted_values.json"
    if not codata_path.exists():
        raise SystemExit(
            "[fail] missing CODATA light-nuclei cache.\n"
            "Run:\n"
            "  python -B scripts/quantum/fetch_nuclear_binding_sources.py --out-dirname nist_codata_2022_nuclear_light_nuclei --include-light-nuclei\n"
            f"Expected: {codata_path}"
        )
    codata = _load_json(codata_path)
    constants = codata.get("constants")
    if not isinstance(constants, dict):
        raise SystemExit(f"[fail] invalid CODATA extracted_values.json: constants missing/invalid: {codata_path}")

    def _codata_r_fm(name: str) -> tuple[float, float]:
        c = constants.get(name)
        if not isinstance(c, dict):
            raise SystemExit(f"[fail] CODATA constant missing: {name} in {codata_path}")
        v_si = c.get("value_si")
        s_si = c.get("sigma_si")
        if not isinstance(v_si, (int, float)) or not math.isfinite(float(v_si)):
            raise SystemExit(f"[fail] invalid CODATA value_si for {name}")
        if not isinstance(s_si, (int, float)) or not math.isfinite(float(s_si)):
            raise SystemExit(f"[fail] invalid CODATA sigma_si for {name}")
        v_fm = float(v_si) * 1e15
        s_fm = float(s_si) * 1e15
        return v_fm, s_fm

    rd_fm, rd_sigma_fm = _codata_r_fm("rd")
    ral_fm, ral_sigma_fm = _codata_r_fm("ral")
    codata_radii = {
        "d": {"r_fm": rd_fm, "sigma_fm": rd_sigma_fm, "label": "CODATA rd (deuteron)"},
        "alpha": {"r_fm": ral_fm, "sigma_fm": ral_sigma_fm, "label": "CODATA ral (alpha)"},
    }

    # Determine per-row / per-eq updates.
    out_rows: list[dict[str, object]] = []
    z_by_eq: dict[str, list[float]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        key = str(r.get("key"))
        r_iaea = float(r.get("r_charge_fm", float("nan")))
        sigma_R_sharp = float(r.get("sigma_R_sharp_fm", float("nan")))

        r_codata = float("nan")
        r_codata_sigma = float("nan")
        delta_r = float("nan")
        sigma_r_source = 0.0
        if key in codata_radii and math.isfinite(r_iaea):
            r_codata = float(codata_radii[key]["r_fm"])
            r_codata_sigma = float(codata_radii[key]["sigma_fm"])
            delta_r = float(r_codata - r_iaea)
            sigma_r_source = 0.5 * abs(delta_r)

        sigma_R_source = _sharp_radius_from_rms(float(sigma_r_source)) if (math.isfinite(float(sigma_r_source)) and sigma_r_source > 0) else 0.0

        item: dict[str, object] = {
            "key": key,
            "label": str(r.get("label")),
            "A": int(r.get("A", 0)),
            "Z": int(r.get("Z", 0)),
            "N": int(r.get("N", 0)),
            "r_charge_iaea_fm": float(r_iaea),
            "sigma_r_charge_iaea_fm": float(r.get("sigma_r_charge_fm", float("nan"))),
            "r_charge_codata_fm": float(r_codata),
            "sigma_r_charge_codata_fm": float(r_codata_sigma),
            "delta_r_codata_minus_iaea_fm": float(delta_r),
            "sigma_r_source_fm": float(sigma_r_source),
            "sigma_R_sharp_fm": float(r.get("sigma_R_sharp_fm", float("nan"))),
            "sigma_R_source_fm": float(sigma_R_source),
            "B_over_A_obs_MeV": float(r.get("B_over_A_obs_MeV", float("nan"))),
            "sigma_B_over_A_obs_MeV": float(r.get("sigma_B_over_A_obs_MeV", float("nan"))),
            "per_eq": {},
        }

        per_eq_in = r.get("per_eq")
        if not isinstance(per_eq_in, dict):
            raise SystemExit(f"[fail] invalid per_eq in 7.13.15.2 row: key={key}")

        per_eq_out: dict[str, dict[str, float]] = {}
        for eq, pe in per_eq_in.items():
            if not isinstance(pe, dict):
                continue
            eqk = str(eq)
            sigma_tot = float(pe.get("sigma_total_MeV", float("nan")))
            sigma_r_mev = float(pe.get("sigma_BA_from_radii_MeV", float("nan")))
            residual = float(pe.get("B_over_A_residual_MeV", float("nan")))

            # Infer |d(B/A)/dR| from sigma_BA_from_radii and sigma_R_sharp.
            dBA_dR_abs = abs(sigma_r_mev) / float(sigma_R_sharp) if (math.isfinite(sigma_R_sharp) and sigma_R_sharp > 0 and math.isfinite(sigma_r_mev)) else float("nan")
            sigma_r_source_mev = float(dBA_dR_abs) * float(sigma_R_source) if (math.isfinite(dBA_dR_abs) and sigma_R_source > 0) else 0.0
            sigma_tot_plus = math.sqrt(float(sigma_tot) ** 2 + float(sigma_r_source_mev) ** 2) if (math.isfinite(sigma_tot) and math.isfinite(sigma_r_source_mev)) else float("nan")
            z = residual / sigma_tot_plus if (math.isfinite(sigma_tot_plus) and sigma_tot_plus > 0 and math.isfinite(residual)) else float("nan")

            if math.isfinite(z):
                z_by_eq.setdefault(eqk, []).append(float(z))

            per_eq_out[eqk] = {
                "B_over_A_pred_MeV": float(pe.get("B_over_A_pred_MeV", float("nan"))),
                "B_over_A_residual_MeV": float(residual),
                "sigma_total_MeV": float(sigma_tot),
                "sigma_BA_from_radii_MeV": float(sigma_r_mev),
                "sigma_BA_from_r_source_MeV": float(sigma_r_source_mev),
                "sigma_total_plus_r_source_MeV": float(sigma_tot_plus),
                "z_residual_plus_r_source": float(z),
            }
        item["per_eq"] = per_eq_out
        out_rows.append(item)

    # Diagnostics
    diag: dict[str, object] = {
        "n_rows": int(len(out_rows)),
        "radii_source": {
            "codata_path": str(codata_path),
            "used_keys": sorted([k for k in codata_radii.keys()]),
        },
    }
    for eqk, zs in z_by_eq.items():
        diag[f"chi2_like_eq{eqk}"] = float(sum(float(z) ** 2 for z in zs))
        diag[f"n_eq{eqk}"] = int(len(zs))
        diag[f"frac_within_3sigma_eq{eqk}"] = float(sum(1 for z in zs if abs(float(z)) <= 3.0) / len(zs)) if zs else float("nan")

    # Plot (2x2)
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in out_rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    labels = [str(r["label"]) for r in out_rows]
    obs_vals = [float(r["B_over_A_obs_MeV"]) for r in out_rows]
    obs_err = [float(r["sigma_B_over_A_obs_MeV"]) for r in out_rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.errorbar(a13, obs_vals, yerr=obs_err, fmt="o", ms=4, label="obs (AME2020)")
    for eqk in sorted(z_by_eq.keys(), key=int):
        pred = [float(r["per_eq"][eqk]["B_over_A_pred_MeV"]) for r in out_rows]
        yerr = [float(r["per_eq"][eqk]["sigma_total_plus_r_source_MeV"]) for r in out_rows]
        ax.errorbar(a13, pred, yerr=yerr, fmt="o", ms=4, linestyle="--", label=f"pred ±σ_total+r_source (eq{eqk})")
    ax.set_title("B/A with added radii-source systematic (CODATA vs IAEA)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab in zip(a13, obs_vals, labels, strict=True):
        ax.annotate(lab, (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8)

    ax = axes[0][1]
    sig_r_src = [float(r["sigma_r_source_fm"]) for r in out_rows]
    ax.plot(a13, sig_r_src, marker="o", linestyle="-", color="tab:olive", label="σ_r_source = 0.5|CODATA-IAEA|")
    ax.set_title("Independent radii-source systematic (fm)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("σ_r_source (fm)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][0]
    for eqk in sorted(z_by_eq.keys(), key=int):
        sig_mev = [float(r["per_eq"][eqk]["sigma_BA_from_r_source_MeV"]) for r in out_rows]
        ax.plot(a13, sig_mev, marker=".", linestyle="-", label=f"σ_BA(r_source) (eq{eqk})")
    ax.set_title("Propagated contribution to B/A (MeV)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("σ (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "Radii-source systematic:",
        "  σ_r_source = 0.5*|r(CODATA) - r(IAEA)|",
        "  σ_BA(r_source) = |d(B/A)/dR| * σ_R_source",
        "",
        f"CODATA: rd={rd_fm:.6g}±{rd_sigma_fm:.2g} fm, ral={ral_fm:.6g}±{ral_sigma_fm:.2g} fm",
    ]
    for eqk in sorted(z_by_eq.keys(), key=int):
        lines.append(f"chi2-like(eq{eqk})≈{diag[f'chi2_like_eq{eqk}']:.3g}  (N={diag[f'n_eq{eqk}']})")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_radii_source_systematic.png"
    fig.suptitle("Phase 7 / Step 7.13.15.4: add radii-source systematic (CODATA vs IAEA)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_radii_source_systematic.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "r_charge_iaea_fm",
            "sigma_r_charge_iaea_fm",
            "r_charge_codata_fm",
            "sigma_r_charge_codata_fm",
            "delta_r_codata_minus_iaea_fm",
            "sigma_r_source_fm",
            "sigma_R_source_fm",
            "B_over_A_obs_MeV",
            "sigma_B_over_A_obs_MeV",
        ]
        # stable eq order for output
        eqks = sorted(z_by_eq.keys(), key=int) if z_by_eq else sorted(out_rows[0]["per_eq"].keys(), key=int)  # type: ignore[union-attr]
        for eqk in eqks:
            header.extend(
                [
                    f"B_over_A_pred_eq{eqk}_MeV",
                    f"residual_eq{eqk}_MeV",
                    f"sigma_total_eq{eqk}_MeV",
                    f"sigma_BA_from_r_source_eq{eqk}_MeV",
                    f"sigma_total_plus_r_source_eq{eqk}_MeV",
                    f"z_plus_r_source_eq{eqk}",
                ]
            )
        w.writerow(header)
        for r in out_rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                f"{float(r['r_charge_iaea_fm']):.12g}",
                f"{float(r['sigma_r_charge_iaea_fm']):.12g}",
                f"{float(r['r_charge_codata_fm']):.12g}",
                f"{float(r['sigma_r_charge_codata_fm']):.12g}",
                f"{float(r['delta_r_codata_minus_iaea_fm']):.12g}",
                f"{float(r['sigma_r_source_fm']):.12g}",
                f"{float(r['sigma_R_source_fm']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
                f"{float(r['sigma_B_over_A_obs_MeV']):.12g}",
            ]
            per_eq = r["per_eq"]
            assert isinstance(per_eq, dict)
            for eqk in eqks:
                pe = per_eq[eqk]
                assert isinstance(pe, dict)
                row.extend(
                    [
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                        f"{float(pe['sigma_total_MeV']):.12g}",
                        f"{float(pe['sigma_BA_from_r_source_MeV']):.12g}",
                        f"{float(pe['sigma_total_plus_r_source_MeV']):.12g}",
                        f"{float(pe['z_residual_plus_r_source']):.12g}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_radii_source_systematic_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.4",
                "inputs": {
                    "metrics_7_13_15_2": {"path": str(metrics_7152_path), "sha256": _sha256(metrics_7152_path)},
                    "codata_light_nuclei": {"path": str(codata_path), "sha256": _sha256(codata_path)},
                },
                "definition": {
                    "sigma_r_source_fm": "0.5*|r_charge(CODATA) - r_charge(IAEA)|  (for nuclei where CODATA exists; else 0)",
                    "sigma_BA_from_r_source_MeV": "|d(B/A)/dR| * sigma_R_source, with |d(B/A)/dR| inferred from (sigma_BA_from_radii / sigma_R_sharp)",
                    "sigma_total_plus_r_source_MeV": "sqrt(sigma_total^2 + sigma_BA_from_r_source^2)",
                },
                "diag": diag,
                "rows": out_rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_5(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.5 (initial): Combine the uncertainty components into a single "rejection budget"
    and explicitly separate the applicability domain for light nuclei.

    Combined per-eq uncertainty budget:
      sigma_final^2 = sigma_total(7.13.15.2)^2 + sigma_set(eq18 vs eq19)^2 + sigma_r_source^2

    where:
      sigma_set = 0.5 * |pred(eq18) - pred(eq19)|
      sigma_r_source is from 7.13.15.4 (CODATA vs IAEA half-difference propagated to B/A).

    Applicability domain:
      in_domain := (A >= domain_min_a)
    """
    metrics_7152_path = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_metrics.json"
    if not metrics_7152_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.2 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.2\n"
            f"Expected: {metrics_7152_path}"
        )
    m7152 = _load_json(metrics_7152_path)
    rows_7152 = m7152.get("rows")
    if not isinstance(rows_7152, list) or not rows_7152:
        raise SystemExit(f"[fail] invalid 7.13.15.2 metrics: rows missing/empty: {metrics_7152_path}")

    metrics_7154_path = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_radii_source_systematic_metrics.json"
    if not metrics_7154_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.4 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.4\n"
            f"Expected: {metrics_7154_path}"
        )
    m7154 = _load_json(metrics_7154_path)
    rows_7154 = m7154.get("rows")
    if not isinstance(rows_7154, list) or not rows_7154:
        raise SystemExit(f"[fail] invalid 7.13.15.4 metrics: rows missing/empty: {metrics_7154_path}")

    by_key_7154: dict[str, dict[str, object]] = {}
    for r in rows_7154:
        if not isinstance(r, dict):
            continue
        key = str(r.get("key"))
        by_key_7154[key] = r

    # Determine eq labels from 7.13.15.2 (should be eq18/eq19).
    sample = next((r for r in rows_7152 if isinstance(r, dict)), None)
    if not isinstance(sample, dict) or not isinstance(sample.get("per_eq"), dict):
        raise SystemExit(f"[fail] invalid 7.13.15.2 metrics row structure: {metrics_7152_path}")
    eq_keys = sorted([str(k) for k in sample["per_eq"].keys()], key=int)
    if not eq_keys:
        raise SystemExit(f"[fail] could not infer eq labels from 7.13.15.2: {metrics_7152_path}")
    if set(eq_keys) != {"18", "19"}:
        raise SystemExit(f"[fail] Step 7.13.15.5 expects eq18/eq19 only; got: {eq_keys}")

    out_rows: list[dict[str, object]] = []
    z_all_by_eq: dict[str, list[float]] = {k: [] for k in eq_keys}
    z_dom_by_eq: dict[str, list[float]] = {k: [] for k in eq_keys}

    for r in rows_7152:
        if not isinstance(r, dict):
            continue
        key = str(r.get("key"))
        if key not in by_key_7154:
            raise SystemExit(f"[fail] missing key={key} in 7.13.15.4 metrics: {metrics_7154_path}")

        A = int(r.get("A", 0))
        in_domain = bool(A >= int(domain_min_a))

        pe = r.get("per_eq")
        if not isinstance(pe, dict):
            raise SystemExit(f"[fail] invalid per_eq in 7.13.15.2 row: key={key}")

        # Compute sigma_set from eq18 vs eq19 predictions (conservative, symmetric).
        pred18 = float(pe["18"].get("B_over_A_pred_MeV", float("nan"))) if isinstance(pe.get("18"), dict) else float("nan")
        pred19 = float(pe["19"].get("B_over_A_pred_MeV", float("nan"))) if isinstance(pe.get("19"), dict) else float("nan")
        sigma_set = 0.5 * abs(pred18 - pred19) if (math.isfinite(pred18) and math.isfinite(pred19)) else float("nan")

        r54 = by_key_7154[key]
        pe54 = r54.get("per_eq")
        if not isinstance(pe54, dict):
            raise SystemExit(f"[fail] invalid per_eq in 7.13.15.4 row: key={key}")

        item: dict[str, object] = {
            "key": key,
            "label": str(r.get("label")),
            "A": A,
            "Z": int(r.get("Z", 0)),
            "N": int(r.get("N", 0)),
            "in_domain": in_domain,
            "r_charge_fm": float(r.get("r_charge_fm", float("nan"))),
            "sigma_r_charge_fm": float(r.get("sigma_r_charge_fm", float("nan"))),
            "B_over_A_obs_MeV": float(r.get("B_over_A_obs_MeV", float("nan"))),
            "sigma_B_over_A_obs_MeV": float(r.get("sigma_B_over_A_obs_MeV", float("nan"))),
            "sigma_set_MeV": float(sigma_set),
            "per_eq": {},
        }

        per_eq_out: dict[str, dict[str, float]] = {}
        for eqk in eq_keys:
            pei = pe.get(eqk)
            if not isinstance(pei, dict):
                raise SystemExit(f"[fail] missing per_eq[{eqk}] in 7.13.15.2 row: key={key}")
            pe54i = pe54.get(eqk)
            if not isinstance(pe54i, dict):
                raise SystemExit(f"[fail] missing per_eq[{eqk}] in 7.13.15.4 row: key={key}")

            residual = float(pei.get("B_over_A_residual_MeV", float("nan")))
            sigma_total = float(pei.get("sigma_total_MeV", float("nan")))
            sigma_r_source = float(pe54i.get("sigma_BA_from_r_source_MeV", 0.0))

            sigma_final = (
                math.sqrt(float(sigma_total) ** 2 + float(sigma_set) ** 2 + float(sigma_r_source) ** 2)
                if (math.isfinite(sigma_total) and math.isfinite(sigma_set) and math.isfinite(sigma_r_source))
                else float("nan")
            )
            z = residual / sigma_final if (math.isfinite(residual) and math.isfinite(sigma_final) and sigma_final > 0) else float("nan")
            passed = bool(math.isfinite(z) and abs(float(z)) <= 3.0)

            if math.isfinite(z):
                z_all_by_eq[eqk].append(float(z))
                if in_domain:
                    z_dom_by_eq[eqk].append(float(z))

            per_eq_out[eqk] = {
                "B_over_A_pred_MeV": float(pei.get("B_over_A_pred_MeV", float("nan"))),
                "B_over_A_residual_MeV": float(residual),
                "sigma_total_MeV": float(sigma_total),
                "sigma_set_MeV": float(sigma_set),
                "sigma_r_source_MeV": float(sigma_r_source),
                "sigma_final_MeV": float(sigma_final),
                "z_final": float(z),
                "pass_3sigma": 1.0 if passed else 0.0,
            }

        item["per_eq"] = per_eq_out
        out_rows.append(item)

    diag: dict[str, object] = {
        "domain_min_A": int(domain_min_a),
        "n_total": int(len(out_rows)),
        "n_in_domain": int(sum(1 for r in out_rows if bool(r.get("in_domain")))),
    }
    for eqk in eq_keys:
        zs_all = z_all_by_eq[eqk]
        zs_dom = z_dom_by_eq[eqk]
        diag[f"chi2_like_all_eq{eqk}"] = float(sum(float(z) ** 2 for z in zs_all)) if zs_all else float("nan")
        diag[f"n_all_eq{eqk}"] = int(len(zs_all))
        diag[f"frac_within_3sigma_all_eq{eqk}"] = float(sum(1 for z in zs_all if abs(float(z)) <= 3.0) / len(zs_all)) if zs_all else float("nan")
        diag[f"chi2_like_domain_eq{eqk}"] = float(sum(float(z) ** 2 for z in zs_dom)) if zs_dom else float("nan")
        diag[f"n_domain_eq{eqk}"] = int(len(zs_dom))
        diag[f"frac_within_3sigma_domain_eq{eqk}"] = float(sum(1 for z in zs_dom if abs(float(z)) <= 3.0) / len(zs_dom)) if zs_dom else float("nan")

    # Plot (2x2)
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in out_rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    labels = [str(r["label"]) for r in out_rows]
    obs_vals = [float(r["B_over_A_obs_MeV"]) for r in out_rows]
    obs_err = [float(r["sigma_B_over_A_obs_MeV"]) for r in out_rows]
    in_dom_mask = [bool(r["in_domain"]) for r in out_rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.errorbar(a13, obs_vals, yerr=obs_err, fmt="o", ms=4, label="obs (AME2020)")
    for eqk in eq_keys:
        pred = [float(r["per_eq"][eqk]["B_over_A_pred_MeV"]) for r in out_rows]
        yerr = [float(r["per_eq"][eqk]["sigma_final_MeV"]) for r in out_rows]
        ax.errorbar(a13, pred, yerr=yerr, fmt="o", ms=4, linestyle="--", label=f"pred ±σ_final (eq{eqk})")
    ax.set_title("B/A with combined rejection budget (HF+3-body)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab, ok in zip(a13, obs_vals, labels, in_dom_mask, strict=True):
        ax.annotate(lab + ("" if ok else " (out)"), (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8, alpha=1.0 if ok else 0.6)

    ax = axes[0][1]
    for eqk in eq_keys:
        zvals = [float(r["per_eq"][eqk]["z_final"]) for r in out_rows]
        xs_in = [x for x, z, ok in zip(a13, zvals, in_dom_mask, strict=True) if ok]
        ys_in = [z for z, ok in zip(zvals, in_dom_mask, strict=True) if ok]
        xs_out = [x for x, z, ok in zip(a13, zvals, in_dom_mask, strict=True) if not ok]
        ys_out = [z for z, ok in zip(zvals, in_dom_mask, strict=True) if not ok]
        ax.scatter(xs_in, ys_in, s=35, label=f"z_final (eq{eqk}) in-domain")
        ax.scatter(xs_out, ys_out, s=35, alpha=0.4, label=f"z_final (eq{eqk}) out-of-domain")
    ax.axhline(0.0, color="k", linewidth=1)
    ax.axhline(3.0, color="tab:red", linestyle="--", linewidth=1)
    ax.axhline(-3.0, color="tab:red", linestyle="--", linewidth=1)
    ax.set_title(f"z = residual/σ_final (domain: A>={domain_min_a})")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("z")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=7, ncol=2)

    ax = axes[1][0]
    ax.plot(a13, [float(r["sigma_set_MeV"]) for r in out_rows], marker="o", linestyle="-", color="tab:orange", label="σ_set (eq spread)")
    for eqk in eq_keys:
        ax.plot(a13, [float(r["per_eq"][eqk]["sigma_total_MeV"]) for r in out_rows], marker=".", linestyle="--", label=f"σ_total (eq{eqk})")
        ax.plot(a13, [float(r["per_eq"][eqk]["sigma_r_source_MeV"]) for r in out_rows], marker=".", linestyle=":", label=f"σ_r_source (eq{eqk})")
        ax.plot(a13, [float(r["per_eq"][eqk]["sigma_final_MeV"]) for r in out_rows], marker=".", linestyle="-", label=f"σ_final (eq{eqk})")
    ax.set_title("Uncertainty budget components")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("σ (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=7, ncol=2)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "σ_final^2 = σ_total(7.13.15.2)^2 + σ_set^2 + σ_r_source^2",
        "  σ_set = 0.5*|pred(eq18) - pred(eq19)|",
        "  σ_r_source: CODATA vs IAEA radii half-diff propagated",
        "",
        f"domain_min_A={domain_min_a}  (n_in_domain={diag['n_in_domain']}/{diag['n_total']})",
    ]
    for eqk in eq_keys:
        lines.append(
            f"eq{eqk}: chi2(all)≈{diag[f'chi2_like_all_eq{eqk}']:.3g} (N={diag[f'n_all_eq{eqk}']})  "
            f"chi2(dom)≈{diag[f'chi2_like_domain_eq{eqk}']:.3g} (N={diag[f'n_domain_eq{eqk}']})"
        )
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_rejection_budget.png"
    fig.suptitle("Phase 7 / Step 7.13.15.5: combined rejection budget + domain", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_rejection_budget.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "in_domain",
            "B_over_A_obs_MeV",
            "sigma_B_over_A_obs_MeV",
            "sigma_set_MeV",
        ]
        for eqk in eq_keys:
            header.extend(
                [
                    f"B_over_A_pred_eq{eqk}_MeV",
                    f"residual_eq{eqk}_MeV",
                    f"sigma_total_eq{eqk}_MeV",
                    f"sigma_r_source_eq{eqk}_MeV",
                    f"sigma_final_eq{eqk}_MeV",
                    f"z_final_eq{eqk}",
                    f"pass_3sigma_eq{eqk}",
                ]
            )
        w.writerow(header)
        for r in out_rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                1 if bool(r["in_domain"]) else 0,
                f"{float(r['B_over_A_obs_MeV']):.12g}",
                f"{float(r['sigma_B_over_A_obs_MeV']):.12g}",
                f"{float(r['sigma_set_MeV']):.12g}",
            ]
            per_eq = r["per_eq"]
            assert isinstance(per_eq, dict)
            for eqk in eq_keys:
                peo = per_eq[eqk]
                assert isinstance(peo, dict)
                row.extend(
                    [
                        f"{float(peo['B_over_A_pred_MeV']):.12g}",
                        f"{float(peo['B_over_A_residual_MeV']):.12g}",
                        f"{float(peo['sigma_total_MeV']):.12g}",
                        f"{float(peo['sigma_r_source_MeV']):.12g}",
                        f"{float(peo['sigma_final_MeV']):.12g}",
                        f"{float(peo['z_final']):.12g}",
                        f"{float(peo['pass_3sigma']):.0f}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_rejection_budget_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.5",
                "inputs": {
                    "metrics_7_13_15_2": {"path": str(metrics_7152_path), "sha256": _sha256(metrics_7152_path)},
                    "metrics_7_13_15_4": {"path": str(metrics_7154_path), "sha256": _sha256(metrics_7154_path)},
                },
                "definition": {
                    "sigma_set_MeV": "0.5*|pred(eq18)-pred(eq19)|",
                    "sigma_final_MeV": "sqrt(sigma_total^2 + sigma_set^2 + sigma_r_source^2)",
                    "domain_min_A": int(domain_min_a),
                },
                "diag": diag,
                "rows": out_rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_6(*, out_dir: Path, domain_min_a: int, max_nuclei: int) -> None:
    """
    Step 7.13.15.6 (initial): Expand the dataset (AME2020 × IAEA charge radii join) and
    diagnose residual systematics by separating:
      - surface-like effects (A binning),
      - shell-like effects (magic Z/N indicators).

    Notes:
      - This step keeps the frozen C3 values from Step 7.13.15.1 (radii-equilibrium freeze).
      - It does NOT refit to B/A. The goal is to make "where it fails" visible at scale.
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if max_nuclei < 0:
        raise SystemExit("[fail] max_nuclei must be >= 0")

    # Load frozen HF+3-body configuration (C3, derivative eps, pn mix).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)

    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    three_body = model.get("three_body") if isinstance(model.get("three_body"), dict) else {}
    freeze = three_body.get("freeze") if isinstance(three_body.get("freeze"), dict) else {}
    repulsion_power = float(three_body.get("n", 2.0))
    derivative_eps_rel = float(freeze.get("derivative_eps_rel", 1e-3))

    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    stats_in = hf.get("stats")
    if not isinstance(stats_in, dict) or not stats_in:
        raise SystemExit(f"[fail] invalid 7.13.15 metrics: stats missing/empty: {metrics_hf_path}")
    eq_labels = sorted(int(k) for k in stats_in.keys())

    c3_frozen_by_eq = three_body.get("C3_frozen_by_eq")
    if not isinstance(c3_frozen_by_eq, dict) or not c3_frozen_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15 metrics: model.three_body.C3_frozen_by_eq missing/empty: {metrics_hf_path}")

    # Load robust C3 scatter (MAD→σ) from Step 7.13.15.2 (needed for an uncertainty budget).
    metrics_7152_path = out_dir / "nuclear_a_dependence_hf_three_body_uncertainty_metrics.json"
    if not metrics_7152_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.2 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.2\n"
            f"Expected: {metrics_7152_path}"
        )
    m7152 = _load_json(metrics_7152_path)
    diag_7152 = m7152.get("diag") if isinstance(m7152.get("diag"), dict) else {}
    c3_sigma_robust_by_eq = diag_7152.get("C3_sigma_robust_by_eq")
    if not isinstance(c3_sigma_robust_by_eq, dict) or not c3_sigma_robust_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.2 metrics: diag.C3_sigma_robust_by_eq missing/empty: {metrics_7152_path}")

    # Load potential sets + constants (from Step 7.13.8 metrics).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N,A) -> (B/A, σ_B/A, symbol)
    ame_map: dict[tuple[int, int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N, A)] = {
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
            "symbol": str(r.get("symbol", "")),
        }

    def fnum(s: str) -> float:
        t = s.strip()
        if t == "":
            return float("nan")
        try:
            return float(t)
        except Exception:
            return float("nan")

    nuclei: list[dict[str, object]] = []
    with radii_path.open("r", encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            if not isinstance(row, dict):
                continue
            Z = int(row.get("z", "-1"))
            N = int(row.get("n", "-1"))
            A = int(row.get("a", "-1"))
            if Z < 1 or A < 2:
                continue

            r_val = fnum(str(row.get("radius_val", "")))
            r_unc = fnum(str(row.get("radius_unc", "")))
            r_pre = fnum(str(row.get("radius_preliminary_val", "")))
            r_pre_unc = fnum(str(row.get("radius_preliminary_unc", "")))

            used = "published"
            r_use = float(r_val)
            r_unc_use = float(r_unc)
            if not (math.isfinite(r_use) and r_use > 0):
                used = "preliminary"
                r_use = float(r_pre)
                r_unc_use = float(r_pre_unc)

            if not (math.isfinite(r_use) and r_use > 0):
                continue
            if (Z, N, A) not in ame_map:
                continue

            sym = str(row.get("symbol", "")).strip() or str(ame_map[(Z, N, A)].get("symbol", "")).strip()
            label = f"{sym}-{A}"
            nuclei.append(
                {
                    "Z": int(Z),
                    "N": int(N),
                    "A": int(A),
                    "symbol": sym,
                    "label": label,
                    "r_charge_fm": float(r_use),
                    "sigma_r_charge_fm": float(r_unc_use) if math.isfinite(r_unc_use) else float("nan"),
                    "radii_used": used,
                    "B_over_A_obs_MeV": float(ame_map[(Z, N, A)]["B_over_A_obs_MeV"]),
                    "sigma_B_over_A_obs_MeV": float(ame_map[(Z, N, A)]["sigma_B_over_A_obs_MeV"]),
                }
            )

    nuclei.sort(key=lambda x: (int(x["A"]), int(x["Z"]), int(x["N"]), str(x["radii_used"])))
    if max_nuclei > 0:
        nuclei = nuclei[: int(max_nuclei)]

    if not nuclei:
        raise SystemExit("[fail] no joined nuclei found (AME2020 × IAEA radii)")

    # Compute predictions + diagnostics.
    MAGIC = {2, 8, 20, 28, 50, 82, 126}

    out_rows: list[dict[str, object]] = []
    for nuc in nuclei:
        A = int(nuc["A"])
        Z = int(nuc["Z"])
        N = int(nuc["N"])
        r_charge = float(nuc["r_charge_fm"])
        sigma_r_charge = float(nuc["sigma_r_charge_fm"])
        ba_obs = float(nuc["B_over_A_obs_MeV"])
        sigma_ba_obs = float(nuc["sigma_B_over_A_obs_MeV"])

        R_sharp = _sharp_radius_from_rms(r_charge)
        sigma_R_sharp = math.sqrt(5.0 / 3.0) * sigma_r_charge if (math.isfinite(sigma_r_charge) and sigma_r_charge > 0) else float("nan")
        V0 = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho0 = float(A) / float(V0)

        dR = float(derivative_eps_rel) * float(R_sharp)
        if not (math.isfinite(dR) and dR > 0):
            dR = 1e-6 * float(R_sharp)

        in_domain = bool(A >= int(domain_min_a))
        magic_z = bool(Z in MAGIC)
        magic_n = bool(N in MAGIC)
        doubly_magic = bool(magic_z and magic_n)
        magic_any = bool(magic_z or magic_n)

        item: dict[str, object] = {
            "key": f"Z{Z}_N{N}",
            "label": str(nuc["label"]),
            "A": int(A),
            "Z": int(Z),
            "N": int(N),
            "in_domain": in_domain,
            "magic_Z": magic_z,
            "magic_N": magic_n,
            "doubly_magic": doubly_magic,
            "magic_any": magic_any,
            "radii_used": str(nuc["radii_used"]),
            "r_charge_fm": float(r_charge),
            "sigma_r_charge_fm": float(sigma_r_charge),
            "R_sharp_fm": float(R_sharp),
            "sigma_R_sharp_fm": float(sigma_R_sharp),
            "rho_fm3": float(rho0),
            "B_over_A_obs_MeV": float(ba_obs),
            "sigma_B_over_A_obs_MeV": float(sigma_ba_obs),
            "per_eq": {},
        }

        per_eq: dict[str, dict[str, float]] = {}
        pred_by_eq: dict[str, float] = {}
        for eq in eq_labels:
            k = str(eq)
            if k not in c3_frozen_by_eq:
                continue
            if k not in c3_sigma_robust_by_eq:
                continue
            c3 = float(c3_frozen_by_eq[k])
            c3_sigma = float(c3_sigma_robust_by_eq[k])

            base0 = _hf_base_energy_uniform_sphere_mev_per_a(
                A=A,
                Z=Z,
                N=N,
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=hbarc,
                m_nucleon_c2_mev=m_nucleon_c2,
            )
            base_p = _hf_base_energy_uniform_sphere_mev_per_a(
                A=A,
                Z=Z,
                N=N,
                R_sharp_fm=float(R_sharp) + float(dR),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=hbarc,
                m_nucleon_c2_mev=m_nucleon_c2,
            )
            base_m = _hf_base_energy_uniform_sphere_mev_per_a(
                A=A,
                Z=Z,
                N=N,
                R_sharp_fm=float(R_sharp) - float(dR),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=hbarc,
                m_nucleon_c2_mev=m_nucleon_c2,
            )

            dEbase_dR = (float(base_p["E_base"]) - float(base_m["E_base"])) / (2.0 * float(dR)) if dR > 0 else float("nan")
            denom = 3.0 * float(repulsion_power) * (float(rho0) ** float(repulsion_power))
            c3_est = (float(R_sharp) * float(dEbase_dR) / denom) if (math.isfinite(denom) and denom > 0) else float("nan")

            # Prediction at R0
            e3_0 = float(c3) * (float(rho0) ** float(repulsion_power))
            e_total_0 = float(base0["E_base"]) + float(e3_0)
            ba_pred_0 = -float(e_total_0)
            residual = float(ba_pred_0 - ba_obs)
            pred_by_eq[k] = float(ba_pred_0)

            # Radii sensitivity for σ_r propagation (use the frozen C3 at R±dR).
            Vp = (4.0 / 3.0) * math.pi * float(R_sharp + dR) ** 3
            Vm = (4.0 / 3.0) * math.pi * float(R_sharp - dR) ** 3
            rhop = float(A) / float(Vp) if Vp > 0 else float("nan")
            rhom = float(A) / float(Vm) if Vm > 0 else float("nan")
            e3_p = float(c3) * (float(rhop) ** float(repulsion_power)) if math.isfinite(rhop) else float("nan")
            e3_m = float(c3) * (float(rhom) ** float(repulsion_power)) if math.isfinite(rhom) else float("nan")
            ba_pred_p = -(float(base_p["E_base"]) + float(e3_p)) if math.isfinite(e3_p) else float("nan")
            ba_pred_m = -(float(base_m["E_base"]) + float(e3_m)) if math.isfinite(e3_m) else float("nan")
            dba_dR = (float(ba_pred_p) - float(ba_pred_m)) / (2.0 * float(dR)) if (math.isfinite(ba_pred_p) and math.isfinite(ba_pred_m) and dR > 0) else float("nan")

            sigma_ba_from_radii = abs(float(dba_dR)) * float(sigma_R_sharp) if math.isfinite(sigma_R_sharp) else 0.0
            sigma_ba_from_c3 = abs(float(rho0) ** float(repulsion_power)) * float(c3_sigma)
            sigma_total = math.sqrt(float(sigma_ba_obs) ** 2 + float(sigma_ba_from_radii) ** 2 + float(sigma_ba_from_c3) ** 2)

            per_eq[k] = {
                "T_kin_MeV_per_A": float(base0["T"]),
                "U_H_MeV_per_A": float(base0["U_H"]),
                "U_F_MeV_per_A": float(base0["U_F"]),
                "E_coul_MeV_per_A": float(base0["Coul"]),
                "E_base_MeV_per_A": float(base0["E_base"]),
                "dEbase_dR_MeV_per_fm": float(dEbase_dR),
                "C3_frozen": float(c3),
                "C3_sigma_robust": float(c3_sigma),
                "C3_est_from_radii": float(c3_est),
                "B_over_A_pred_MeV": float(ba_pred_0),
                "B_over_A_residual_MeV": float(residual),
                "sigma_BA_from_radii_MeV": float(sigma_ba_from_radii),
                "sigma_BA_from_C3_MeV": float(sigma_ba_from_c3),
                "sigma_total_MeV": float(sigma_total),
            }

        if not per_eq:
            continue

        # Dataset ambiguity systematic (eq18 vs eq19) if both exist.
        sigma_set = float("nan")
        if "18" in pred_by_eq and "19" in pred_by_eq and math.isfinite(pred_by_eq["18"]) and math.isfinite(pred_by_eq["19"]):
            sigma_set = 0.5 * abs(float(pred_by_eq["18"]) - float(pred_by_eq["19"]))

        for k, pe in per_eq.items():
            sig_total = float(pe.get("sigma_total_MeV", float("nan")))
            sig_set = float(sigma_set) if math.isfinite(sigma_set) else 0.0
            sig_final = math.sqrt(sig_total**2 + sig_set**2) if math.isfinite(sig_total) else float("nan")
            z = float(pe.get("B_over_A_residual_MeV", float("nan"))) / sig_final if (math.isfinite(sig_final) and sig_final > 0) else float("nan")
            pe.update({"sigma_set_MeV": float(sig_set), "sigma_final_MeV": float(sig_final), "z_final": float(z), "pass_3sigma": 1.0 if (math.isfinite(z) and abs(float(z)) <= 3.0) else 0.0})

        item["sigma_set_MeV"] = float(sigma_set) if math.isfinite(sigma_set) else 0.0
        item["per_eq"] = per_eq

        # Mean prediction (for shell/surface grouping; avoid choosing the "better" eq).
        if "18" in pred_by_eq and "19" in pred_by_eq and math.isfinite(pred_by_eq["18"]) and math.isfinite(pred_by_eq["19"]):
            pred_mean = 0.5 * (float(pred_by_eq["18"]) + float(pred_by_eq["19"]))
        else:
            # Fallback: mean over available eqs.
            vals = [float(v) for v in pred_by_eq.values() if math.isfinite(float(v))]
            pred_mean = float(sum(vals) / len(vals)) if vals else float("nan")
        item["B_over_A_pred_mean_MeV"] = float(pred_mean)
        item["B_over_A_residual_mean_MeV"] = float(pred_mean - ba_obs) if math.isfinite(pred_mean) else float("nan")
        out_rows.append(item)

    if not out_rows:
        raise SystemExit("[fail] no valid computed rows for Step 7.13.15.6")

    def _rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def _median(vals: list[float]) -> float:
        v = sorted(vals)
        m = len(v) // 2
        return v[m] if (len(v) % 2 == 1) else 0.5 * (v[m - 1] + v[m])

    def _mad_to_sigma(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        med = _median(vals)
        mad = _median([abs(x - med) for x in vals])
        return float(1.4826 * mad)

    # Group metrics for residual_mean (shell/surface split).
    def summarize(items: list[dict[str, object]]) -> dict[str, float]:
        res = [float(it["B_over_A_residual_mean_MeV"]) for it in items if math.isfinite(float(it.get("B_over_A_residual_mean_MeV", float("nan"))))]
        abs_res = [abs(x) for x in res]
        return {
            "N": float(len(res)),
            "residual_mean_MeV": float(sum(res) / len(res)) if res else float("nan"),
            "residual_rms_MeV": float(_rms(res)),
            "median_abs_residual_MeV": float(_median(abs_res)) if abs_res else float("nan"),
        }

    # A bins (surface proxy)
    a_bins = [(2, 16), (16, 40), (40, 100), (100, 200), (200, 10**9)]
    def bin_label(a: int) -> str:
        for lo, hi in a_bins:
            if lo <= a < hi:
                return f"{lo}<=A<{hi}" if hi < 10**8 else f"A>={lo}"
        return "unknown"

    for r in out_rows:
        r["A_bin"] = bin_label(int(r["A"]))

    # Published vs preliminary radii split
    rows_published = [r for r in out_rows if str(r.get("radii_used")) == "published"]
    rows_prelim = [r for r in out_rows if str(r.get("radii_used")) == "preliminary"]
    rows_domain = [r for r in out_rows if bool(r.get("in_domain"))]

    diag: dict[str, object] = {
        "domain_min_A": int(domain_min_a),
        "max_nuclei": int(max_nuclei),
        "n_total": int(len(out_rows)),
        "n_published": int(len(rows_published)),
        "n_preliminary": int(len(rows_prelim)),
        "n_in_domain": int(len(rows_domain)),
        "eq_labels": [int(e) for e in eq_labels],
        "pn_triplet_weight": float(pn_triplet_weight),
        "repulsion_power": float(repulsion_power),
        "derivative_eps_rel": float(derivative_eps_rel),
        "C3_frozen_by_eq": {str(k): float(v) for k, v in c3_frozen_by_eq.items()},
        "C3_sigma_robust_by_eq": {str(k): float(v) for k, v in c3_sigma_robust_by_eq.items()},
    }

    diag["residual_stats_all"] = summarize(out_rows)
    diag["residual_stats_domain"] = summarize(rows_domain)
    diag["residual_stats_published"] = summarize(rows_published)

    diag["residual_stats_magic_any_domain"] = summarize([r for r in rows_domain if bool(r.get("magic_any"))])
    diag["residual_stats_nonmagic_domain"] = summarize([r for r in rows_domain if not bool(r.get("magic_any"))])

    # Surface bin split (domain only; magic vs non-magic)
    by_bin: dict[str, dict[str, object]] = {}
    for lo, hi in a_bins:
        lab = f"{lo}<=A<{hi}" if hi < 10**8 else f"A>={lo}"
        items = [r for r in rows_domain if str(r.get("A_bin")) == lab]
        by_bin[lab] = {
            "all": summarize(items),
            "magic_any": summarize([r for r in items if bool(r.get("magic_any"))]),
            "nonmagic": summarize([r for r in items if not bool(r.get("magic_any"))]),
            "N_total": int(len(items)),
        }
    diag["surface_shell_split_domain"] = by_bin

    # C3_est_from_radii distribution (diagnostic for missing physics; do not refit)
    c3_est_stats: dict[str, dict[str, float]] = {}
    for eq in eq_labels:
        k = str(eq)
        vals_all = [
            float(r["per_eq"][k]["C3_est_from_radii"])
            for r in out_rows
            if isinstance(r.get("per_eq"), dict)
            and k in r["per_eq"]
            and isinstance(r["per_eq"][k], dict)
            and math.isfinite(float(r["per_eq"][k].get("C3_est_from_radii", float("nan"))))
        ]
        vals_dom = [
            float(r["per_eq"][k]["C3_est_from_radii"])
            for r in rows_domain
            if isinstance(r.get("per_eq"), dict)
            and k in r["per_eq"]
            and isinstance(r["per_eq"][k], dict)
            and math.isfinite(float(r["per_eq"][k].get("C3_est_from_radii", float("nan"))))
        ]
        c3_est_stats[k] = {
            "median_all": float(_median(vals_all)) if vals_all else float("nan"),
            "sigma_robust_all": float(_mad_to_sigma(vals_all)),
            "median_domain": float(_median(vals_dom)) if vals_dom else float("nan"),
            "sigma_robust_domain": float(_mad_to_sigma(vals_dom)),
            "N_all": float(len(vals_all)),
            "N_domain": float(len(vals_dom)),
        }
    diag["C3_est_from_radii_stats"] = c3_est_stats

    # Plot (2x2)
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in out_rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    obs = [float(r["B_over_A_obs_MeV"]) for r in out_rows]
    pred_mean = [float(r["B_over_A_pred_mean_MeV"]) for r in out_rows]
    res_mean = [float(r["B_over_A_residual_mean_MeV"]) for r in out_rows]
    magic_any = [bool(r["magic_any"]) for r in out_rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.scatter(a13, obs, s=10, alpha=0.45, label="obs (AME2020 B/A)")
    ax.scatter(a13, pred_mean, s=10, alpha=0.45, label="pred_mean (HF+3-body; frozen C3)")
    ax.set_title("B/A: obs vs pred_mean (extended dataset)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[0][1]
    xs_magic = [x for x, m in zip(a13, magic_any, strict=True) if m]
    ys_magic = [y for y, m in zip(res_mean, magic_any, strict=True) if m]
    xs_non = [x for x, m in zip(a13, magic_any, strict=True) if not m]
    ys_non = [y for y, m in zip(res_mean, magic_any, strict=True) if not m]
    ax.scatter(xs_non, ys_non, s=10, alpha=0.45, label="residual_mean (non-magic)")
    ax.scatter(xs_magic, ys_magic, s=12, alpha=0.65, label="residual_mean (magic Z/N)")
    ax.axhline(0.0, color="k", linewidth=1)
    ax.set_title("Residual (pred_mean - obs): shell-like split")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("Δ(B/A) (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][0]
    for eq in eq_labels:
        k = str(eq)
        vals = [
            float(r["per_eq"][k]["C3_est_from_radii"])
            if (isinstance(r.get("per_eq"), dict) and k in r["per_eq"] and isinstance(r["per_eq"][k], dict))
            else float("nan")
            for r in out_rows
        ]
        ax.scatter(a13, vals, s=10, alpha=0.35, label=f"C3_est_from_radii (eq{eq})")
    ax.set_title("C3_est_from_radii scatter (diagnostic)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("C3_est (MeV·fm^6)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=7, ncol=2)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        f"domain_min_A={domain_min_a}   N_total={diag['n_total']} (published={diag['n_published']}, prelim={diag['n_preliminary']})",
        f"residual_mean stats (all): rms={diag['residual_stats_all']['residual_rms_MeV']:.3g} MeV   median|Δ|={diag['residual_stats_all']['median_abs_residual_MeV']:.3g} MeV",
        f"residual_mean stats (domain): rms={diag['residual_stats_domain']['residual_rms_MeV']:.3g} MeV   median|Δ|={diag['residual_stats_domain']['median_abs_residual_MeV']:.3g} MeV",
        "",
        "domain split (magic vs non-magic):",
        f"  magic_any:  N={int(diag['residual_stats_magic_any_domain']['N']):d}  rms={diag['residual_stats_magic_any_domain']['residual_rms_MeV']:.3g} MeV",
        f"  non-magic:  N={int(diag['residual_stats_nonmagic_domain']['N']):d}  rms={diag['residual_stats_nonmagic_domain']['residual_rms_MeV']:.3g} MeV",
        "",
        "C3_est_from_radii (domain; robust σ):",
    ]
    for eq in eq_labels:
        k = str(eq)
        cs = diag["C3_est_from_radii_stats"][k]
        lines.append(f"  eq{eq}: median={cs['median_domain']:.4g}   σ≈{cs['sigma_robust_domain']:.4g}   (N={int(cs['N_domain']):d})")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_extended_dataset.png"
    fig.suptitle("Phase 7 / Step 7.13.15.6: HF+3-body (extended dataset; shell/surface split)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_extended_dataset.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "in_domain",
            "magic_Z",
            "magic_N",
            "doubly_magic",
            "magic_any",
            "A_bin",
            "radii_used",
            "r_charge_fm",
            "sigma_r_charge_fm",
            "R_sharp_fm",
            "sigma_R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
            "sigma_B_over_A_obs_MeV",
            "B_over_A_pred_mean_MeV",
            "B_over_A_residual_mean_MeV",
            "sigma_set_MeV",
        ]
        for eq in eq_labels:
            header.extend(
                [
                    f"B_over_A_pred_eq{eq}_MeV",
                    f"residual_eq{eq}_MeV",
                    f"C3_frozen_eq{eq}",
                    f"C3_est_from_radii_eq{eq}",
                    f"sigma_total_eq{eq}_MeV",
                    f"sigma_final_eq{eq}_MeV",
                    f"z_final_eq{eq}",
                ]
            )
        w.writerow(header)
        for r in out_rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                1 if bool(r["in_domain"]) else 0,
                1 if bool(r["magic_Z"]) else 0,
                1 if bool(r["magic_N"]) else 0,
                1 if bool(r["doubly_magic"]) else 0,
                1 if bool(r["magic_any"]) else 0,
                str(r.get("A_bin")),
                str(r.get("radii_used")),
                f"{float(r['r_charge_fm']):.12g}",
                f"{float(r['sigma_r_charge_fm']):.12g}",
                f"{float(r['R_sharp_fm']):.12g}",
                f"{float(r['sigma_R_sharp_fm']):.12g}" if math.isfinite(float(r["sigma_R_sharp_fm"])) else "",
                f"{float(r['rho_fm3']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
                f"{float(r['sigma_B_over_A_obs_MeV']):.12g}",
                f"{float(r['B_over_A_pred_mean_MeV']):.12g}",
                f"{float(r['B_over_A_residual_mean_MeV']):.12g}",
                f"{float(r['sigma_set_MeV']):.12g}",
            ]
            per_eq = r["per_eq"]
            assert isinstance(per_eq, dict)
            for eq in eq_labels:
                k = str(eq)
                pe = per_eq.get(k)
                if not isinstance(pe, dict):
                    row.extend(["", "", "", "", "", "", ""])
                    continue
                row.extend(
                    [
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                        f"{float(pe['C3_frozen']):.12g}",
                        f"{float(pe['C3_est_from_radii']):.12g}",
                        f"{float(pe['sigma_total_MeV']):.12g}",
                        f"{float(pe['sigma_final_MeV']):.12g}",
                        f"{float(pe['z_final']):.12g}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_extended_dataset_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.6",
                "inputs": {
                    "hf_metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_2": {"path": str(metrics_7152_path), "sha256": _sha256(metrics_7152_path)},
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                },
                "selection": {
                    "filters": ["Z>=1", "A>=2", "r_charge>0", "AME2020 ∩ IAEA radii join"],
                    "radii_choice": "use published radius if present else preliminary; track radii_used",
                },
                "diag": diag,
                "rows": out_rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_7(
    *,
    out_dir: Path,
    domain_min_a: int,
    fit_min_a: int,
    fit_include_preliminary: bool,
    clip_k: float,
) -> None:
    """
    Step 7.13.15.7 (initial): Add an explicit finite-size (surface) term to explain the
    observed A-dependence of C3_est_from_radii, and update rejection-style diagnostics.

    Fit (radii-only; no B/A):
      x := 1/(6 ρ^2 R_sharp)
      C3_est_from_radii ≈ C3_inf + C_surf * x

    Predict (frozen parameters):
      C3_eff = C3_inf + C_surf * x
      E_total/A = E_base/A + C3_eff ρ^2  = E_base/A + C3_inf ρ^2 + C_surf/(6 R_sharp)
      B/A_pred = -E_total/A
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if fit_min_a < 1:
        raise SystemExit("[fail] fit_min_a must be >= 1")
    if not (math.isfinite(clip_k) and clip_k >= 0.0):
        raise SystemExit("[fail] clip_k must be finite and >= 0")

    metrics_7156_path = out_dir / "nuclear_a_dependence_hf_three_body_extended_dataset_metrics.json"
    if not metrics_7156_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.6 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.6\n"
            f"Expected: {metrics_7156_path}"
        )
    m7156 = _load_json(metrics_7156_path)
    rows_in = m7156.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.6 metrics: rows missing/empty: {metrics_7156_path}")

    sample = next((r for r in rows_in if isinstance(r, dict)), None)
    if not isinstance(sample, dict) or not isinstance(sample.get("per_eq"), dict):
        raise SystemExit(f"[fail] invalid 7.13.15.6 row structure: per_eq missing: {metrics_7156_path}")
    eq_keys = sorted([str(k) for k in sample["per_eq"].keys()], key=int)
    if set(eq_keys) != {"18", "19"}:
        raise SystemExit(f"[fail] Step 7.13.15.7 expects per_eq with eq18/eq19; got: {eq_keys}")

    def median(vals: list[float]) -> float:
        v = sorted(vals)
        m = len(v) // 2
        return v[m] if (len(v) % 2 == 1) else 0.5 * (v[m - 1] + v[m])

    def mad_to_sigma(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        m = median(vals)
        mad = median([abs(x - m) for x in vals])
        return float(1.4826 * mad)

    def ols_fit(xs: list[float], ys: list[float]) -> tuple[float, float]:
        # y = a + b x
        n = float(len(xs))
        sx = float(sum(xs))
        sy = float(sum(ys))
        sxx = float(sum(x * x for x in xs))
        sxy = float(sum(x * y for x, y in zip(xs, ys, strict=True)))
        denom = n * sxx - sx * sx
        if not (math.isfinite(denom) and abs(denom) > 0):
            return float("nan"), float("nan")
        b = (n * sxy - sx * sy) / denom
        a = (sy - b * sx) / n
        return float(a), float(b)

    fit_by_eq: dict[str, dict[str, float]] = {}
    fit_points_by_eq: dict[str, dict[str, list[float]]] = {}

    for eqk in eq_keys:
        xs: list[float] = []
        ys: list[float] = []
        for r in rows_in:
            if not isinstance(r, dict):
                continue
            A = int(r.get("A", 0))
            if A < fit_min_a:
                continue
            if not fit_include_preliminary and str(r.get("radii_used")) != "published":
                continue
            R = float(r.get("R_sharp_fm", float("nan")))
            rho = float(r.get("rho_fm3", float("nan")))
            pe = r.get("per_eq")
            if not isinstance(pe, dict) or eqk not in pe or not isinstance(pe[eqk], dict):
                continue
            y = float(pe[eqk].get("C3_est_from_radii", float("nan")))
            if not (math.isfinite(R) and R > 0 and math.isfinite(rho) and rho > 0 and math.isfinite(y)):
                continue
            x = 1.0 / (6.0 * (rho**2) * R)
            if not (math.isfinite(x) and x > 0):
                continue
            xs.append(float(x))
            ys.append(float(y))

        if len(xs) < 20:
            raise SystemExit(f"[fail] insufficient fit points for eq{eqk}: n={len(xs)} (fit_min_a={fit_min_a})")

        a0, b0 = ols_fit(xs, ys)
        res0 = [y - (a0 + b0 * x) for x, y in zip(xs, ys, strict=True)]
        sig0 = mad_to_sigma(res0)
        if not math.isfinite(sig0) or sig0 <= 0 or clip_k == 0:
            keep = [True] * len(xs)
        else:
            thr = float(clip_k) * float(sig0)
            keep = [abs(r) <= thr for r in res0]
        xs2 = [x for x, k in zip(xs, keep, strict=True) if k]
        ys2 = [y for y, k in zip(ys, keep, strict=True) if k]
        a, b = ols_fit(xs2, ys2) if len(xs2) >= 20 else (a0, b0)
        res = [y - (a + b * x) for x, y in zip(xs2, ys2, strict=True)] if len(xs2) >= 2 else []
        sig = mad_to_sigma(res)

        fit_by_eq[eqk] = {
            "C3_inf": float(a),
            "C_surf_MeV_fm": float(b),
            "sigma_C3_fit_resid": float(sig),
            "n_fit_all": float(len(xs)),
            "n_fit_kept": float(len(xs2)),
            "fit_min_A": float(fit_min_a),
            "fit_include_preliminary": 1.0 if fit_include_preliminary else 0.0,
            "clip_k": float(clip_k),
        }
        fit_points_by_eq[eqk] = {"x_fm5": xs2, "C3_est": ys2}

    # Predict with the frozen (C3_inf, C_surf).
    out_rows: list[dict[str, object]] = []
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        A = int(r.get("A", 0))
        Z = int(r.get("Z", 0))
        N = int(r.get("N", 0))
        R = float(r.get("R_sharp_fm", float("nan")))
        rho = float(r.get("rho_fm3", float("nan")))
        if not (A > 0 and math.isfinite(R) and R > 0 and math.isfinite(rho) and rho > 0):
            continue

        ba_obs = float(r.get("B_over_A_obs_MeV", float("nan")))
        sigma_ba_obs = float(r.get("sigma_B_over_A_obs_MeV", 0.0))
        sigma_R = float(r.get("sigma_R_sharp_fm", 0.0))

        in_domain = bool(A >= int(domain_min_a))

        per_eq_in = r.get("per_eq")
        if not isinstance(per_eq_in, dict):
            continue

        item: dict[str, object] = {
            "key": str(r.get("key")),
            "label": str(r.get("label")),
            "A": int(A),
            "Z": int(Z),
            "N": int(N),
            "in_domain": in_domain,
            "magic_Z": bool(r.get("magic_Z")),
            "magic_N": bool(r.get("magic_N")),
            "doubly_magic": bool(r.get("doubly_magic")),
            "magic_any": bool(r.get("magic_any")),
            "A_bin": str(r.get("A_bin")),
            "radii_used": str(r.get("radii_used")),
            "r_charge_fm": float(r.get("r_charge_fm", float("nan"))),
            "sigma_r_charge_fm": float(r.get("sigma_r_charge_fm", float("nan"))),
            "R_sharp_fm": float(R),
            "sigma_R_sharp_fm": float(sigma_R),
            "rho_fm3": float(rho),
            "B_over_A_obs_MeV": float(ba_obs),
            "sigma_B_over_A_obs_MeV": float(sigma_ba_obs),
            "sigma_set_MeV": 0.0,  # filled later if both eq exist
            "per_eq": {},
        }

        pred_by_eq: dict[str, float] = {}
        per_eq_out: dict[str, dict[str, float]] = {}
        for eqk in eq_keys:
            if eqk not in per_eq_in or not isinstance(per_eq_in[eqk], dict):
                continue
            base = per_eq_in[eqk]
            e_base = float(base.get("E_base_MeV_per_A", float("nan")))
            dE_dR = float(base.get("dEbase_dR_MeV_per_fm", float("nan")))
            if not (math.isfinite(e_base) and math.isfinite(dE_dR)):
                continue

            c3_inf = float(fit_by_eq[eqk]["C3_inf"])
            c_surf = float(fit_by_eq[eqk]["C_surf_MeV_fm"])
            sigma_c3 = float(fit_by_eq[eqk]["sigma_C3_fit_resid"])

            x = 1.0 / (6.0 * (float(rho) ** 2) * float(R))
            c3_eff = float(c3_inf) + float(c_surf) * float(x)
            e3_vol = float(c3_inf) * (float(rho) ** 2)
            e3_surf_equiv = float(c_surf) / (6.0 * float(R))
            e3 = float(c3_eff) * (float(rho) ** 2)
            e_total = float(e_base) + float(e3)
            ba_pred = -float(e_total)
            pred_by_eq[eqk] = float(ba_pred)

            residual = float(ba_pred - ba_obs)

            # d(B/A)/dR for radii uncertainty propagation (analytic, uses dEbase/dR).
            dBA_dR = -float(dE_dR) + 6.0 * float(c3_inf) * (float(rho) ** 2) / float(R) + float(c_surf) / (6.0 * (float(R) ** 2))
            sig_r = abs(float(dBA_dR)) * float(sigma_R) if (math.isfinite(sigma_R) and sigma_R > 0) else 0.0
            sig_c3 = abs(float(rho) ** 2) * float(sigma_c3) if math.isfinite(sigma_c3) else 0.0
            sig_total = math.sqrt(float(sigma_ba_obs) ** 2 + float(sig_r) ** 2 + float(sig_c3) ** 2)

            per_eq_out[eqk] = {
                "C3_inf": float(c3_inf),
                "C_surf_MeV_fm": float(c_surf),
                "x_fm5": float(x),
                "C3_eff": float(c3_eff),
                "sigma_C3_fit_resid": float(sigma_c3),
                "E_base_MeV_per_A": float(e_base),
                "dEbase_dR_MeV_per_fm": float(dE_dR),
                "E_3body_volume_MeV_per_A": float(e3_vol),
                "E_3body_surface_equiv_MeV_per_A": float(e3_surf_equiv),
                "E_3body_MeV_per_A": float(e3),
                "E_total_MeV_per_A": float(e_total),
                "B_over_A_pred_MeV": float(ba_pred),
                "B_over_A_residual_MeV": float(residual),
                "dBA_dR_MeV_per_fm": float(dBA_dR),
                "sigma_BA_from_radii_MeV": float(sig_r),
                "sigma_BA_from_C3_MeV": float(sig_c3),
                "sigma_total_MeV": float(sig_total),
            }

        if not per_eq_out:
            continue

        sigma_set = 0.0
        if "18" in pred_by_eq and "19" in pred_by_eq and math.isfinite(pred_by_eq["18"]) and math.isfinite(pred_by_eq["19"]):
            sigma_set = 0.5 * abs(float(pred_by_eq["18"]) - float(pred_by_eq["19"]))
        item["sigma_set_MeV"] = float(sigma_set)

        # Final z with σ_set (no choosing eq).
        for eqk, pe in per_eq_out.items():
            sig_total = float(pe.get("sigma_total_MeV", float("nan")))
            sig_final = math.sqrt(sig_total**2 + float(sigma_set) ** 2) if math.isfinite(sig_total) else float("nan")
            z = float(pe.get("B_over_A_residual_MeV", float("nan"))) / sig_final if (math.isfinite(sig_final) and sig_final > 0) else float("nan")
            pe["sigma_set_MeV"] = float(sigma_set)
            pe["sigma_final_MeV"] = float(sig_final)
            pe["z_final"] = float(z)
            pe["pass_3sigma"] = 1.0 if (math.isfinite(z) and abs(float(z)) <= 3.0) else 0.0

        item["per_eq"] = per_eq_out

        if "18" in pred_by_eq and "19" in pred_by_eq and math.isfinite(pred_by_eq["18"]) and math.isfinite(pred_by_eq["19"]):
            pred_mean = 0.5 * (float(pred_by_eq["18"]) + float(pred_by_eq["19"]))
        else:
            vals = [float(v) for v in pred_by_eq.values() if math.isfinite(float(v))]
            pred_mean = float(sum(vals) / len(vals)) if vals else float("nan")
        item["B_over_A_pred_mean_MeV"] = float(pred_mean)
        item["B_over_A_residual_mean_MeV"] = float(pred_mean - ba_obs) if math.isfinite(pred_mean) else float("nan")

        out_rows.append(item)

    if not out_rows:
        raise SystemExit("[fail] no valid output rows for Step 7.13.15.7")

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    diag: dict[str, object] = {
        "domain_min_A": int(domain_min_a),
        "fit_min_A": int(fit_min_a),
        "fit_include_preliminary": bool(fit_include_preliminary),
        "clip_k": float(clip_k),
        "n_total": int(len(out_rows)),
        "n_in_domain": int(sum(1 for r in out_rows if bool(r.get("in_domain")))),
        "fit_by_eq": fit_by_eq,
    }

    # Summary stats (mean residual; domain)
    rows_domain = [r for r in out_rows if bool(r.get("in_domain"))]
    res_dom = [float(r["B_over_A_residual_mean_MeV"]) for r in rows_domain if math.isfinite(float(r.get("B_over_A_residual_mean_MeV", float("nan"))))]
    diag["residual_rms_domain_MeV"] = float(rms(res_dom))

    # z stats (per eq; domain)
    for eqk in eq_keys:
        zs = [
            float(r["per_eq"][eqk]["z_final"])
            for r in rows_domain
            if isinstance(r.get("per_eq"), dict)
            and eqk in r["per_eq"]
            and isinstance(r["per_eq"][eqk], dict)
            and math.isfinite(float(r["per_eq"][eqk].get("z_final", float("nan"))))
        ]
        diag[f"chi2_like_domain_eq{eqk}"] = float(sum(float(z) ** 2 for z in zs)) if zs else float("nan")
        diag[f"n_domain_eq{eqk}"] = int(len(zs))
        diag[f"frac_within_3sigma_domain_eq{eqk}"] = float(sum(1 for z in zs if abs(float(z)) <= 3.0) / len(zs)) if zs else float("nan")

    # Plot (2x2)
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a13_all = [int(r["A"]) ** (1.0 / 3.0) for r in out_rows]
    res_mean_all = [float(r["B_over_A_residual_mean_MeV"]) for r in out_rows]
    magic_any_all = [bool(r.get("magic_any")) for r in out_rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    for eqk in eq_keys:
        xs = fit_points_by_eq[eqk]["x_fm5"]
        ys = fit_points_by_eq[eqk]["C3_est"]
        ax.scatter(xs, ys, s=8, alpha=0.25, label=f"C3_est (eq{eqk})")
        a = float(fit_by_eq[eqk]["C3_inf"])
        b = float(fit_by_eq[eqk]["C_surf_MeV_fm"])
        x0 = min(xs) if xs else 0.0
        x1 = max(xs) if xs else 1.0
        ax.plot([x0, x1], [a + b * x0, a + b * x1], linewidth=2, label=f"fit eq{eqk}: C3_inf={a:.3g}, C_surf={b:.3g}")
    ax.set_title("Radii-only fit: C3_est ≈ C3_inf + C_surf * x")
    ax.set_xlabel("x = 1/(6 ρ^2 R_sharp)  (fm^5)")
    ax.set_ylabel("C3_est_from_radii (MeV·fm^6)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=7)

    ax = axes[0][1]
    xs_magic = [x for x, m in zip(a13_all, magic_any_all, strict=True) if m]
    ys_magic = [y for y, m in zip(res_mean_all, magic_any_all, strict=True) if m]
    xs_non = [x for x, m in zip(a13_all, magic_any_all, strict=True) if not m]
    ys_non = [y for y, m in zip(res_mean_all, magic_any_all, strict=True) if not m]
    ax.scatter(xs_non, ys_non, s=10, alpha=0.35, label="Δ(B/A) mean (non-magic)")
    ax.scatter(xs_magic, ys_magic, s=10, alpha=0.55, label="Δ(B/A) mean (magic Z/N)")
    ax.axhline(0.0, color="k", linewidth=1)
    ax.set_title("Residual after adding surface term (mean over eq18/eq19)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("Δ(B/A) (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][0]
    for eqk in eq_keys:
        zs = [
            float(r["per_eq"][eqk]["z_final"])
            if (isinstance(r.get("per_eq"), dict) and eqk in r["per_eq"] and isinstance(r["per_eq"][eqk], dict))
            else float("nan")
            for r in out_rows
        ]
        ax.scatter(a13_all, zs, s=8, alpha=0.20, label=f"z_final (eq{eqk})")
    ax.axhline(0.0, color="k", linewidth=1)
    ax.axhline(3.0, color="tab:red", linestyle="--", linewidth=1)
    ax.axhline(-3.0, color="tab:red", linestyle="--", linewidth=1)
    ax.set_title(f"z = residual/σ_final (domain: A>={domain_min_a})")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("z")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8, ncol=2)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        f"domain_min_A={domain_min_a}   fit_min_A={fit_min_a}   include_prelim={fit_include_preliminary}",
        f"N_total={diag['n_total']}   N_domain={diag['n_in_domain']}",
        f"residual RMS (domain; mean eq) ≈ {diag['residual_rms_domain_MeV']:.3g} MeV",
        "",
    ]
    for eqk in eq_keys:
        fb = fit_by_eq[eqk]
        lines.append(
            f"eq{eqk}: C3_inf={fb['C3_inf']:.4g}  C_surf={fb['C_surf_MeV_fm']:.4g}  "
            f"sigma_C3(resid)≈{fb['sigma_C3_fit_resid']:.3g}  (kept {int(fb['n_fit_kept'])}/{int(fb['n_fit_all'])})"
        )
        lines.append(
            f"  frac(|z|<=3) domain ≈ {diag[f'frac_within_3sigma_domain_eq{eqk}']:.3g}  (N={diag[f'n_domain_eq{eqk}']})"
        )
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_surface_term.png"
    fig.suptitle("Phase 7 / Step 7.13.15.7: surface term from radii + updated z", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_surface_term.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "in_domain",
            "magic_any",
            "A_bin",
            "radii_used",
            "R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
            "sigma_B_over_A_obs_MeV",
            "sigma_set_MeV",
            "B_over_A_pred_mean_MeV",
            "B_over_A_residual_mean_MeV",
        ]
        for eqk in eq_keys:
            header.extend(
                [
                    f"C3_inf_eq{eqk}",
                    f"C_surf_eq{eqk}_MeV_fm",
                    f"x_eq{eqk}_fm5",
                    f"C3_eff_eq{eqk}",
                    f"E3_vol_eq{eqk}_MeV",
                    f"E3_surf_equiv_eq{eqk}_MeV",
                    f"B_over_A_pred_eq{eqk}_MeV",
                    f"residual_eq{eqk}_MeV",
                    f"sigma_total_eq{eqk}_MeV",
                    f"sigma_final_eq{eqk}_MeV",
                    f"z_final_eq{eqk}",
                    f"pass_3sigma_eq{eqk}",
                ]
            )
        w.writerow(header)
        for r in out_rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                1 if bool(r["in_domain"]) else 0,
                1 if bool(r["magic_any"]) else 0,
                str(r.get("A_bin")),
                str(r.get("radii_used")),
                f"{float(r['R_sharp_fm']):.12g}",
                f"{float(r['rho_fm3']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
                f"{float(r['sigma_B_over_A_obs_MeV']):.12g}",
                f"{float(r['sigma_set_MeV']):.12g}",
                f"{float(r['B_over_A_pred_mean_MeV']):.12g}",
                f"{float(r['B_over_A_residual_mean_MeV']):.12g}",
            ]
            per_eq = r["per_eq"]
            assert isinstance(per_eq, dict)
            for eqk in eq_keys:
                pe = per_eq.get(eqk)
                if not isinstance(pe, dict):
                    row.extend(["", "", "", "", "", "", "", ""])
                    continue
                row.extend(
                    [
                        f"{float(pe['C3_inf']):.12g}",
                        f"{float(pe['C_surf_MeV_fm']):.12g}",
                        f"{float(pe['x_fm5']):.12g}",
                        f"{float(pe['C3_eff']):.12g}",
                        f"{float(pe['E_3body_volume_MeV_per_A']):.12g}",
                        f"{float(pe['E_3body_surface_equiv_MeV_per_A']):.12g}",
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                        f"{float(pe['sigma_total_MeV']):.12g}",
                        f"{float(pe['sigma_final_MeV']):.12g}",
                        f"{float(pe['z_final']):.12g}",
                        f"{float(pe['pass_3sigma']):.0f}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.7",
                "inputs": {
                    "metrics_7_13_15_6": {"path": str(metrics_7156_path), "sha256": _sha256(metrics_7156_path)},
                },
                "definition": {
                    "x_fm5": "1/(6*rho^2*R_sharp)",
                    "fit": "C3_est_from_radii ≈ C3_inf + C_surf * x  (radii-only; no B/A)",
                    "predict": "C3_eff=C3_inf+C_surf*x;  E_total/A=E_base/A+C3_eff*rho^2=E_base/A+C3_inf*rho^2+C_surf/(6R_sharp);  B/A_pred=-E_total/A",
                    "sigma_set": "0.5*|pred(eq18)-pred(eq19)| (no choosing eq)",
                },
                "fit_by_eq": fit_by_eq,
                "diag": diag,
                "rows": out_rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_8(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.8 (initial): Add an explicit *shell* systematic term (magic Z/N) as a model-error
    budget item, without changing the prediction (no deterministic correction to B/A).

    Strategy:
      - Use Step 7.13.15.7 predictions (surface term frozen by radii-only fit).
      - Define a per-category systematic σ_shell (magic_any vs nonmagic) from the residual scatter.
      - Update the rejection budget:
          sigma_final_shell^2 = sigma_final^2 + sigma_shell^2
          z_shell = residual / sigma_final_shell

    This keeps fit/predict separation: σ_shell is a *rejection budget* item, not a tuned correction.
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    sample = next((r for r in rows_in if isinstance(r, dict)), None)
    if not isinstance(sample, dict) or not isinstance(sample.get("per_eq"), dict):
        raise SystemExit(f"[fail] invalid 7.13.15.7 row structure: per_eq missing: {metrics_7157_path}")
    eq_keys = sorted([str(k) for k in sample["per_eq"].keys()], key=int)
    if set(eq_keys) != {"18", "19"}:
        raise SystemExit(f"[fail] Step 7.13.15.8 expects per_eq with eq18/eq19; got: {eq_keys}")

    def median(vals: list[float]) -> float:
        v = sorted(vals)
        m2 = len(v) // 2
        return v[m2] if (len(v) % 2 == 1) else 0.5 * (v[m2 - 1] + v[m2])

    def mad_to_sigma(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        med = median(vals)
        mad = median([abs(x - med) for x in vals])
        return float(1.4826 * mad)

    # Compute σ_shell for categories from residual_mean scatter (domain only).
    def sigma_shell_from_items(items: list[dict[str, object]]) -> float:
        resid = [
            float(r.get("B_over_A_residual_mean_MeV", float("nan")))
            for r in items
            if math.isfinite(float(r.get("B_over_A_residual_mean_MeV", float("nan"))))
        ]
        if not resid:
            return float("nan")
        # Robust "RMS about 0" scale for typical |residual| (do not center by median).
        sigma_resid0 = math.sqrt(median([float(x) ** 2 for x in resid]))

        sigma_mean_sq: list[float] = []
        for r in items:
            if not isinstance(r, dict):
                continue
            sigma_set = float(r.get("sigma_set_MeV", 0.0))
            pe = r.get("per_eq")
            if not isinstance(pe, dict):
                continue
            s18 = pe.get("18")
            s19 = pe.get("19")
            if not (isinstance(s18, dict) and isinstance(s19, dict)):
                continue
            st18 = float(s18.get("sigma_total_MeV", float("nan")))
            st19 = float(s19.get("sigma_total_MeV", float("nan")))
            if not (math.isfinite(st18) and math.isfinite(st19)):
                continue
            sigma_total_mean = math.sqrt(0.5 * (st18**2 + st19**2))
            sigma_mean = math.sqrt(sigma_total_mean**2 + float(sigma_set) ** 2)
            if math.isfinite(sigma_mean) and sigma_mean > 0:
                sigma_mean_sq.append(float(sigma_mean**2))

        base_sq = median(sigma_mean_sq) if sigma_mean_sq else 0.0
        extra_sq = max(0.0, float(sigma_resid0) ** 2 - float(base_sq))
        return float(math.sqrt(extra_sq))

    rows_domain = [r for r in rows_in if isinstance(r, dict) and int(r.get("A", 0)) >= int(domain_min_a)]
    rows_magic = [r for r in rows_domain if bool(r.get("magic_any"))]
    rows_nonmagic = [r for r in rows_domain if not bool(r.get("magic_any"))]

    sigma_shell_magic = sigma_shell_from_items(rows_magic)
    sigma_shell_nonmagic = sigma_shell_from_items(rows_nonmagic)
    if not (math.isfinite(sigma_shell_magic) and math.isfinite(sigma_shell_nonmagic)):
        raise SystemExit("[fail] could not derive sigma_shell for categories (magic/nonmagic)")

    out_rows: list[dict[str, object]] = []
    z_mean_shell_all: list[float] = []
    z_mean_shell_dom: list[float] = []
    z_shell_dom_by_eq: dict[str, list[float]] = {k: [] for k in eq_keys}

    for r in rows_in:
        if not isinstance(r, dict):
            continue
        A = int(r.get("A", 0))
        in_domain = bool(A >= int(domain_min_a))
        magic_any = bool(r.get("magic_any"))

        sigma_shell = float(sigma_shell_magic) if magic_any else float(sigma_shell_nonmagic)
        sigma_set = float(r.get("sigma_set_MeV", 0.0))
        resid_mean = float(r.get("B_over_A_residual_mean_MeV", float("nan")))

        pe = r.get("per_eq")
        if not isinstance(pe, dict):
            continue
        pe18 = pe.get("18")
        pe19 = pe.get("19")
        if not (isinstance(pe18, dict) and isinstance(pe19, dict)):
            continue

        st18 = float(pe18.get("sigma_total_MeV", float("nan")))
        st19 = float(pe19.get("sigma_total_MeV", float("nan")))
        sigma_total_mean = math.sqrt(0.5 * (st18**2 + st19**2)) if (math.isfinite(st18) and math.isfinite(st19)) else float("nan")
        sigma_mean = math.sqrt(sigma_total_mean**2 + float(sigma_set) ** 2) if math.isfinite(sigma_total_mean) else float("nan")
        sigma_mean_shell = (
            math.sqrt(float(sigma_mean) ** 2 + float(sigma_shell) ** 2) if math.isfinite(sigma_mean) and sigma_mean > 0 else float("nan")
        )
        z_mean_shell = float(resid_mean) / float(sigma_mean_shell) if (math.isfinite(resid_mean) and math.isfinite(sigma_mean_shell) and sigma_mean_shell > 0) else float("nan")
        if math.isfinite(z_mean_shell):
            z_mean_shell_all.append(float(z_mean_shell))
            if in_domain:
                z_mean_shell_dom.append(float(z_mean_shell))

        item: dict[str, object] = {
            "key": str(r.get("key")),
            "label": str(r.get("label")),
            "A": A,
            "Z": int(r.get("Z", 0)),
            "N": int(r.get("N", 0)),
            "in_domain": in_domain,
            "magic_any": magic_any,
            "radii_used": str(r.get("radii_used")),
            "A_bin": str(r.get("A_bin")),
            "B_over_A_obs_MeV": float(r.get("B_over_A_obs_MeV", float("nan"))),
            "B_over_A_pred_mean_MeV": float(r.get("B_over_A_pred_mean_MeV", float("nan"))),
            "B_over_A_residual_mean_MeV": float(resid_mean),
            "sigma_set_MeV": float(sigma_set),
            "sigma_mean_MeV": float(sigma_mean),
            "sigma_shell_MeV": float(sigma_shell),
            "sigma_mean_shell_MeV": float(sigma_mean_shell),
            "z_mean_shell": float(z_mean_shell),
            "per_eq": {},
        }

        per_eq_out: dict[str, dict[str, float]] = {}
        for eqk in eq_keys:
            pei = pe.get(eqk)
            if not isinstance(pei, dict):
                continue
            residual = float(pei.get("B_over_A_residual_MeV", float("nan")))
            sigma_final = float(pei.get("sigma_final_MeV", float("nan")))
            sigma_final_shell = (
                math.sqrt(float(sigma_final) ** 2 + float(sigma_shell) ** 2) if math.isfinite(sigma_final) and sigma_final > 0 else float("nan")
            )
            z_shell = float(residual) / float(sigma_final_shell) if (math.isfinite(residual) and math.isfinite(sigma_final_shell) and sigma_final_shell > 0) else float("nan")
            passed = bool(math.isfinite(z_shell) and abs(float(z_shell)) <= 3.0)

            if in_domain and math.isfinite(z_shell):
                z_shell_dom_by_eq[eqk].append(float(z_shell))

            per_eq_out[eqk] = {
                "B_over_A_pred_MeV": float(pei.get("B_over_A_pred_MeV", float("nan"))),
                "B_over_A_residual_MeV": float(residual),
                "sigma_total_MeV": float(pei.get("sigma_total_MeV", float("nan"))),
                "sigma_set_MeV": float(pei.get("sigma_set_MeV", float("nan"))),
                "sigma_final_MeV": float(sigma_final),
                "sigma_shell_MeV": float(sigma_shell),
                "sigma_final_shell_MeV": float(sigma_final_shell),
                "z_shell": float(z_shell),
                "pass_3sigma_shell": 1.0 if passed else 0.0,
            }

        item["per_eq"] = per_eq_out
        out_rows.append(item)

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    diag: dict[str, object] = {
        "domain_min_A": int(domain_min_a),
        "n_total": int(len(out_rows)),
        "n_in_domain": int(sum(1 for r in out_rows if bool(r.get("in_domain")))),
        "sigma_shell_magic_MeV": float(sigma_shell_magic),
        "sigma_shell_nonmagic_MeV": float(sigma_shell_nonmagic),
        "z_mean_shell_rms_domain": float(rms(z_mean_shell_dom)),
        "frac_within_3sigma_mean_shell_domain": float(sum(1 for z in z_mean_shell_dom if abs(float(z)) <= 3.0) / len(z_mean_shell_dom))
        if z_mean_shell_dom
        else float("nan"),
    }
    for eqk in eq_keys:
        zs = z_shell_dom_by_eq[eqk]
        diag[f"chi2_like_domain_eq{eqk}"] = float(sum(float(z) ** 2 for z in zs)) if zs else float("nan")
        diag[f"n_domain_eq{eqk}"] = int(len(zs))
        diag[f"frac_within_3sigma_domain_eq{eqk}"] = float(sum(1 for z in zs if abs(float(z)) <= 3.0) / len(zs)) if zs else float("nan")

    # Plot (2x2)
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in out_rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    res_mean = [float(r["B_over_A_residual_mean_MeV"]) for r in out_rows]
    z_mean = [float(r["z_mean_shell"]) for r in out_rows]
    sig_mean = [float(r["sigma_mean_MeV"]) for r in out_rows]
    sig_mean_shell = [float(r["sigma_mean_shell_MeV"]) for r in out_rows]
    magic = [bool(r["magic_any"]) for r in out_rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.scatter([x for x, m in zip(a13, magic, strict=True) if not m], [y for y, m in zip(res_mean, magic, strict=True) if not m], s=8, alpha=0.35, label="Δ(B/A) mean (non-magic)")
    ax.scatter([x for x, m in zip(a13, magic, strict=True) if m], [y for y, m in zip(res_mean, magic, strict=True) if m], s=9, alpha=0.55, label="Δ(B/A) mean (magic Z/N)")
    ax.axhline(0.0, color="k", linewidth=1)
    ax.set_title("Residual (mean over eq18/eq19) with shell categories")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("Δ(B/A) (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[0][1]
    ax.scatter([x for x, m in zip(a13, magic, strict=True) if not m], [y for y, m in zip(z_mean, magic, strict=True) if not m], s=8, alpha=0.35, label="z_mean_shell (non-magic)")
    ax.scatter([x for x, m in zip(a13, magic, strict=True) if m], [y for y, m in zip(z_mean, magic, strict=True) if m], s=9, alpha=0.55, label="z_mean_shell (magic)")
    ax.axhline(0.0, color="k", linewidth=1)
    ax.axhline(3.0, color="tab:red", linestyle="--", linewidth=1)
    ax.axhline(-3.0, color="tab:red", linestyle="--", linewidth=1)
    ax.set_title("z = residual / sqrt(σ_mean^2 + σ_shell^2)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("z_mean_shell")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][0]
    ax.scatter(a13, sig_mean, s=8, alpha=0.25, label="σ_mean (obs+radii+C3fit + σ_set)")
    ax.scatter(a13, sig_mean_shell, s=8, alpha=0.25, label="σ_mean_shell ( + σ_shell)")
    ax.set_title("Uncertainty budget (mean)")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("σ (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        f"domain_min_A={domain_min_a}  (N_domain={diag['n_in_domain']}/{diag['n_total']})",
        "",
        f"σ_shell(non-magic)={diag['sigma_shell_nonmagic_MeV']:.3g} MeV",
        f"σ_shell(magic)={diag['sigma_shell_magic_MeV']:.3g} MeV",
        "",
        f"z_mean_shell RMS (domain) ≈ {diag['z_mean_shell_rms_domain']:.3g}",
        f"frac(|z|<=3) mean-shell (domain) ≈ {diag['frac_within_3sigma_mean_shell_domain']:.3g}",
    ]
    for eqk in eq_keys:
        frac_key = f"frac_within_3sigma_domain_eq{eqk}"
        n_key = f"n_domain_eq{eqk}"
        lines.append(f"eq{eqk}: frac(|z|<=3) domain ≈ {diag[frac_key]:.3g}  (N={diag[n_key]})")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_term.png"
    fig.suptitle("Phase 7 / Step 7.13.15.8: shell systematic as rejection budget", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_term.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "in_domain",
            "magic_any",
            "A_bin",
            "radii_used",
            "B_over_A_residual_mean_MeV",
            "sigma_mean_MeV",
            "sigma_shell_MeV",
            "sigma_mean_shell_MeV",
            "z_mean_shell",
        ]
        for eqk in eq_keys:
            header.extend(
                [
                    f"residual_eq{eqk}_MeV",
                    f"sigma_final_eq{eqk}_MeV",
                    f"sigma_final_shell_eq{eqk}_MeV",
                    f"z_shell_eq{eqk}",
                    f"pass_3sigma_shell_eq{eqk}",
                ]
            )
        w.writerow(header)
        for r in out_rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                1 if bool(r["in_domain"]) else 0,
                1 if bool(r["magic_any"]) else 0,
                str(r.get("A_bin")),
                str(r.get("radii_used")),
                f"{float(r['B_over_A_residual_mean_MeV']):.12g}",
                f"{float(r['sigma_mean_MeV']):.12g}",
                f"{float(r['sigma_shell_MeV']):.12g}",
                f"{float(r['sigma_mean_shell_MeV']):.12g}",
                f"{float(r['z_mean_shell']):.12g}",
            ]
            per_eq = r["per_eq"]
            assert isinstance(per_eq, dict)
            for eqk in eq_keys:
                pe = per_eq.get(eqk)
                if not isinstance(pe, dict):
                    row.extend(["", "", "", "", ""])
                    continue
                row.extend(
                    [
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                        f"{float(pe['sigma_final_MeV']):.12g}",
                        f"{float(pe['sigma_final_shell_MeV']):.12g}",
                        f"{float(pe['z_shell']):.12g}",
                        f"{float(pe['pass_3sigma_shell']):.0f}",
                    ]
                )
            w.writerow(row)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_term_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.8",
                "inputs": {"metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)}},
                "definition": {
                    "sigma_shell_category": "sqrt(max(0, median(residual_mean^2) - median(sigma_mean^2)))  (domain-only; category split by magic_any)",
                    "sigma_final_shell": "sqrt(sigma_final^2 + sigma_shell^2)",
                },
                "diag": diag,
                "rows": out_rows,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_9(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.9 (initial): Use separation energies (S_n, S_2n) and shell-gap diagnostics as a
    decision point for handling shell systematics, without absorbing them into an overly large
    per-nucleus model-error budget.

    This is aligned with the roadmap option:
      - "judge using separation energies (shell-sensitive)" rather than re-fitting B/A.

    Definitions:
      - B(Z,N) = A * (B/A)
      - S_n(Z,N)  = B(Z,N) - B(Z,N-1)
      - S_2n(Z,N) = B(Z,N) - B(Z,N-2)
      - shell-gap (1n) at magic N0:
          gap_n(Z;N0) = S_n(Z,N0) - S_n(Z,N0+1)
      - shell-gap (2n) at magic N0:
          gap_2n(Z;N0) = S_2n(Z,N0) - S_2n(Z,N0+2)

    Inputs:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit; predictions unchanged by shell σ).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    sample = next((r for r in rows_in if isinstance(r, dict)), None)
    if not isinstance(sample, dict) or not isinstance(sample.get("per_eq"), dict):
        raise SystemExit(f"[fail] invalid 7.13.15.7 row structure: per_eq missing: {metrics_7157_path}")
    eq_keys = sorted([str(k) for k in sample["per_eq"].keys()], key=int)
    if set(eq_keys) != {"18", "19"}:
        raise SystemExit(f"[fail] Step 7.13.15.9 expects per_eq with eq18/eq19; got: {eq_keys}")

    MAGIC = {2, 8, 20, 28, 50, 82, 126}

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    # Build a single (Z,N) map. Prefer published radii if duplicates exist (should not, but keep safe).
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    # Precompute total binding energies for obs/pred (eq18/eq19/mean).
    b_obs: dict[tuple[int, int], float] = {}
    b_pred_mean: dict[tuple[int, int], float] = {}
    b_pred_by_eq: dict[str, dict[tuple[int, int], float]] = {k: {} for k in eq_keys}
    a_by_zn: dict[tuple[int, int], int] = {}
    label_by_zn: dict[tuple[int, int], str] = {}
    magic_n_by_zn: dict[tuple[int, int], bool] = {}

    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        a_by_zn[(Z, N)] = int(A)
        label_by_zn[(Z, N)] = str(r.get("label", f"Z{Z}-N{N}"))
        magic_n_by_zn[(Z, N)] = bool(r.get("magic_N")) or bool(N in MAGIC)

        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred_mean = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred_mean[(Z, N)] = float(A) * float(ba_pred_mean)

        per_eq = r.get("per_eq")
        if not isinstance(per_eq, dict):
            raise SystemExit(f"[fail] missing per_eq for Z{Z} N{N} in 7.13.15.7 metrics")
        for eqk in eq_keys:
            pe = per_eq.get(eqk)
            if not isinstance(pe, dict):
                raise SystemExit(f"[fail] missing per_eq[{eqk}] for Z{Z} N{N} in 7.13.15.7 metrics")
            ba_pred = fnum(pe.get("B_over_A_pred_MeV"), ctx=f"B/A pred eq{eqk} Z{Z} N{N}")
            b_pred_by_eq[eqk][(Z, N)] = float(A) * float(ba_pred)

    # Separation energies (domain only; require both nuclei in-domain by A>=domain_min_a).
    sn_obs: dict[tuple[int, int], float] = {}
    sn_pred_mean: dict[tuple[int, int], float] = {}
    sn_pred_by_eq: dict[str, dict[tuple[int, int], float]] = {k: {} for k in eq_keys}
    sn_rows: list[dict[str, object]] = []

    s2n_obs: dict[tuple[int, int], float] = {}
    s2n_pred_mean: dict[tuple[int, int], float] = {}
    s2n_pred_by_eq: dict[str, dict[tuple[int, int], float]] = {k: {} for k in eq_keys}
    s2n_rows: list[dict[str, object]] = []

    for (Z, N), A in a_by_zn.items():
        if A < int(domain_min_a):
            continue

        # S_n
        child1 = (Z, N - 1)
        if child1 in a_by_zn and a_by_zn[child1] >= int(domain_min_a):
            Sn_o = float(b_obs[(Z, N)] - b_obs[child1])
            Sn_pm = float(b_pred_mean[(Z, N)] - b_pred_mean[child1])
            Sn_p18 = float(b_pred_by_eq["18"][(Z, N)] - b_pred_by_eq["18"][child1])
            Sn_p19 = float(b_pred_by_eq["19"][(Z, N)] - b_pred_by_eq["19"][child1])
            sn_obs[(Z, N)] = Sn_o
            sn_pred_mean[(Z, N)] = Sn_pm
            sn_pred_by_eq["18"][(Z, N)] = Sn_p18
            sn_pred_by_eq["19"][(Z, N)] = Sn_p19

            magic_pair = bool(magic_n_by_zn.get((Z, N), False) or magic_n_by_zn.get(child1, False))
            sn_rows.append(
                {
                    "kind": "Sn",
                    "Z": int(Z),
                    "N_parent": int(N),
                    "A_parent": int(A),
                    "label_parent": str(label_by_zn[(Z, N)]),
                    "N_child": int(N - 1),
                    "A_child": int(a_by_zn[child1]),
                    "label_child": str(label_by_zn[child1]),
                    "magic_any_pair": magic_pair,
                    "obs_MeV": Sn_o,
                    "pred_eq18_MeV": Sn_p18,
                    "pred_eq19_MeV": Sn_p19,
                    "pred_mean_MeV": Sn_pm,
                    "residual_eq18_MeV": float(Sn_p18 - Sn_o),
                    "residual_eq19_MeV": float(Sn_p19 - Sn_o),
                    "residual_mean_MeV": float(Sn_pm - Sn_o),
                }
            )

        # S_2n
        child2 = (Z, N - 2)
        if child2 in a_by_zn and a_by_zn[child2] >= int(domain_min_a):
            S2n_o = float(b_obs[(Z, N)] - b_obs[child2])
            S2n_pm = float(b_pred_mean[(Z, N)] - b_pred_mean[child2])
            S2n_p18 = float(b_pred_by_eq["18"][(Z, N)] - b_pred_by_eq["18"][child2])
            S2n_p19 = float(b_pred_by_eq["19"][(Z, N)] - b_pred_by_eq["19"][child2])
            s2n_obs[(Z, N)] = S2n_o
            s2n_pred_mean[(Z, N)] = S2n_pm
            s2n_pred_by_eq["18"][(Z, N)] = S2n_p18
            s2n_pred_by_eq["19"][(Z, N)] = S2n_p19

            magic_pair = bool(magic_n_by_zn.get((Z, N), False) or magic_n_by_zn.get(child2, False))
            s2n_rows.append(
                {
                    "kind": "S2n",
                    "Z": int(Z),
                    "N_parent": int(N),
                    "A_parent": int(A),
                    "label_parent": str(label_by_zn[(Z, N)]),
                    "N_child": int(N - 2),
                    "A_child": int(a_by_zn[child2]),
                    "label_child": str(label_by_zn[child2]),
                    "magic_any_pair": magic_pair,
                    "obs_MeV": S2n_o,
                    "pred_eq18_MeV": S2n_p18,
                    "pred_eq19_MeV": S2n_p19,
                    "pred_mean_MeV": S2n_pm,
                    "residual_eq18_MeV": float(S2n_p18 - S2n_o),
                    "residual_eq19_MeV": float(S2n_p19 - S2n_o),
                    "residual_mean_MeV": float(S2n_pm - S2n_o),
                }
            )

    if not sn_rows and not s2n_rows:
        raise SystemExit(f"[fail] no valid separation-energy pairs found in-domain (A>={domain_min_a})")

    # Shell-gap diagnostics around magic N0.
    gap_sn_rows: list[dict[str, object]] = []
    for N0 in sorted(MAGIC):
        for (Z, N) in list(sn_obs.keys()):
            if N != int(N0):
                continue
            if (Z, N0 + 1) not in sn_obs:
                continue

            g_obs = float(sn_obs[(Z, N0)] - sn_obs[(Z, N0 + 1)])
            g_p18 = float(sn_pred_by_eq["18"][(Z, N0)] - sn_pred_by_eq["18"][(Z, N0 + 1)])
            g_p19 = float(sn_pred_by_eq["19"][(Z, N0)] - sn_pred_by_eq["19"][(Z, N0 + 1)])
            g_pm = float(sn_pred_mean[(Z, N0)] - sn_pred_mean[(Z, N0 + 1)])
            gap_sn_rows.append(
                {
                    "kind": "gap_Sn",
                    "Z": int(Z),
                    "N_magic": int(N0),
                    "label_N0": str(label_by_zn.get((Z, N0), f"Z{Z}_N{N0}")),
                    "label_N0p1": str(label_by_zn.get((Z, N0 + 1), f"Z{Z}_N{N0+1}")),
                    "obs_MeV": g_obs,
                    "pred_eq18_MeV": g_p18,
                    "pred_eq19_MeV": g_p19,
                    "pred_mean_MeV": g_pm,
                    "residual_mean_MeV": float(g_pm - g_obs),
                }
            )

    gap_s2n_rows: list[dict[str, object]] = []
    for N0 in sorted(MAGIC):
        for (Z, N) in list(s2n_obs.keys()):
            if N != int(N0):
                continue
            if (Z, N0 + 2) not in s2n_obs:
                continue
            g_obs = float(s2n_obs[(Z, N0)] - s2n_obs[(Z, N0 + 2)])
            g_p18 = float(s2n_pred_by_eq["18"][(Z, N0)] - s2n_pred_by_eq["18"][(Z, N0 + 2)])
            g_p19 = float(s2n_pred_by_eq["19"][(Z, N0)] - s2n_pred_by_eq["19"][(Z, N0 + 2)])
            g_pm = float(s2n_pred_mean[(Z, N0)] - s2n_pred_mean[(Z, N0 + 2)])
            gap_s2n_rows.append(
                {
                    "kind": "gap_S2n",
                    "Z": int(Z),
                    "N_magic": int(N0),
                    "label_N0": str(label_by_zn.get((Z, N0), f"Z{Z}_N{N0}")),
                    "label_N0p2": str(label_by_zn.get((Z, N0 + 2), f"Z{Z}_N{N0+2}")),
                    "obs_MeV": g_obs,
                    "pred_eq18_MeV": g_p18,
                    "pred_eq19_MeV": g_p19,
                    "pred_mean_MeV": g_pm,
                    "residual_mean_MeV": float(g_pm - g_obs),
                }
            )

    # Diagnostics summary.
    sn_resid_mean = [float(r["residual_mean_MeV"]) for r in sn_rows]
    s2n_resid_mean = [float(r["residual_mean_MeV"]) for r in s2n_rows]

    def summarize_by_magic(records: list[dict[str, object]]) -> dict[str, object]:
        magic_vals = [float(r["residual_mean_MeV"]) for r in records if bool(r.get("magic_any_pair"))]
        non_vals = [float(r["residual_mean_MeV"]) for r in records if not bool(r.get("magic_any_pair"))]
        return {
            "n_total": len(records),
            "rms_total_MeV": rms([float(r["residual_mean_MeV"]) for r in records]),
            "magic_any_pair": {"n": len(magic_vals), "rms_MeV": rms(magic_vals)},
            "nonmagic_pair": {"n": len(non_vals), "rms_MeV": rms(non_vals)},
        }

    def summarize_gaps(rows: list[dict[str, object]], *, key_label: str) -> dict[str, object]:
        by_magic: dict[int, list[dict[str, object]]] = {}
        for r in rows:
            n0 = int(r.get("N_magic", -1))
            by_magic.setdefault(n0, []).append(r)
        out: dict[str, object] = {"n_total": len(rows), "by_magic_N": {}}
        for n0 in sorted(by_magic.keys()):
            items = by_magic[n0]
            obs = [float(x["obs_MeV"]) for x in items]
            pred = [float(x["pred_mean_MeV"]) for x in items]
            resid = [float(x["residual_mean_MeV"]) for x in items]
            out["by_magic_N"][str(n0)] = {
                "n": len(items),
                f"median_{key_label}_obs_MeV": float(sorted(obs)[len(obs) // 2]) if obs else float("nan"),
                f"median_{key_label}_pred_MeV": float(sorted(pred)[len(pred) // 2]) if pred else float("nan"),
                f"rms_{key_label}_residual_MeV": rms(resid),
            }
        return out

    diag = {
        "domain_min_A": int(domain_min_a),
        "n_nuclei_total": len(nuc_by_zn),
        "n_domain_nuclei": sum(1 for a in a_by_zn.values() if int(a) >= int(domain_min_a)),
        "magic_N": sorted([int(x) for x in MAGIC]),
        "Sn": summarize_by_magic(sn_rows),
        "S2n": summarize_by_magic(s2n_rows),
        "gap_Sn": summarize_gaps(gap_sn_rows, key_label="gap_n"),
        "gap_S2n": summarize_gaps(gap_s2n_rows, key_label="gap_2n"),
    }

    # Plot.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_s2n, ax_gsn, ax_gs2n = axes.flat

    def _scatter_residual(ax, records: list[dict[str, object]], *, title: str) -> None:
        if not records:
            ax.text(0.5, 0.5, "no data", ha="center", va="center")
            ax.set_title(title)
            return
        xs = [int(r["N_parent"]) for r in records]
        ys = [float(r["residual_mean_MeV"]) for r in records]
        ms = [bool(r.get("magic_any_pair")) for r in records]
        xs_magic = [x for x, m in zip(xs, ms, strict=True) if m]
        ys_magic = [y for y, m in zip(ys, ms, strict=True) if m]
        xs_non = [x for x, m in zip(xs, ms, strict=True) if not m]
        ys_non = [y for y, m in zip(ys, ms, strict=True) if not m]
        ax.scatter(xs_non, ys_non, s=6, alpha=0.25, c="#1f77b4", label="non-magic pair")
        ax.scatter(xs_magic, ys_magic, s=8, alpha=0.35, c="#d62728", label="magic N in pair")
        for n0 in sorted(MAGIC):
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.15)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.3)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred_mean - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=8)

    _scatter_residual(ax_sn, sn_rows, title=f"S_n residuals (domain A>={domain_min_a})")
    _scatter_residual(ax_s2n, s2n_rows, title=f"S_2n residuals (domain A>={domain_min_a})")

    def _scatter_gaps(ax, rows: list[dict[str, object]], *, title: str, xlab: str, ylab: str) -> None:
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return
        by_magic: dict[int, list[dict[str, object]]] = {}
        for r in rows:
            by_magic.setdefault(int(r["N_magic"]), []).append(r)
        colors = plt.cm.tab10.colors
        for i, n0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[n0]
            xs = [float(x["obs_MeV"]) for x in items]
            ys = [float(x["pred_mean_MeV"]) for x in items]
            ax.scatter(xs, ys, s=18, alpha=0.75, color=colors[i % len(colors)], label=f"N={n0}")
        lo = min([float(r["obs_MeV"]) for r in rows] + [float(r["pred_mean_MeV"]) for r in rows])
        hi = max([float(r["obs_MeV"]) for r in rows] + [float(r["pred_mean_MeV"]) for r in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.4)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=8, ncol=2)

    _scatter_gaps(
        ax_gsn,
        gap_sn_rows,
        title="Shell gaps at magic N (1n): obs vs pred_mean",
        xlab="gap_n obs (MeV)",
        ylab="gap_n pred_mean (MeV)",
    )
    _scatter_gaps(
        ax_gs2n,
        gap_s2n_rows,
        title="Shell gaps at magic N (2n): obs vs pred_mean",
        xlab="gap_2n obs (MeV)",
        ylab="gap_2n pred_mean (MeV)",
    )

    fig.suptitle("Phase 7 / Step 7.13.15.9: separation energies and shell-gap diagnostics", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_separation_energies.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_separation_energies.csv"
    header = [
        "kind",
        "Z",
        "N_parent",
        "A_parent",
        "label_parent",
        "N_child",
        "A_child",
        "label_child",
        "magic_any_pair",
        "N_magic",
        "label_N0",
        "label_N0p1",
        "label_N0p2",
        "obs_MeV",
        "pred_eq18_MeV",
        "pred_eq19_MeV",
        "pred_mean_MeV",
        "residual_eq18_MeV",
        "residual_eq19_MeV",
        "residual_mean_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in sn_rows + s2n_rows + gap_sn_rows + gap_s2n_rows:
            w.writerow(
                [
                    str(r.get("kind", "")),
                    str(r.get("Z", "")),
                    str(r.get("N_parent", "")),
                    str(r.get("A_parent", "")),
                    str(r.get("label_parent", "")),
                    str(r.get("N_child", "")),
                    str(r.get("A_child", "")),
                    str(r.get("label_child", "")),
                    str(int(bool(r.get("magic_any_pair")))) if "magic_any_pair" in r else "",
                    str(r.get("N_magic", "")),
                    str(r.get("label_N0", "")),
                    str(r.get("label_N0p1", "")),
                    str(r.get("label_N0p2", "")),
                    f"{float(r.get('obs_MeV', float('nan'))):.12g}" if "obs_MeV" in r else "",
                    f"{float(r.get('pred_eq18_MeV', float('nan'))):.12g}" if "pred_eq18_MeV" in r else "",
                    f"{float(r.get('pred_eq19_MeV', float('nan'))):.12g}" if "pred_eq19_MeV" in r else "",
                    f"{float(r.get('pred_mean_MeV', float('nan'))):.12g}" if "pred_mean_MeV" in r else "",
                    f"{float(r.get('residual_eq18_MeV', float('nan'))):.12g}" if "residual_eq18_MeV" in r else "",
                    f"{float(r.get('residual_eq19_MeV', float('nan'))):.12g}" if "residual_eq19_MeV" in r else "",
                    f"{float(r.get('residual_mean_MeV', float('nan'))):.12g}" if "residual_mean_MeV" in r else "",
                ]
            )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_separation_energies_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.9",
                "inputs": {"metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)}},
                "definition": {
                    "B_total": "B(Z,N) = A * (B/A)",
                    "Sn": "S_n(Z,N) = B(Z,N) - B(Z,N-1)",
                    "S2n": "S_2n(Z,N) = B(Z,N) - B(Z,N-2)",
                    "gap_Sn": "gap_n(Z;N0) = S_n(Z,N0) - S_n(Z,N0+1)  (magic N0)",
                    "gap_S2n": "gap_2n(Z;N0) = S_2n(Z,N0) - S_2n(Z,N0+2)  (magic N0)",
                    "domain": f"A>= {int(domain_min_a)} for all nuclei used in the difference",
                },
                "diag": diag,
                "rows": {"Sn": sn_rows, "S2n": s2n_rows, "gap_Sn": gap_sn_rows, "gap_S2n": gap_s2n_rows},
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_10(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.10 (initial): Promote shell into a *deterministic correction* with the smallest
    possible degrees of freedom, and evaluate out-of-sample using separation energies and shell gaps.

    Model (minimal DoF):
      ΔE_shell(Z,N) = a_any * I_magic_any + a_double * I_doubly_magic

    This correction is applied to total binding energy:
      B_pred_corr(Z,N) = B_pred(Z,N) + ΔE_shell(Z,N)

    Fit/predict separation (initial, fixed protocol):
      - Fit uses ONLY S_n pairs where the pair involves magic-N in {50, 82}.
      - Evaluation reports:
          (i) all-domain RMS for S_n / S_2n and shell gaps,
          (ii) training-region RMS (N in {50,82}),
          (iii) validation-region RMS (magic-N not in {50,82}).

    Input:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    sample = next((r for r in rows_in if isinstance(r, dict)), None)
    if not isinstance(sample, dict) or not isinstance(sample.get("per_eq"), dict):
        raise SystemExit(f"[fail] invalid 7.13.15.7 row structure: per_eq missing: {metrics_7157_path}")
    eq_keys = sorted([str(k) for k in sample["per_eq"].keys()], key=int)
    if set(eq_keys) != {"18", "19"}:
        raise SystemExit(f"[fail] Step 7.13.15.10 expects per_eq with eq18/eq19; got: {eq_keys}")

    MAGIC = {2, 8, 20, 28, 50, 82, 126}
    TRAIN_MAGIC_N = {50, 82}

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def median(vals: list[float]) -> float:
        v = sorted(vals)
        m2 = len(v) // 2
        return v[m2] if (len(v) % 2 == 1) else 0.5 * (v[m2 - 1] + v[m2])

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    # Precompute total binding energies for obs/pred (mean + per-eq), plus shell indicators.
    b_obs: dict[tuple[int, int], float] = {}
    b_pred_mean: dict[tuple[int, int], float] = {}
    b_pred_by_eq: dict[str, dict[tuple[int, int], float]] = {k: {} for k in eq_keys}
    a_by_zn: dict[tuple[int, int], int] = {}
    label_by_zn: dict[tuple[int, int], str] = {}
    magic_z_by_zn: dict[tuple[int, int], bool] = {}
    magic_n_by_zn: dict[tuple[int, int], bool] = {}
    doubly_by_zn: dict[tuple[int, int], bool] = {}
    magic_any_by_zn: dict[tuple[int, int], bool] = {}

    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        a_by_zn[(Z, N)] = int(A)
        label_by_zn[(Z, N)] = str(r.get("label", f"Z{Z}-N{N}"))
        mz = bool(r.get("magic_Z")) or bool(Z in MAGIC)
        mn = bool(r.get("magic_N")) or bool(N in MAGIC)
        dm = bool(r.get("doubly_magic")) or bool(mz and mn)
        ma = bool(r.get("magic_any")) or bool(mz or mn)
        magic_z_by_zn[(Z, N)] = mz
        magic_n_by_zn[(Z, N)] = mn
        doubly_by_zn[(Z, N)] = dm
        magic_any_by_zn[(Z, N)] = ma

        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred_mean = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred_mean[(Z, N)] = float(A) * float(ba_pred_mean)

        per_eq = r.get("per_eq")
        if not isinstance(per_eq, dict):
            raise SystemExit(f"[fail] missing per_eq for Z{Z} N{N} in 7.13.15.7 metrics")
        for eqk in eq_keys:
            pe = per_eq.get(eqk)
            if not isinstance(pe, dict):
                raise SystemExit(f"[fail] missing per_eq[{eqk}] for Z{Z} N{N} in 7.13.15.7 metrics")
            ba_pred = fnum(pe.get("B_over_A_pred_MeV"), ctx=f"B/A pred eq{eqk} Z{Z} N{N}")
            b_pred_by_eq[eqk][(Z, N)] = float(A) * float(ba_pred)

    # Helper: build Sn/S2n pairs for a given binding-energy map.
    def build_pairs(*, b_map: dict[tuple[int, int], float], kind: str) -> list[dict[str, object]]:
        if kind not in {"Sn", "S2n"}:
            raise ValueError("invalid kind")
        dN = 1 if kind == "Sn" else 2
        out: list[dict[str, object]] = []
        for (Z, N), A in a_by_zn.items():
            if int(A) < int(domain_min_a):
                continue
            child = (Z, N - dN)
            if child not in a_by_zn or int(a_by_zn[child]) < int(domain_min_a):
                continue
            out.append(
                {
                    "kind": kind,
                    "Z": int(Z),
                    "N_parent": int(N),
                    "A_parent": int(A),
                    "label_parent": str(label_by_zn[(Z, N)]),
                    "N_child": int(N - dN),
                    "A_child": int(a_by_zn[child]),
                    "label_child": str(label_by_zn[child]),
                    "magicN_parent": bool(magic_n_by_zn[(Z, N)]),
                    "magicN_child": bool(magic_n_by_zn[child]),
                    "magicZ_parent": bool(magic_z_by_zn[(Z, N)]),
                    "magicZ_child": bool(magic_z_by_zn[child]),
                    "magic_any_parent": bool(magic_any_by_zn[(Z, N)]),
                    "magic_any_child": bool(magic_any_by_zn[child]),
                    "doubly_magic_parent": bool(doubly_by_zn[(Z, N)]),
                    "doubly_magic_child": bool(doubly_by_zn[child]),
                    "magic_any_pair": bool(magic_any_by_zn[(Z, N)] or magic_any_by_zn[child]),
                    "magicN_train_pair": bool(
                        (magic_n_by_zn[(Z, N)] and int(N) in TRAIN_MAGIC_N) or (magic_n_by_zn[child] and int(N - dN) in TRAIN_MAGIC_N)
                    ),
                    "magicN_other_pair": bool(
                        (
                            (magic_n_by_zn[(Z, N)] and int(N) in MAGIC and int(N) not in TRAIN_MAGIC_N)
                            or (magic_n_by_zn[child] and int(N - dN) in MAGIC and int(N - dN) not in TRAIN_MAGIC_N)
                        )
                    ),
                    "value_MeV": float(b_map[(Z, N)] - b_map[child]),
                }
            )
        return out

    # Observed Sn/S2n.
    sn_obs_pairs = build_pairs(b_map=b_obs, kind="Sn")
    s2n_obs_pairs = build_pairs(b_map=b_obs, kind="S2n")
    # Predicted (uncorrected) Sn/S2n.
    sn_pred_pairs = build_pairs(b_map=b_pred_mean, kind="Sn")
    s2n_pred_pairs = build_pairs(b_map=b_pred_mean, kind="S2n")

    # Fit: use Sn pairs only, and ONLY those involving magic-N in {50,82}.
    fit_records: list[tuple[float, float, float]] = []  # (residual, dI_any, dI_double)
    for obs_r, pred_r in zip(sn_obs_pairs, sn_pred_pairs, strict=True):
        if not bool(pred_r.get("magicN_train_pair")):
            continue
        # Features: indicator differences for the pair.
        dI_any = float(bool(pred_r["magic_any_parent"])) - float(bool(pred_r["magic_any_child"]))
        dI_d = float(bool(pred_r["doubly_magic_parent"])) - float(bool(pred_r["doubly_magic_child"]))
        if dI_any == 0.0 and dI_d == 0.0:
            continue
        resid = float(pred_r["value_MeV"] - obs_r["value_MeV"])
        fit_records.append((resid, dI_any, dI_d))

    if len(fit_records) < 2:
        raise SystemExit(f"[fail] insufficient fit records for Step 7.13.15.10 (got {len(fit_records)})")

    # Solve least squares for a_any, a_double via 2x2 normal equations.
    # Minimize Σ (resid + a_any*dI_any + a_double*dI_double)^2.
    S11 = sum(d1 * d1 for _, d1, _ in fit_records)
    S22 = sum(d2 * d2 for _, _, d2 in fit_records)
    S12 = sum(d1 * d2 for _, d1, d2 in fit_records)
    t1 = sum((-resid) * d1 for resid, d1, _ in fit_records)
    t2 = sum((-resid) * d2 for resid, _, d2 in fit_records)

    det = S11 * S22 - S12 * S12
    if abs(det) < 1e-12:
        # Fallback: fit only the best-constrained axis.
        a_any = (t1 / S11) if abs(S11) > 1e-12 else 0.0
        a_double = (t2 / S22) if abs(S22) > 1e-12 else 0.0
        solve_mode = "fallback_axis"
    else:
        a_any = (t1 * S22 - t2 * S12) / det
        a_double = (S11 * t2 - S12 * t1) / det
        solve_mode = "normal_equations_2x2"

    # Apply correction to binding energies.
    def delta_shell(zn: tuple[int, int]) -> float:
        return float(a_any) * float(bool(magic_any_by_zn[zn])) + float(a_double) * float(bool(doubly_by_zn[zn]))

    b_pred_corr: dict[tuple[int, int], float] = {}
    for zn, val in b_pred_mean.items():
        b_pred_corr[zn] = float(val) + float(delta_shell(zn))

    # Corrected Sn/S2n.
    sn_corr_pairs = build_pairs(b_map=b_pred_corr, kind="Sn")
    s2n_corr_pairs = build_pairs(b_map=b_pred_corr, kind="S2n")

    # Shell-gap diagnostics at magic N0 (use corrected predictions).
    # gap_n(Z;N0) = S_n(Z,N0) - S_n(Z,N0+1)   (magic N0)
    # gap_2n(Z;N0) = S_2n(Z,N0) - S_2n(Z,N0+2) (magic N0)
    sn_obs_map = {(int(r["Z"]), int(r["N_parent"])): float(r["value_MeV"]) for r in sn_obs_pairs}
    sn_pred_map = {(int(r["Z"]), int(r["N_parent"])): float(r["value_MeV"]) for r in sn_pred_pairs}
    sn_corr_map = {(int(r["Z"]), int(r["N_parent"])): float(r["value_MeV"]) for r in sn_corr_pairs}

    s2n_obs_map = {(int(r["Z"]), int(r["N_parent"])): float(r["value_MeV"]) for r in s2n_obs_pairs}
    s2n_pred_map = {(int(r["Z"]), int(r["N_parent"])): float(r["value_MeV"]) for r in s2n_pred_pairs}
    s2n_corr_map = {(int(r["Z"]), int(r["N_parent"])): float(r["value_MeV"]) for r in s2n_corr_pairs}

    gap_sn_rows: list[dict[str, object]] = []
    gap_s2n_rows: list[dict[str, object]] = []
    for N0 in sorted(MAGIC):
        # 1n gap
        for (Z, Np), sn0 in list(sn_obs_map.items()):
            if int(Np) != int(N0):
                continue
            if (Z, int(N0) + 1) not in sn_obs_map:
                continue
            g_obs = float(sn_obs_map[(Z, int(N0))] - sn_obs_map[(Z, int(N0) + 1)])
            g_pred = float(sn_pred_map[(Z, int(N0))] - sn_pred_map[(Z, int(N0) + 1)])
            g_corr = float(sn_corr_map[(Z, int(N0))] - sn_corr_map[(Z, int(N0) + 1)])
            gap_sn_rows.append(
                {
                    "kind": "gap_Sn",
                    "Z": int(Z),
                    "N_magic": int(N0),
                    "obs_MeV": g_obs,
                    "pred_uncorrected_MeV": g_pred,
                    "pred_corrected_MeV": g_corr,
                    "resid_uncorrected_MeV": float(g_pred - g_obs),
                    "resid_corrected_MeV": float(g_corr - g_obs),
                }
            )
        # 2n gap
        for (Z, Np), s2n0 in list(s2n_obs_map.items()):
            if int(Np) != int(N0):
                continue
            if (Z, int(N0) + 2) not in s2n_obs_map:
                continue
            g_obs = float(s2n_obs_map[(Z, int(N0))] - s2n_obs_map[(Z, int(N0) + 2)])
            g_pred = float(s2n_pred_map[(Z, int(N0))] - s2n_pred_map[(Z, int(N0) + 2)])
            g_corr = float(s2n_corr_map[(Z, int(N0))] - s2n_corr_map[(Z, int(N0) + 2)])
            gap_s2n_rows.append(
                {
                    "kind": "gap_S2n",
                    "Z": int(Z),
                    "N_magic": int(N0),
                    "obs_MeV": g_obs,
                    "pred_uncorrected_MeV": g_pred,
                    "pred_corrected_MeV": g_corr,
                    "resid_uncorrected_MeV": float(g_pred - g_obs),
                    "resid_corrected_MeV": float(g_corr - g_obs),
                }
            )

    def summarize_pairs(obs_pairs: list[dict[str, object]], pred_pairs: list[dict[str, object]], corr_pairs: list[dict[str, object]]) -> dict[str, object]:
        resid_unc = [float(p["value_MeV"]) - float(o["value_MeV"]) for o, p in zip(obs_pairs, pred_pairs, strict=True)]
        resid_cor = [float(c["value_MeV"]) - float(o["value_MeV"]) for o, c in zip(obs_pairs, corr_pairs, strict=True)]

        def region_mask(pairs: list[dict[str, object]], key: str) -> list[bool]:
            return [bool(r.get(key)) for r in pairs]

        train_mask = region_mask(pred_pairs, "magicN_train_pair")
        other_mask = region_mask(pred_pairs, "magicN_other_pair")

        def masked(vals: list[float], mask: list[bool]) -> list[float]:
            return [v for v, m2 in zip(vals, mask, strict=True) if m2]

        return {
            "n_total": len(resid_unc),
            "rms_uncorrected_MeV": rms(resid_unc),
            "rms_corrected_MeV": rms(resid_cor),
            "train_magicN_50_82": {
                "n": sum(1 for x in train_mask if x),
                "rms_uncorrected_MeV": rms(masked(resid_unc, train_mask)),
                "rms_corrected_MeV": rms(masked(resid_cor, train_mask)),
            },
            "other_magicN": {
                "n": sum(1 for x in other_mask if x),
                "rms_uncorrected_MeV": rms(masked(resid_unc, other_mask)),
                "rms_corrected_MeV": rms(masked(resid_cor, other_mask)),
            },
        }

    def summarize_gaps(rows: list[dict[str, object]]) -> dict[str, object]:
        resid_unc = [float(r["resid_uncorrected_MeV"]) for r in rows]
        resid_cor = [float(r["resid_corrected_MeV"]) for r in rows]
        by_magic: dict[int, list[dict[str, object]]] = {}
        for r in rows:
            by_magic.setdefault(int(r["N_magic"]), []).append(r)
        out: dict[str, object] = {
            "n_total": len(rows),
            "rms_resid_uncorrected_MeV": rms(resid_unc),
            "rms_resid_corrected_MeV": rms(resid_cor),
            "by_magic_N": {},
        }
        for n0 in sorted(by_magic.keys()):
            items = by_magic[n0]
            out["by_magic_N"][str(n0)] = {
                "n": len(items),
                "median_gap_obs_MeV": median([float(x["obs_MeV"]) for x in items]),
                "median_gap_pred_uncorrected_MeV": median([float(x["pred_uncorrected_MeV"]) for x in items]),
                "median_gap_pred_corrected_MeV": median([float(x["pred_corrected_MeV"]) for x in items]),
                "rms_resid_uncorrected_MeV": rms([float(x["resid_uncorrected_MeV"]) for x in items]),
                "rms_resid_corrected_MeV": rms([float(x["resid_corrected_MeV"]) for x in items]),
            }
        return out

    diag = {
        "domain_min_A": int(domain_min_a),
        "train_magic_N": sorted([int(x) for x in TRAIN_MAGIC_N]),
        "model": "DeltaE_shell(Z,N) = a_any*I_magic_any + a_double*I_doubly_magic  (applied to B_total)",
        "fit": {
            "fit_target": "Sn only",
            "fit_region": "pairs involving magic-N in {50,82}",
            "n_fit_records": len(fit_records),
            "solve_mode": solve_mode,
            "a_any_MeV": float(a_any),
            "a_double_MeV": float(a_double),
        },
        "Sn": summarize_pairs(sn_obs_pairs, sn_pred_pairs, sn_corr_pairs),
        "S2n": summarize_pairs(s2n_obs_pairs, s2n_pred_pairs, s2n_corr_pairs),
        "gap_Sn": summarize_gaps(gap_sn_rows),
        "gap_S2n": summarize_gaps(gap_s2n_rows),
    }

    # Plot: before vs after overlays.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_s2n, ax_gsn, ax_gs2n = axes.flat

    def plot_residuals(ax, obs_pairs, pred_pairs, corr_pairs, *, title: str) -> None:
        xs = [int(r["N_parent"]) for r in pred_pairs]
        r_unc = [float(p["value_MeV"]) - float(o["value_MeV"]) for o, p in zip(obs_pairs, pred_pairs, strict=True)]
        r_cor = [float(c["value_MeV"]) - float(o["value_MeV"]) for o, c in zip(obs_pairs, corr_pairs, strict=True)]
        ax.scatter(xs, r_unc, s=6, alpha=0.12, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, r_cor, s=6, alpha=0.22, c="#1f77b4", label="corrected")
        for n0 in sorted(MAGIC):
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.12)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=8)

    plot_residuals(ax_sn, sn_obs_pairs, sn_pred_pairs, sn_corr_pairs, title=f"S_n residuals (A>={domain_min_a})")
    plot_residuals(ax_s2n, s2n_obs_pairs, s2n_pred_pairs, s2n_corr_pairs, title=f"S_2n residuals (A>={domain_min_a})")

    def plot_gaps(ax, rows: list[dict[str, object]], *, title: str, xlab: str, ylab: str) -> None:
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return
        by_magic: dict[int, list[dict[str, object]]] = {}
        for r in rows:
            by_magic.setdefault(int(r["N_magic"]), []).append(r)
        colors = plt.cm.tab10.colors
        for i, n0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[n0]
            xs = [float(x["obs_MeV"]) for x in items]
            y_unc = [float(x["pred_uncorrected_MeV"]) for x in items]
            y_cor = [float(x["pred_corrected_MeV"]) for x in items]
            ax.scatter(xs, y_unc, s=20, alpha=0.35, color=colors[i % len(colors)], marker="o", label=f"N={n0} (unc)")
            ax.scatter(xs, y_cor, s=28, alpha=0.75, color=colors[i % len(colors)], marker="x", label=f"N={n0} (cor)")
        lo = min([float(r["obs_MeV"]) for r in rows] + [float(r["pred_uncorrected_MeV"]) for r in rows] + [float(r["pred_corrected_MeV"]) for r in rows])
        hi = max([float(r["obs_MeV"]) for r in rows] + [float(r["pred_uncorrected_MeV"]) for r in rows] + [float(r["pred_corrected_MeV"]) for r in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.4)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=7, ncol=2)

    plot_gaps(ax_gsn, gap_sn_rows, title="Shell gaps at magic N (1n): obs vs pred", xlab="gap_n obs (MeV)", ylab="gap_n pred (MeV)")
    plot_gaps(ax_gs2n, gap_s2n_rows, title="Shell gaps at magic N (2n): obs vs pred", xlab="gap_2n obs (MeV)", ylab="gap_2n pred (MeV)")

    fig.suptitle("Phase 7 / Step 7.13.15.10: deterministic shell correction (minimal DoF)", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_correction.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_correction.csv"
    header = [
        "kind",
        "Z",
        "N_parent",
        "A_parent",
        "label_parent",
        "N_child",
        "A_child",
        "label_child",
        "magic_any_pair",
        "magicN_train_pair",
        "magicN_other_pair",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_corrected_MeV",
        "resid_uncorrected_MeV",
        "resid_corrected_MeV",
        "N_magic",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for obs_r, pred_r, cor_r in zip(sn_obs_pairs, sn_pred_pairs, sn_corr_pairs, strict=True):
            w.writerow(
                [
                    "Sn",
                    int(pred_r["Z"]),
                    int(pred_r["N_parent"]),
                    int(pred_r["A_parent"]),
                    str(pred_r["label_parent"]),
                    int(pred_r["N_child"]),
                    int(pred_r["A_child"]),
                    str(pred_r["label_child"]),
                    int(bool(pred_r["magic_any_pair"])),
                    int(bool(pred_r["magicN_train_pair"])),
                    int(bool(pred_r["magicN_other_pair"])),
                    f"{float(obs_r['value_MeV']):.12g}",
                    f"{float(pred_r['value_MeV']):.12g}",
                    f"{float(cor_r['value_MeV']):.12g}",
                    f"{float(pred_r['value_MeV'] - obs_r['value_MeV']):.12g}",
                    f"{float(cor_r['value_MeV'] - obs_r['value_MeV']):.12g}",
                    "",
                ]
            )
        for obs_r, pred_r, cor_r in zip(s2n_obs_pairs, s2n_pred_pairs, s2n_corr_pairs, strict=True):
            w.writerow(
                [
                    "S2n",
                    int(pred_r["Z"]),
                    int(pred_r["N_parent"]),
                    int(pred_r["A_parent"]),
                    str(pred_r["label_parent"]),
                    int(pred_r["N_child"]),
                    int(pred_r["A_child"]),
                    str(pred_r["label_child"]),
                    int(bool(pred_r["magic_any_pair"])),
                    int(bool(pred_r["magicN_train_pair"])),
                    int(bool(pred_r["magicN_other_pair"])),
                    f"{float(obs_r['value_MeV']):.12g}",
                    f"{float(pred_r['value_MeV']):.12g}",
                    f"{float(cor_r['value_MeV']):.12g}",
                    f"{float(pred_r['value_MeV'] - obs_r['value_MeV']):.12g}",
                    f"{float(cor_r['value_MeV'] - obs_r['value_MeV']):.12g}",
                    "",
                ]
            )
        for r in gap_sn_rows + gap_s2n_rows:
            kind = str(r["kind"])
            w.writerow(
                [
                    kind,
                    int(r["Z"]),
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    f"{float(r['obs_MeV']):.12g}",
                    f"{float(r['pred_uncorrected_MeV']):.12g}",
                    f"{float(r['pred_corrected_MeV']):.12g}",
                    f"{float(r['resid_uncorrected_MeV']):.12g}",
                    f"{float(r['resid_corrected_MeV']):.12g}",
                    int(r["N_magic"]),
                ]
            )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_correction_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.10",
                "inputs": {"metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)}},
                "definition": {
                    "DeltaE_shell": "a_any*I_magic_any + a_double*I_doubly_magic (applied to B_total)",
                    "Sn": "S_n(Z,N) = B(Z,N) - B(Z,N-1)",
                    "S2n": "S_2n(Z,N) = B(Z,N) - B(Z,N-2)",
                    "gap_Sn": "gap_n(Z;N0) = S_n(Z,N0) - S_n(Z,N0+1)  (magic N0)",
                    "gap_S2n": "gap_2n(Z;N0) = S_2n(Z,N0) - S_2n(Z,N0+2)  (magic N0)",
                    "fit_region": "Sn pairs involving magic-N in {50,82}",
                    "domain": f"A>= {int(domain_min_a)} for all nuclei used in the difference",
                },
                "diag": diag,
                "rows": {
                    "Sn": [
                        {
                            **{k: v for k, v in p.items() if k in ('Z','N_parent','A_parent','label_parent','N_child','A_child','label_child','magic_any_pair','magicN_train_pair','magicN_other_pair')},
                            "obs_MeV": float(o["value_MeV"]),
                            "pred_uncorrected_MeV": float(p["value_MeV"]),
                            "pred_corrected_MeV": float(c["value_MeV"]),
                        }
                        for o, p, c in zip(sn_obs_pairs, sn_pred_pairs, sn_corr_pairs, strict=True)
                    ],
                    "S2n": [
                        {
                            **{k: v for k, v in p.items() if k in ('Z','N_parent','A_parent','label_parent','N_child','A_child','label_child','magic_any_pair','magicN_train_pair','magicN_other_pair')},
                            "obs_MeV": float(o["value_MeV"]),
                            "pred_uncorrected_MeV": float(p["value_MeV"]),
                            "pred_corrected_MeV": float(c["value_MeV"]),
                        }
                        for o, p, c in zip(s2n_obs_pairs, s2n_pred_pairs, s2n_corr_pairs, strict=True)
                    ],
                    "gap_Sn": gap_sn_rows,
                    "gap_S2n": gap_s2n_rows,
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_11(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.11 (initial): Make shell structure explicit as *quantized bound modes* via a
    minimal, frozen mapping from (Z,N) to a bounded "shell occupancy correction", and re-evaluate
    shell-gaps as a rejection point.

    Motivation (from 7.13.15.10): ad-hoc magic-indicator shifts do not extrapolate and can worsen
    shell-gaps. Here we switch to a quantized-mode view: a nucleus sits inside a (magic-number)
    shell, and the correction depends on the filling fraction inside that shell.

    Minimal mapping (dimensionless):
      - Define magic boundaries M = [0,2,8,20,28,50,82,126,184].
      - For a given particle number x (N or Z), find the shell [M_k, M_{k+1}] with capacity g=M_{k+1}-M_k,
        and position p=x-M_k (1..g). Define:
            S_shell(x) = p(p-g)/g     (bounded: min ~ -g/4, and S=0 at shell edges p=0 or p=g).
      - For a nucleus (Z,N,A), define ℏω(A)=41*A^{-1/3} (MeV) and add a deterministic correction to binding:
            B_corr = B_pred + κ * ℏω(A) * ( S_shell(N) + S_shell(Z) )

    Fit/predict separation (frozen protocol):
      - Fit κ using ONLY 1n shell gaps at magic N in {50,82} (training set), via least squares on gap_n.
      - Report extrapolation performance on other magic N and on gap_2n (not used in fit).

    Input:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    TRAIN_MAGIC_N = {50, 82}

    def hw_mev(A: int) -> float:
        if A <= 0:
            return float("nan")
        return float(41.0 * (float(A) ** (-1.0 / 3.0)))

    def shell_S(x: int) -> float:
        if x <= 0:
            return 0.0
        # Find shell interval (Mk < x <= Mk1).
        Mk = None
        Mk1 = None
        for a, b in zip(MAGIC[:-1], MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            # Beyond table: clamp to last interval.
            Mk = int(MAGIC[-2])
            Mk1 = int(MAGIC[-1])
            if x > Mk1:
                # Treat as being in the last shell, saturated at its edge.
                Mk = int(MAGIC[-1])
                Mk1 = int(MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    # Binding energies (obs/pred) maps, domain-limited by A>=domain_min_a.
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}
    a_by_zn: dict[tuple[int, int], int] = {}
    label_by_zn: dict[tuple[int, int], str] = {}

    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        label_by_zn[(Z, N)] = str(r.get("label", f"Z{Z}-N{N}"))
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.11")

    # Separation energies from binding maps (Sn/S2n).
    def build_sep(*, b_map: dict[tuple[int, int], float], kind: str) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        dN = 1 if kind == "Sn" else 2
        for (Z, N), A in a_by_zn.items():
            child = (Z, N - dN)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    sn_obs = build_sep(b_map=b_obs, kind="Sn")
    s2n_obs = build_sep(b_map=b_obs, kind="S2n")
    sn_pred_unc = build_sep(b_map=b_pred, kind="Sn")
    s2n_pred_unc = build_sep(b_map=b_pred, kind="S2n")

    # Shell-gaps at magic N0.
    def build_gap(sn_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int, int], float]:
        # Returns keyed by (Z, N_magic, dN) where dN is 1 or 2.
        out: dict[tuple[int, int, int], float] = {}
        for N0 in MAGIC[1:]:  # skip 0
            step = dN
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + step)
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(dN))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    gap_sn_obs = build_gap(sn_obs, dN=1)
    gap_sn_pred_unc = build_gap(sn_pred_unc, dN=1)
    gap_s2n_obs = build_gap(s2n_obs, dN=2)
    gap_s2n_pred_unc = build_gap(s2n_pred_unc, dN=2)

    # Fit κ on gap_n for magic N in TRAIN_MAGIC_N.
    fit_pairs: list[tuple[float, float]] = []  # (y, x) for y=(obs - pred_unc), x=delta_gap_per_kappa

    def corrected_binding(*, kappa: float) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            hw = hw_mev(int(A))
            corr = float(kappa) * float(hw) * (shell_S(int(N)) + shell_S(int(Z)))
            out[(Z, N)] = float(b_pred[(Z, N)] + corr)
        return out

    # Precompute delta_gap for kappa=1 (linear).
    b_pred_k1 = corrected_binding(kappa=1.0)
    gap_sn_pred_k1 = build_gap(build_sep(b_map=b_pred_k1, kind="Sn"), dN=1)

    for (Z, N0, dN), g_obs in gap_sn_obs.items():
        if int(dN) != 1:
            continue
        if int(N0) not in TRAIN_MAGIC_N:
            continue
        g_unc = gap_sn_pred_unc.get((int(Z), int(N0), 1))
        g_k1 = gap_sn_pred_k1.get((int(Z), int(N0), 1))
        if g_unc is None or g_k1 is None:
            continue
        x = float(g_k1 - g_unc)  # change in predicted gap per kappa=1
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_unc)
        fit_pairs.append((y, x))

    if not fit_pairs:
        raise SystemExit("[fail] no fit pairs for kappa (gap_n at magic N=50/82)")

    num = sum(y * x for y, x in fit_pairs)
    den = sum(x * x for _, x in fit_pairs)
    kappa = float(num / den) if den > 0 else 0.0

    # Build corrected maps with fitted κ.
    b_corr = corrected_binding(kappa=kappa)
    sn_pred_cor = build_sep(b_map=b_corr, kind="Sn")
    s2n_pred_cor = build_sep(b_map=b_corr, kind="S2n")
    gap_sn_pred_cor = build_gap(sn_pred_cor, dN=1)
    gap_s2n_pred_cor = build_gap(s2n_pred_cor, dN=2)

    # Diagnostics: RMS residuals for Sn/S2n and gaps.
    def residuals_sep(obs_map, pred_map) -> list[float]:
        out: list[float] = []
        for k, v in obs_map.items():
            if k not in pred_map:
                continue
            out.append(float(pred_map[k] - v))
        return out

    diag = {
        "domain_min_A": int(domain_min_a),
        "magic_boundaries": MAGIC,
        "train_magic_N": sorted([int(x) for x in TRAIN_MAGIC_N]),
        "model": {
            "S_shell": "p(p-g)/g  within magic shell [Mk, Mk1] (0..g)",
            "hw_mev": "41*A^(-1/3)",
            "B_corr": "B_pred + kappa*hw*(S_shell(N)+S_shell(Z))",
        },
        "fit": {
            "fit_target": "gap_n (1n shell gap)",
            "fit_region": "magic N in {50,82}",
            "n_fit_pairs": len(fit_pairs),
            "kappa": float(kappa),
        },
        "Sn": {
            "n": len(sn_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)),
            "rms_resid_corrected_MeV": rms(residuals_sep(sn_obs, sn_pred_cor)),
        },
        "S2n": {
            "n": len(s2n_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(s2n_obs, s2n_pred_unc)),
            "rms_resid_corrected_MeV": rms(residuals_sep(s2n_obs, s2n_pred_cor)),
        },
    }

    def summarize_gaps(obs_gap, pred_unc, pred_cor) -> dict[str, object]:
        rows_all: list[tuple[int, float, float]] = []
        rows_train: list[tuple[int, float, float]] = []
        rows_other: list[tuple[int, float, float]] = []
        for (Z, N0, dN), g_obs in obs_gap.items():
            g_u = pred_unc.get((Z, N0, dN))
            g_c = pred_cor.get((Z, N0, dN))
            if g_u is None or g_c is None:
                continue
            r_u = float(g_u - g_obs)
            r_c = float(g_c - g_obs)
            rows_all.append((int(N0), r_u, r_c))
            if int(N0) in TRAIN_MAGIC_N:
                rows_train.append((int(N0), r_u, r_c))
            else:
                rows_other.append((int(N0), r_u, r_c))

        def rms_from(items: list[tuple[int, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_corrected_MeV": rms_from(rows_all, 2),
            "train_magicN": {
                "n": len(rows_train),
                "rms_resid_uncorrected_MeV": rms_from(rows_train, 1),
                "rms_resid_corrected_MeV": rms_from(rows_train, 2),
            },
            "other_magicN": {
                "n": len(rows_other),
                "rms_resid_uncorrected_MeV": rms_from(rows_other, 1),
                "rms_resid_corrected_MeV": rms_from(rows_other, 2),
            },
        }

    diag["gap_Sn"] = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_cor)
    diag["gap_S2n"] = summarize_gaps(gap_s2n_obs, gap_s2n_pred_unc, gap_s2n_pred_cor)

    # Plot.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_s2n, ax_gsn, ax_gs2n = axes.flat

    def scatter_sep(ax, obs_map, pred_u, pred_c, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.12, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_c, s=6, alpha=0.22, c="#1f77b4", label="quantized shell (κ fit)")
        for n0 in MAGIC[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.12)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=8)

    scatter_sep(ax_sn, sn_obs, sn_pred_unc, sn_pred_cor, title=f"S_n residuals (A>={domain_min_a})")
    scatter_sep(ax_s2n, s2n_obs, s2n_pred_unc, s2n_pred_cor, title=f"S_2n residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_c, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float]] = []  # (N0, obs, u, c)
        for (Z, N0, dN), g_obs in gap_obs.items():
            gu = gap_u.get((Z, N0, dN))
            gc = gap_c.get((Z, N0, dN))
            if gu is None or gc is None:
                continue
            rows.append((int(N0), float(g_obs), float(gu), float(gc)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for n0, obs, gu, gc in rows:
            by_magic.setdefault(int(n0), []).append((obs, gu, gc))
        for i, n0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[n0]
            xs = [o for (o, _, _) in items]
            ys_u = [u for (_, u, _) in items]
            ys_c = [c for (_, _, c) in items]
            ax.scatter(xs, ys_u, s=18, alpha=0.35, color=colors[i % len(colors)], marker="o", label=f"N={n0} (unc)")
            ax.scatter(xs, ys_c, s=26, alpha=0.75, color=colors[i % len(colors)], marker="x", label=f"N={n0} (cor)")

        lo = min([o for _, o, _, _ in rows] + [u for _, _, u, _ in rows] + [c for _, _, _, c in rows])
        hi = max([o for _, o, _, _ in rows] + [u for _, _, u, _ in rows] + [c for _, _, _, c in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.4)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=7, ncol=2)

    scatter_gaps(ax_gsn, gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_cor, title="Shell gaps at magic N (1n): obs vs pred", xlab="gap_n obs (MeV)", ylab="gap_n pred (MeV)")
    scatter_gaps(ax_gs2n, gap_s2n_obs, gap_s2n_pred_unc, gap_s2n_pred_cor, title="Shell gaps at magic N (2n): obs vs pred", xlab="gap_2n obs (MeV)", ylab="gap_2n pred (MeV)")

    fig.suptitle("Phase 7 / Step 7.13.15.11: quantized shell occupancy correction (minimal κ)", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_quantization.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_quantization.csv"
    header = [
        "kind",
        "Z",
        "N_magic",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_corrected_MeV",
        "resid_uncorrected_MeV",
        "resid_corrected_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gc is None:
                continue
            w.writerow(["gap_Sn", Z, N0, f"{g_obs:.12g}", f"{gu:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gc-g_obs):.12g}"])
        for (Z, N0, _dN), g_obs in sorted(gap_s2n_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_s2n_pred_unc.get((Z, N0, 2))
            gc = gap_s2n_pred_cor.get((Z, N0, 2))
            if gu is None or gc is None:
                continue
            w.writerow(["gap_S2n", Z, N0, f"{g_obs:.12g}", f"{gu:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gc-g_obs):.12g}"])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_quantization_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.11",
                "inputs": {"metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)}},
                "definition": {
                    "magic_boundaries": MAGIC,
                    "S_shell": "p(p-g)/g  where p=x-Mk, g=Mk1-Mk, Mk < x <= Mk1",
                    "hw_mev": "41*A^(-1/3)",
                    "B_corr": "B_pred + kappa*hw*(S_shell(N)+S_shell(Z))",
                    "fit": "kappa fit on gap_n for magic N in {50,82} (least squares)",
                },
                "diag": diag,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_12(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.12 (initial): Strengthen the shell-quantization mapping by introducing a minimal
    Z/N asymmetry (separate coefficients for N and Z), while keeping identifiability and a strict
    fit/predict split.

    Model (2 DoF, linear):
      - Use the same bounded occupancy function S_shell(x) as Step 7.13.15.11.
      - Apply correction to binding energy:
          B_corr = B_pred + kN * ħω(A) * S_shell(N) + kZ * ħω(A) * S_shell(Z)

    Identifiability note:
      - Neutron observables (S_n, gap_n) depend only on the N-term (Z-term cancels in differences at fixed Z).
      - Proton observables (S_p, gap_p) depend only on the Z-term (N-term cancels in differences at fixed N).
      Therefore kN and kZ must be frozen from separate, targeted training sets.

    Frozen protocol (initial):
      - kN: fit on gap_n at magic N in {50,82} (training set), least squares (1D).
      - kZ: fit on gap_p at magic Z in {50,82} (training set), least squares (1D).
      - Evaluate extrapolation on other magic N/Z; also report gap_2n/gap_2p (not used in fit).

    Input:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    TRAIN_MAGIC_N = {50, 82}
    TRAIN_MAGIC_Z = {50, 82}

    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def shell_S(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MAGIC[:-1], MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MAGIC[-2])
            Mk1 = int(MAGIC[-1])
            if x > Mk1:
                Mk = int(MAGIC[-1])
                Mk1 = int(MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    # In-domain binding energies and correction basis terms (C_N, C_Z).
    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}
    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}
    label_by_zn: dict[tuple[int, int], str] = {}

    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        label_by_zn[(Z, N)] = str(r.get("label", f"Z{Z}-N{N}"))
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)
        hw = hw_mev(int(A))
        cN[(Z, N)] = float(hw) * float(shell_S(int(N)))
        cZ[(Z, N)] = float(hw) * float(shell_S(int(Z)))

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.12")

    # Build separation energies and gaps for N-side and Z-side.
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (Z, N_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for N0 in MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (N, Z_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    sn_obs = build_sep_n(b_obs, dN=1)
    s2n_obs = build_sep_n(b_obs, dN=2)
    sp_obs = build_sep_p(b_obs, dZ=1)
    s2p_obs = build_sep_p(b_obs, dZ=2)

    sn_pred_unc = build_sep_n(b_pred, dN=1)
    s2n_pred_unc = build_sep_n(b_pred, dN=2)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    s2p_pred_unc = build_sep_p(b_pred, dZ=2)

    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_s2n_obs = build_gap_n(s2n_obs, step=2)
    gap_sp_obs = build_gap_p(sp_obs, step=1)
    gap_s2p_obs = build_gap_p(s2p_obs, step=2)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_s2n_pred_unc = build_gap_n(s2n_pred_unc, step=2)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_s2p_pred_unc = build_gap_p(s2p_pred_unc, step=2)

    # Precompute unit-basis corrected binding maps:
    #   B_N1 = B_pred + 1*C_N  (kN=1,kZ=0)
    #   B_Z1 = B_pred + 1*C_Z  (kN=0,kZ=1)
    bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_pred.items()}
    bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_pred.items()}

    gap_sn_pred_N1 = build_gap_n(build_sep_n(bN1, dN=1), step=1)
    gap_sp_pred_Z1 = build_gap_p(build_sep_p(bZ1, dZ=1), step=1)

    # Fit kN from neutron gaps at magic N in TRAIN_MAGIC_N (1D LS).
    fit_n: list[tuple[float, float]] = []  # y, x
    for (Z, N0, step), g_obs in gap_sn_obs.items():
        if int(step) != 1 or int(N0) not in TRAIN_MAGIC_N:
            continue
        g_unc = gap_sn_pred_unc.get((Z, N0, 1))
        g_1 = gap_sn_pred_N1.get((Z, N0, 1))
        if g_unc is None or g_1 is None:
            continue
        x = float(g_1 - g_unc)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_unc)
        fit_n.append((y, x))
    if not fit_n:
        raise SystemExit("[fail] no fit data for kN (gap_n at magic N=50/82)")
    kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

    # Fit kZ from proton gaps at magic Z in TRAIN_MAGIC_Z (1D LS).
    fit_z: list[tuple[float, float]] = []  # y, x
    for (N, Z0, step), g_obs in gap_sp_obs.items():
        if int(step) != 1 or int(Z0) not in TRAIN_MAGIC_Z:
            continue
        g_unc = gap_sp_pred_unc.get((N, Z0, 1))
        g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
        if g_unc is None or g_1 is None:
            continue
        x = float(g_1 - g_unc)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_unc)
        fit_z.append((y, x))
    if not fit_z:
        raise SystemExit("[fail] no fit data for kZ (gap_p at magic Z=50/82)")
    kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))

    ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")
    solve_mode = "1d_separate_fits"

    # Corrected binding energies and diagnostics.
    b_cor: dict[tuple[int, int], float] = {}
    for zn, b0 in b_pred.items():
        b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    sn_pred_cor = build_sep_n(b_cor, dN=1)
    s2n_pred_cor = build_sep_n(b_cor, dN=2)
    sp_pred_cor = build_sep_p(b_cor, dZ=1)
    s2p_pred_cor = build_sep_p(b_cor, dZ=2)

    gap_sn_pred_cor = build_gap_n(sn_pred_cor, step=1)
    gap_s2n_pred_cor = build_gap_n(s2n_pred_cor, step=2)
    gap_sp_pred_cor = build_gap_p(sp_pred_cor, step=1)
    gap_s2p_pred_cor = build_gap_p(s2p_pred_cor, step=2)

    def residuals_sep(obs_map, pred_map) -> list[float]:
        return [float(pred_map[k] - v) for k, v in obs_map.items() if k in pred_map]

    def summarize_gaps(obs_gap, pred_unc, pred_cor, *, train_set: set[int]) -> dict[str, object]:
        rows_all: list[tuple[int, float, float]] = []
        rows_train: list[tuple[int, float, float]] = []
        rows_other: list[tuple[int, float, float]] = []
        for (Z, N0, dN), g_obs in obs_gap.items():
            gu = pred_unc.get((Z, N0, dN))
            gc = pred_cor.get((Z, N0, dN))
            if gu is None or gc is None:
                continue
            r_u = float(gu - g_obs)
            r_c = float(gc - g_obs)
            rows_all.append((int(N0), r_u, r_c))
            if int(N0) in train_set:
                rows_train.append((int(N0), r_u, r_c))
            else:
                rows_other.append((int(N0), r_u, r_c))

        def rms_from(items: list[tuple[int, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_corrected_MeV": rms_from(rows_all, 2),
            "train_magicN": {"n": len(rows_train), "rms_resid_uncorrected_MeV": rms_from(rows_train, 1), "rms_resid_corrected_MeV": rms_from(rows_train, 2)},
            "other_magicN": {"n": len(rows_other), "rms_resid_uncorrected_MeV": rms_from(rows_other, 1), "rms_resid_corrected_MeV": rms_from(rows_other, 2)},
        }

    diag = {
        "domain_min_A": int(domain_min_a),
        "magic_boundaries": MAGIC,
        "train_magic_N": sorted([int(x) for x in TRAIN_MAGIC_N]),
        "train_magic_Z": sorted([int(x) for x in TRAIN_MAGIC_Z]),
        "model": {
            "S_shell": "p(p-g)/g  within magic shell [Mk, Mk1] (0..g)",
            "hw_mev": "41*A^(-1/3)",
            "B_corr": "B_pred + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)",
        },
        "fit": {
            "fit_target": "gap_n @ magic N=50/82  AND  gap_p @ magic Z=50/82 (separate 1D fits)",
            "fit_region": "kN: magic N in {50,82}; kZ: magic Z in {50,82}",
            "n_fit_pairs_kN": len(fit_n),
            "n_fit_pairs_kZ": len(fit_z),
            "solve_mode": solve_mode,
            "kN": float(kN),
            "kZ": float(kZ),
            "kZ_over_kN": ratio_kZ_over_kN,
        },
        "Sn": {
            "n": len(sn_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)),
            "rms_resid_corrected_MeV": rms(residuals_sep(sn_obs, sn_pred_cor)),
        },
        "S2n": {
            "n": len(s2n_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(s2n_obs, s2n_pred_unc)),
            "rms_resid_corrected_MeV": rms(residuals_sep(s2n_obs, s2n_pred_cor)),
        },
        "Sp": {
            "n": len(sp_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sp_obs, sp_pred_unc)),
            "rms_resid_corrected_MeV": rms(residuals_sep(sp_obs, sp_pred_cor)),
        },
        "S2p": {
            "n": len(s2p_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(s2p_obs, s2p_pred_unc)),
            "rms_resid_corrected_MeV": rms(residuals_sep(s2p_obs, s2p_pred_cor)),
        },
        "gap_Sn": summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_cor, train_set=TRAIN_MAGIC_N),
        "gap_S2n": summarize_gaps(gap_s2n_obs, gap_s2n_pred_unc, gap_s2n_pred_cor, train_set=TRAIN_MAGIC_N),
        "gap_Sp": summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_cor, train_set=TRAIN_MAGIC_Z),
        "gap_S2p": summarize_gaps(gap_s2p_obs, gap_s2p_pred_unc, gap_s2p_pred_cor, train_set=TRAIN_MAGIC_Z),
    }

    # Plot: show N-side and Z-side with explicit observables.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_sp, ax_gsn, ax_gsp = axes.flat

    def scatter_sep(ax, obs_map, pred_u, pred_c, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.12, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_c, s=6, alpha=0.22, c="#1f77b4", label="quantized shell (kN/kZ fit)")
        for n0 in MAGIC[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.12)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=8)

    scatter_sep(ax_sn, sn_obs, sn_pred_unc, sn_pred_cor, title=f"S_n residuals (A>={domain_min_a})")
    # For proton separation energies, plot vs Z (parent).
    def scatter_sep_p(ax, obs_map, pred_u, pred_c, *, title: str) -> None:
        xs = [int(Z) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.12, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_c, s=6, alpha=0.22, c="#1f77b4", label="quantized shell (kN/kZ fit)")
        for z0 in MAGIC[1:]:
            ax.axvline(int(z0), color="k", lw=0.6, alpha=0.12)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("Z (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=8)

    scatter_sep_p(ax_sp, sp_obs, sp_pred_unc, sp_pred_cor, title=f"S_p residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_c, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float]] = []  # (N0, obs, u, c)
        for (Z, N0, dN), g_obs in gap_obs.items():
            gu = gap_u.get((Z, N0, dN))
            gc = gap_c.get((Z, N0, dN))
            if gu is None or gc is None:
                continue
            rows.append((int(N0), float(g_obs), float(gu), float(gc)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for n0, obs, gu, gc in rows:
            by_magic.setdefault(int(n0), []).append((obs, gu, gc))
        for i, n0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[n0]
            xs = [o for (o, _, _) in items]
            ys_u = [u for (_, u, _) in items]
            ys_c = [c for (_, _, c) in items]
            ax.scatter(xs, ys_u, s=18, alpha=0.35, color=colors[i % len(colors)], marker="o", label=f"N={n0} (unc)")
            ax.scatter(xs, ys_c, s=26, alpha=0.75, color=colors[i % len(colors)], marker="x", label=f"N={n0} (cor)")

        lo = min([o for _, o, _, _ in rows] + [u for _, _, u, _ in rows] + [c for _, _, _, c in rows])
        hi = max([o for _, o, _, _ in rows] + [u for _, _, u, _ in rows] + [c for _, _, _, c in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.4)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=7, ncol=2)

    scatter_gaps(ax_gsn, gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_cor, title="Shell gaps at magic N (1n): obs vs pred", xlab="gap_n obs (MeV)", ylab="gap_n pred (MeV)")
    scatter_gaps(ax_gsp, gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_cor, title="Shell gaps at magic Z (1p): obs vs pred", xlab="gap_p obs (MeV)", ylab="gap_p pred (MeV)")

    fig.suptitle("Phase 7 / Step 7.13.15.12: quantized shell correction with N/Z asymmetry", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_quantization_asym.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_quantization_asym.csv"
    header = ["kind", "key1", "key2", "obs_MeV", "pred_uncorrected_MeV", "pred_corrected_MeV", "resid_uncorrected_MeV", "resid_corrected_MeV"]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gc is None:
                continue
            w.writerow(["gap_Sn", f"Z{Z}", f"N{N0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gc-g_obs):.12g}"])
        for (N, Z0, _step), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gc = gap_sp_pred_cor.get((N, Z0, 1))
            if gu is None or gc is None:
                continue
            w.writerow(["gap_Sp", f"N{N}", f"Z{Z0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gc-g_obs):.12g}"])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_quantization_asym_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.12",
                "inputs": {"metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)}},
                "definition": {
                    "magic_boundaries": MAGIC,
                    "S_shell": "p(p-g)/g  where p=x-Mk, g=Mk1-Mk, Mk < x <= Mk1",
                    "hw_mev": "41*A^(-1/3)",
                "B_corr": "B_pred + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)",
                "fit": "kN fit on gap_n (magic N in {50,82}); kZ fit on gap_p (magic Z in {50,82})",
            },
            "diag": diag,
            "outputs": {"png": str(out_png), "csv": str(out_csv)},
        },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_13(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.13 (initial): Generate shell capacities (degeneracy structure) from a minimal,
    internal spectrum model (not a fixed magic list), and re-evaluate shell gaps under the same
    strict fit/predict protocol used in 7.13.15.12.

    Motivation (from 7.13.15.11–.12): providing the magic boundaries externally can make the shell
    mapping overfit the training magic (50/82) while worsening extrapolation to other closures.
    Here we instead generate "shell boundaries" from a frozen one-body spectrum ansatz and test
    whether shell-gap extrapolation improves.

    Spectrum ansatz (frozen; dimensionless in units of ħω):
      - Spherical HO major shells (N_ho) with a Nilsson-like l·s + l^2 splitting:
          E = (N_ho + 3/2) - 2κ (l·s) - κ μ ( l(l+1) - <l(l+1)>_{N_ho} )
        where <l(l+1)>_{N_ho} is the degeneracy-weighted average within the HO major shell.
      - We detect shell closures by large gaps in the sorted energy spectrum (grouped by exact
        degeneracy), using a robust threshold:
          closure if ΔE > gap_factor * median(ΔE).
      - The resulting cumulative occupancies define MODEL_MAGIC boundaries used for S_shell(x).

    Mapping / correction (same as 7.13.15.12, but S_shell uses MODEL_MAGIC):
      - ℏω(A)=41*A^{-1/3} (MeV)
      - B_corr = B_pred + kN * ℏω(A) * S_shell(N) + kZ * ℏω(A) * S_shell(Z)

    Fit/predict separation (frozen protocol, unchanged from 7.13.15.12):
      - kN: fit on 1n shell gaps at observed magic N in {50,82} (training set), least squares (1D).
      - kZ: fit on 1p shell gaps at observed magic Z in {50,82} (training set), least squares (1D).
      - Extrapolation is evaluated on other observed magic numbers (not used in fit).

    Input:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    # Observed magic list is used ONLY for evaluation and for the frozen training protocol.
    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    TRAIN_MAGIC_N = {50, 82}
    TRAIN_MAGIC_Z = {50, 82}

    # Frozen spectrum parameters (Nilsson-like spherical ansatz).
    NILSSON_KAPPA = 0.07
    NILSSON_MU = 0.60
    GAP_FACTOR = 2.0
    ENERGY_TOL = 1e-12

    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    def _generate_model_magic(*, max_x: int) -> dict[str, object]:
        """
        Generate shell-boundary cumulative occupancies (MODEL_MAGIC) from a frozen Nilsson-like
        spectrum, robustly detecting closures as large energy gaps.
        """
        s = 0.5

        def ldot_s(l: int, j: float) -> float:
            return float((j * (j + 1.0) - float(l * (l + 1)) - s * (s + 1.0)) / 2.0)

        def gen_orbitals(max_major: int) -> list[dict[str, float]]:
            orbs: list[dict[str, float]] = []
            for N_ho in range(max_major + 1):
                l_vals = [l for l in range(0, N_ho + 1) if ((N_ho - l) % 2) == 0]
                if not l_vals:
                    continue
                # Include spin degeneracy as a global factor (does not change the average).
                weights = [2 * (2 * l + 1) for l in l_vals]
                l2_avg = sum(w * float(l * (l + 1)) for l, w in zip(l_vals, weights, strict=True)) / float(sum(weights))

                for l in l_vals:
                    j_vals = [0.5] if l == 0 else [float(l) - 0.5, float(l) + 0.5]
                    for j in j_vals:
                        deg = int(round(2.0 * float(j) + 1.0))
                        ls_val = ldot_s(l, j)
                        E = float(N_ho + 1.5) - 2.0 * float(NILSSON_KAPPA) * float(ls_val) - float(NILSSON_KAPPA) * float(NILSSON_MU) * (float(l * (l + 1)) - float(l2_avg))
                        orbs.append(
                            {
                                "E": float(E),
                                "N_ho": float(N_ho),
                                "l": float(l),
                                "j": float(j),
                                "deg": float(deg),
                            }
                        )
            return sorted(orbs, key=lambda o: float(o["E"]))

        # Ensure we cover at least max_x (with a margin) in cumulative degeneracy.
        margin = 32
        max_major = 0
        while True:
            orbs = gen_orbitals(max_major)
            total = int(sum(int(o["deg"]) for o in orbs))
            if total >= int(max_x) + margin and max_major > 0:
                break
            max_major += 1
            if max_major > 40:
                break

        # Group orbitals by (nearly) equal energies so closures are not detected inside exact degeneracies.
        groups: list[list[dict[str, float]]] = []
        cur: list[dict[str, float]] = []
        for o in orbs:
            if not cur:
                cur = [o]
                continue
            if abs(float(o["E"]) - float(cur[0]["E"])) <= ENERGY_TOL:
                cur.append(o)
            else:
                groups.append(cur)
                cur = [o]
        if cur:
            groups.append(cur)

        gaps = []
        for g1, g2 in zip(groups[:-1], groups[1:], strict=True):
            de = float(g2[0]["E"] - g1[0]["E"])
            if math.isfinite(de) and de > ENERGY_TOL:
                gaps.append(float(de))

        median_gap = _median(gaps)
        thresh = float(GAP_FACTOR) * float(median_gap) if math.isfinite(median_gap) else float("inf")

        magic: list[int] = [0]
        cum = 0
        for g1, g2 in zip(groups[:-1], groups[1:], strict=True):
            cum += int(sum(int(o["deg"]) for o in g1))
            de = float(g2[0]["E"] - g1[0]["E"])
            if math.isfinite(de) and de > thresh:
                magic.append(int(cum))
            if cum >= int(max_x) + margin:
                break

        if magic[-1] < int(max_x) + 1:
            magic.append(int(max_x) + margin)

        # Unique + sorted (defensive).
        uniq: list[int] = []
        for x in sorted(set(int(v) for v in magic)):
            if not uniq or x != uniq[-1]:
                uniq.append(int(x))

        return {
            "max_major": int(max_major),
            "median_gap": float(median_gap),
            "gap_threshold": float(thresh),
            "magic_boundaries": uniq,
        }

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    # In-domain binding energies and correction basis terms (C_N, C_Z).
    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}

    max_n = 0
    max_z = 0
    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)
        max_n = max(max_n, int(N))
        max_z = max(max_z, int(Z))

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.13")

    model_magic_info = _generate_model_magic(max_x=max(max_n, max_z) + 32)
    MODEL_MAGIC = model_magic_info["magic_boundaries"]
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        raise SystemExit("[fail] could not generate MODEL_MAGIC boundaries")

    def shell_S_model(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        hw = hw_mev(int(A))
        cN[(Z, N)] = float(hw) * float(shell_S_model(int(N)))
        cZ[(Z, N)] = float(hw) * float(shell_S_model(int(Z)))

    # Build separation energies and gaps (evaluated at OBS_MAGIC).
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (Z, N_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (N, Z_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    sn_obs = build_sep_n(b_obs, dN=1)
    s2n_obs = build_sep_n(b_obs, dN=2)
    sp_obs = build_sep_p(b_obs, dZ=1)
    s2p_obs = build_sep_p(b_obs, dZ=2)

    sn_pred_unc = build_sep_n(b_pred, dN=1)
    s2n_pred_unc = build_sep_n(b_pred, dN=2)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    s2p_pred_unc = build_sep_p(b_pred, dZ=2)

    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_s2n_obs = build_gap_n(s2n_obs, step=2)
    gap_sp_obs = build_gap_p(sp_obs, step=1)
    gap_s2p_obs = build_gap_p(s2p_obs, step=2)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_s2n_pred_unc = build_gap_n(s2n_pred_unc, step=2)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_s2p_pred_unc = build_gap_p(s2p_pred_unc, step=2)

    # Precompute unit-basis corrected binding maps:
    #   B_N1 = B_pred + 1*C_N  (kN=1,kZ=0)
    #   B_Z1 = B_pred + 1*C_Z  (kN=0,kZ=1)
    bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_pred.items()}
    bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_pred.items()}

    gap_sn_pred_N1 = build_gap_n(build_sep_n(bN1, dN=1), step=1)
    gap_sp_pred_Z1 = build_gap_p(build_sep_p(bZ1, dZ=1), step=1)

    # Fit kN from neutron gaps at magic N in TRAIN_MAGIC_N (1D LS).
    fit_n: list[tuple[float, float]] = []  # y, x
    for (Z, N0, step), g_obs in gap_sn_obs.items():
        if int(step) != 1 or int(N0) not in TRAIN_MAGIC_N:
            continue
        g_unc = gap_sn_pred_unc.get((Z, N0, 1))
        g_1 = gap_sn_pred_N1.get((Z, N0, 1))
        if g_unc is None or g_1 is None:
            continue
        x = float(g_1 - g_unc)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_unc)
        fit_n.append((y, x))
    if not fit_n:
        raise SystemExit("[fail] no fit data for kN (gap_n at observed magic N=50/82)")
    kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

    # Fit kZ from proton gaps at magic Z in TRAIN_MAGIC_Z (1D LS).
    fit_z: list[tuple[float, float]] = []  # y, x
    for (N, Z0, step), g_obs in gap_sp_obs.items():
        if int(step) != 1 or int(Z0) not in TRAIN_MAGIC_Z:
            continue
        g_unc = gap_sp_pred_unc.get((N, Z0, 1))
        g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
        if g_unc is None or g_1 is None:
            continue
        x = float(g_1 - g_unc)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_unc)
        fit_z.append((y, x))
    if not fit_z:
        raise SystemExit("[fail] no fit data for kZ (gap_p at observed magic Z=50/82)")
    kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))

    ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

    # Corrected binding energies and diagnostics.
    b_cor: dict[tuple[int, int], float] = {}
    for zn, b0 in b_pred.items():
        b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    sn_pred_cor = build_sep_n(b_cor, dN=1)
    s2n_pred_cor = build_sep_n(b_cor, dN=2)
    sp_pred_cor = build_sep_p(b_cor, dZ=1)
    s2p_pred_cor = build_sep_p(b_cor, dZ=2)

    gap_sn_pred_cor = build_gap_n(sn_pred_cor, step=1)
    gap_s2n_pred_cor = build_gap_n(s2n_pred_cor, step=2)
    gap_sp_pred_cor = build_gap_p(sp_pred_cor, step=1)
    gap_s2p_pred_cor = build_gap_p(s2p_pred_cor, step=2)

    def residuals_sep(obs_map, pred_map) -> list[float]:
        return [float(pred_map[k] - v) for k, v in obs_map.items() if k in pred_map]

    def summarize_gaps(obs_gap, pred_unc, pred_cor, *, train_set: set[int]) -> dict[str, object]:
        rows_all: list[tuple[int, float, float]] = []
        rows_train: list[tuple[int, float, float]] = []
        rows_other: list[tuple[int, float, float]] = []
        for (Z, N0, dN), g_obs in obs_gap.items():
            gu = pred_unc.get((Z, N0, dN))
            gc = pred_cor.get((Z, N0, dN))
            if gu is None or gc is None:
                continue
            r_u = float(gu - g_obs)
            r_c = float(gc - g_obs)
            rows_all.append((int(N0), r_u, r_c))
            if int(N0) in train_set:
                rows_train.append((int(N0), r_u, r_c))
            else:
                rows_other.append((int(N0), r_u, r_c))

        def rms_from(items: list[tuple[int, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_corrected_MeV": rms_from(rows_all, 2),
            "train_magicN": {"n": len(rows_train), "rms_resid_uncorrected_MeV": rms_from(rows_train, 1), "rms_resid_corrected_MeV": rms_from(rows_train, 2)},
            "other_magicN": {"n": len(rows_other), "rms_resid_uncorrected_MeV": rms_from(rows_other, 1), "rms_resid_corrected_MeV": rms_from(rows_other, 2)},
        }

    diag = {
        "domain_min_A": int(domain_min_a),
        "observed_magic_boundaries": OBS_MAGIC,
        "model_magic": model_magic_info,
        "model": {
            "spectrum": {
                "type": "nilsson_like_spherical_ho",
                "kappa": float(NILSSON_KAPPA),
                "mu": float(NILSSON_MU),
                "gap_factor": float(GAP_FACTOR),
                "energy_tol": float(ENERGY_TOL),
            },
            "S_shell": "p(p-g)/g  within MODEL_MAGIC shell [Mk, Mk1] (0..g)",
            "hw_mev": "41*A^(-1/3)",
            "B_corr": "B_pred + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)",
        },
        "fit": {
            "fit_target": "gap_n @ obs magic N=50/82  AND  gap_p @ obs magic Z=50/82 (separate 1D fits)",
            "fit_region": "kN: obs magic N in {50,82}; kZ: obs magic Z in {50,82}",
            "n_fit_pairs_kN": len(fit_n),
            "n_fit_pairs_kZ": len(fit_z),
            "kN": float(kN),
            "kZ": float(kZ),
            "kZ_over_kN": ratio_kZ_over_kN,
        },
        "Sn": {"n": len(sn_obs), "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)), "rms_resid_corrected_MeV": rms(residuals_sep(sn_obs, sn_pred_cor))},
        "S2n": {"n": len(s2n_obs), "rms_resid_uncorrected_MeV": rms(residuals_sep(s2n_obs, s2n_pred_unc)), "rms_resid_corrected_MeV": rms(residuals_sep(s2n_obs, s2n_pred_cor))},
        "Sp": {"n": len(sp_obs), "rms_resid_uncorrected_MeV": rms(residuals_sep(sp_obs, sp_pred_unc)), "rms_resid_corrected_MeV": rms(residuals_sep(sp_obs, sp_pred_cor))},
        "S2p": {"n": len(s2p_obs), "rms_resid_uncorrected_MeV": rms(residuals_sep(s2p_obs, s2p_pred_unc)), "rms_resid_corrected_MeV": rms(residuals_sep(s2p_obs, s2p_pred_cor))},
        "gap_Sn": summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_cor, train_set=TRAIN_MAGIC_N),
        "gap_S2n": summarize_gaps(gap_s2n_obs, gap_s2n_pred_unc, gap_s2n_pred_cor, train_set=TRAIN_MAGIC_N),
        "gap_Sp": summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_cor, train_set=TRAIN_MAGIC_Z),
        "gap_S2p": summarize_gaps(gap_s2p_obs, gap_s2p_pred_unc, gap_s2p_pred_cor, train_set=TRAIN_MAGIC_Z),
    }

    # Plot: show N-side and Z-side with explicit observables.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_sp, ax_gsn, ax_gsp = axes.flat

    model_lines_n = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_n]
    model_lines_z = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_z]

    def _draw_magic_lines(ax, *, obs: list[int], model: list[int]) -> None:
        for n0 in obs[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.10)
        for n0 in model:
            ax.axvline(int(n0), color="#d62728", lw=0.6, alpha=0.10, linestyle="--")

    def scatter_sep(ax, obs_map, pred_u, pred_c, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.12, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_c, s=6, alpha=0.22, c="#1f77b4", label="degeneracy-model shell (kN/kZ fit)")
        _draw_magic_lines(ax, obs=OBS_MAGIC, model=model_lines_n)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=8)

    scatter_sep(ax_sn, sn_obs, sn_pred_unc, sn_pred_cor, title=f"S_n residuals (A>={domain_min_a})")

    # For proton separation energies, plot vs Z (parent).
    def scatter_sep_p(ax, obs_map, pred_u, pred_c, *, title: str) -> None:
        xs = [int(Z) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.12, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_c, s=6, alpha=0.22, c="#1f77b4", label="degeneracy-model shell (kN/kZ fit)")
        _draw_magic_lines(ax, obs=OBS_MAGIC, model=model_lines_z)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("Z (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=8)

    scatter_sep_p(ax_sp, sp_obs, sp_pred_unc, sp_pred_cor, title=f"S_p residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_c, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float]] = []  # (N0, obs, u, c)
        for (Z, N0, dN), g_obs in gap_obs.items():
            gu = gap_u.get((Z, N0, dN))
            gc = gap_c.get((Z, N0, dN))
            if gu is None or gc is None:
                continue
            rows.append((int(N0), float(g_obs), float(gu), float(gc)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for n0, obs, gu, gc in rows:
            by_magic.setdefault(int(n0), []).append((obs, gu, gc))
        for i, n0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[n0]
            xs = [o for (o, _, _) in items]
            ys_u = [u for (_, u, _) in items]
            ys_c = [c for (_, _, c) in items]
            ax.scatter(xs, ys_u, s=18, alpha=0.35, color=colors[i % len(colors)], marker="o", label=f"N={n0} (unc)")
            ax.scatter(xs, ys_c, s=26, alpha=0.75, color=colors[i % len(colors)], marker="x", label=f"N={n0} (cor)")

        lo = min([o for _, o, _, _ in rows] + [u for _, _, u, _ in rows] + [c for _, _, _, c in rows])
        hi = max([o for _, o, _, _ in rows] + [u for _, _, u, _ in rows] + [c for _, _, _, c in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.4)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=7, ncol=2)

    scatter_gaps(ax_gsn, gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_cor, title="Shell gaps at observed magic N (1n): obs vs pred", xlab="gap_n obs (MeV)", ylab="gap_n pred (MeV)")
    scatter_gaps(ax_gsp, gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_cor, title="Shell gaps at observed magic Z (1p): obs vs pred", xlab="gap_p obs (MeV)", ylab="gap_p pred (MeV)")

    fig.suptitle("Phase 7 / Step 7.13.15.13: shell boundaries generated from a frozen degeneracy model", fontsize=12)

    # Compact legend for generated MODEL_MAGIC (first few entries).
    model_magic_short = [int(x) for x in MODEL_MAGIC if int(x) <= max(max_n, max_z)]
    text = "MODEL_MAGIC (<=max): " + ", ".join(str(x) for x in model_magic_short[:18]) + ("…" if len(model_magic_short) > 18 else "")
    fig.text(0.01, 0.01, text, ha="left", va="bottom", fontsize=8, color="#444444")

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_model.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_model.csv"
    header = ["kind", "key1", "key2", "obs_MeV", "pred_uncorrected_MeV", "pred_corrected_MeV", "resid_uncorrected_MeV", "resid_corrected_MeV"]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gc is None:
                continue
            w.writerow(["gap_Sn", f"Z{Z}", f"N{N0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gc-g_obs):.12g}"])
        for (N, Z0, _step), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gc = gap_sp_pred_cor.get((N, Z0, 1))
            if gu is None or gc is None:
                continue
            w.writerow(["gap_Sp", f"N{N}", f"Z{Z0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gc-g_obs):.12g}"])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_model_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.13",
                "inputs": {"metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)}},
                "definition": {
                    "observed_magic_boundaries": OBS_MAGIC,
                    "model_magic": model_magic_info,
                    "S_shell": "p(p-g)/g  where p=x-Mk, g=Mk1-Mk, Mk < x <= Mk1 (MODEL_MAGIC)",
                    "hw_mev": "41*A^(-1/3)",
                    "B_corr": "B_pred + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)",
                    "fit": "kN fit on gap_n (obs magic N in {50,82}); kZ fit on gap_p (obs magic Z in {50,82})",
                },
                "diag": diag,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_14(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.14 (initial): Introduce a minimal pairing (odd-even) correlation term as an
    explicit extra DoF (not a hidden model error), freeze it from a mid-shell training region,
    and evaluate whether 1n/1p shell-gap extrapolation improves.

    Model:
      - Start from Step 7.13.15.13 (degeneracy-model shell mapping) with frozen (MODEL_MAGIC, kN, kZ).
      - Add a pairing term to binding energy:
          B_pair = B_shell + a_p * s(Z,N) / sqrt(A)
        where s(Z,N)=+1 for even-even, -1 for odd-odd, and 0 for odd-A nuclei.

    Frozen protocol (initial):
      - kN/kZ and MODEL_MAGIC are taken as frozen outputs from Step 7.13.15.13.
      - Freeze a_p from observed odd-even staggering (OES; 3-point formula) on B_obs, using a
        mid-shell set (exclude nuclei near observed shell closures; tol=1). This keeps the pairing
        scale model-independent.
      - Evaluate shell gaps at observed magic numbers; report extrapolation to other magic (not in fit).

    Input:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit).
      - Step 7.13.15.13 metrics (MODEL_MAGIC and kN/kZ).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    metrics_71513_path = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_model_metrics.json"
    if not metrics_71513_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.13 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.13\n"
            f"Expected: {metrics_71513_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    m13 = _load_json(metrics_71513_path)
    diag13 = m13.get("diag") if isinstance(m13.get("diag"), dict) else {}
    def13 = m13.get("definition") if isinstance(m13.get("definition"), dict) else {}

    model_magic_info = diag13.get("model_magic") if isinstance(diag13.get("model_magic"), dict) else def13.get("model_magic")
    if not isinstance(model_magic_info, dict):
        raise SystemExit("[fail] Step 7.13.15.13 metrics missing model_magic")
    MODEL_MAGIC = model_magic_info.get("magic_boundaries")
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        raise SystemExit("[fail] Step 7.13.15.13 metrics: invalid model_magic.magic_boundaries")

    OBS_MAGIC = diag13.get("observed_magic_boundaries") if isinstance(diag13.get("observed_magic_boundaries"), list) else def13.get("observed_magic_boundaries")
    if not isinstance(OBS_MAGIC, list) or len(OBS_MAGIC) < 2:
        OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]

    fit13 = diag13.get("fit") if isinstance(diag13.get("fit"), dict) else {}

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    kN = fnum(fit13.get("kN"), ctx="7.13.15.13 diag.fit.kN")
    kZ = fnum(fit13.get("kZ"), ctx="7.13.15.13 diag.fit.kZ")

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def shell_S_model(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    def parity_sign(Z: int, N: int) -> int:
        z_even = (int(Z) % 2) == 0
        n_even = (int(N) % 2) == 0
        if z_even and n_even:
            return 1
        if (not z_even) and (not n_even):
            return -1
        return 0

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        for m0 in OBS_MAGIC:
            if abs(int(x) - int(m0)) <= int(tol):
                return True
        return False

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}

    max_n = 0
    max_z = 0
    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)
        max_n = max(max_n, int(N))
        max_z = max(max_z, int(Z))

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.14")

    # Step 7.13.15.13 shell correction basis.
    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        hw = hw_mev(int(A))
        cN[(Z, N)] = float(hw) * float(shell_S_model(int(N)))
        cZ[(Z, N)] = float(hw) * float(shell_S_model(int(Z)))

    b_shell: dict[tuple[int, int], float] = {}
    for zn, b0 in b_pred.items():
        b_shell[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    # Freeze pairing amplitude a_p from observed odd-even staggering (3-point formula),
    # independent of the mean-field / shell correction model.
    # Use a mid-shell set by excluding nuclei near observed shell closures (tol=1).
    ap_n_list: list[float] = []
    ap_p_list: list[float] = []
    for (Z, N), A in a_by_zn.items():
        if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
            continue

        if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
            dn = ((-1) ** int(N)) * (
                float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])
            ) / 2.0
            if math.isfinite(dn):
                ap_n_list.append(abs(float(dn)) * math.sqrt(float(A)))

        if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
            dp = ((-1) ** int(Z)) * (
                float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])
            ) / 2.0
            if math.isfinite(dp):
                ap_p_list.append(abs(float(dp)) * math.sqrt(float(A)))

    a_p_n = _median(ap_n_list)
    a_p_p = _median(ap_p_list)
    if math.isfinite(a_p_n) and math.isfinite(a_p_p):
        a_p = float(0.5 * (float(a_p_n) + float(a_p_p)))
    elif math.isfinite(a_p_n):
        a_p = float(a_p_n)
    elif math.isfinite(a_p_p):
        a_p = float(a_p_p)
    else:
        raise SystemExit("[fail] could not estimate pairing amplitude a_p from OES (3-point) in mid-shell set")

    # Pairing-corrected binding energies.
    b_pair: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        sgn = parity_sign(Z, N)
        term = float(a_p) * float(sgn) / math.sqrt(float(A)) if sgn != 0 else 0.0
        b_pair[(Z, N)] = float(b_shell[(Z, N)]) + float(term)

    # Build separation energies and gaps (evaluated at OBS_MAGIC).
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (Z, N_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (N, Z_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    sn_obs = build_sep_n(b_obs, dN=1)
    s2n_obs = build_sep_n(b_obs, dN=2)
    sp_obs = build_sep_p(b_obs, dZ=1)
    s2p_obs = build_sep_p(b_obs, dZ=2)

    sn_pred_unc = build_sep_n(b_pred, dN=1)
    s2n_pred_unc = build_sep_n(b_pred, dN=2)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    s2p_pred_unc = build_sep_p(b_pred, dZ=2)

    sn_pred_shell = build_sep_n(b_shell, dN=1)
    s2n_pred_shell = build_sep_n(b_shell, dN=2)
    sp_pred_shell = build_sep_p(b_shell, dZ=1)
    s2p_pred_shell = build_sep_p(b_shell, dZ=2)

    sn_pred_pair = build_sep_n(b_pair, dN=1)
    s2n_pred_pair = build_sep_n(b_pair, dN=2)
    sp_pred_pair = build_sep_p(b_pair, dZ=1)
    s2p_pred_pair = build_sep_p(b_pair, dZ=2)

    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_s2n_obs = build_gap_n(s2n_obs, step=2)
    gap_sp_obs = build_gap_p(sp_obs, step=1)
    gap_s2p_obs = build_gap_p(s2p_obs, step=2)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_s2n_pred_unc = build_gap_n(s2n_pred_unc, step=2)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_s2p_pred_unc = build_gap_p(s2p_pred_unc, step=2)

    gap_sn_pred_shell = build_gap_n(sn_pred_shell, step=1)
    gap_s2n_pred_shell = build_gap_n(s2n_pred_shell, step=2)
    gap_sp_pred_shell = build_gap_p(sp_pred_shell, step=1)
    gap_s2p_pred_shell = build_gap_p(s2p_pred_shell, step=2)

    gap_sn_pred_pair = build_gap_n(sn_pred_pair, step=1)
    gap_s2n_pred_pair = build_gap_n(s2n_pred_pair, step=2)
    gap_sp_pred_pair = build_gap_p(sp_pred_pair, step=1)
    gap_s2p_pred_pair = build_gap_p(s2p_pred_pair, step=2)

    def residuals_sep(obs_map, pred_map) -> list[float]:
        return [float(pred_map[k] - v) for k, v in obs_map.items() if k in pred_map]

    def summarize_gaps_3(obs_gap, pred_u, pred_s, pred_p, *, train_set: set[int], key_is_magic: str) -> dict[str, object]:
        rows_all: list[tuple[int, float, float, float]] = []
        rows_train: list[tuple[int, float, float, float]] = []
        rows_other: list[tuple[int, float, float, float]] = []
        for key, g_obs in obs_gap.items():
            gu = pred_u.get(key)
            gs = pred_s.get(key)
            gp = pred_p.get(key)
            if gu is None or gs is None or gp is None:
                continue
            if key_is_magic == "N":
                m0 = int(key[1])  # (Z, N0, dN)
            else:
                m0 = int(key[1])  # (N, Z0, dZ)
            r_u = float(gu - g_obs)
            r_s = float(gs - g_obs)
            r_p = float(gp - g_obs)
            rows_all.append((m0, r_u, r_s, r_p))
            if int(m0) in train_set:
                rows_train.append((m0, r_u, r_s, r_p))
            else:
                rows_other.append((m0, r_u, r_s, r_p))

        def rms_from(items: list[tuple[int, float, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_shell_MeV": rms_from(rows_all, 2),
            "rms_resid_shell_pairing_MeV": rms_from(rows_all, 3),
            "train_magic": {
                "n": len(rows_train),
                "rms_resid_uncorrected_MeV": rms_from(rows_train, 1),
                "rms_resid_shell_MeV": rms_from(rows_train, 2),
                "rms_resid_shell_pairing_MeV": rms_from(rows_train, 3),
            },
            "other_magic": {
                "n": len(rows_other),
                "rms_resid_uncorrected_MeV": rms_from(rows_other, 1),
                "rms_resid_shell_MeV": rms_from(rows_other, 2),
                "rms_resid_shell_pairing_MeV": rms_from(rows_other, 3),
            },
        }

    diag = {
        "domain_min_A": int(domain_min_a),
        "observed_magic_boundaries": [int(x) for x in OBS_MAGIC],
        "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
        "frozen_from_step_7_13_15_13": {
            "path": str(metrics_71513_path),
            "sha256": _sha256(metrics_71513_path),
            "kN": float(kN),
            "kZ": float(kZ),
        },
        "pairing": {
            "form": "B_pair = B_shell + a_p * s(Z,N)/sqrt(A); s=+1 even-even, -1 odd-odd, 0 odd-A",
            "a_p_MeV": float(a_p),
            "freeze_method": "OES 3-point on B_obs (independent of model)",
            "exclude_near_observed_magic_tol": 1,
            "a_p_n_median_MeV": float(a_p_n) if math.isfinite(a_p_n) else None,
            "a_p_p_median_MeV": float(a_p_p) if math.isfinite(a_p_p) else None,
            "n_oed_pairs_n": int(len(ap_n_list)),
            "n_oed_pairs_p": int(len(ap_p_list)),
        },
        "Sn": {
            "n": len(sn_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)),
            "rms_resid_shell_MeV": rms(residuals_sep(sn_obs, sn_pred_shell)),
            "rms_resid_shell_pairing_MeV": rms(residuals_sep(sn_obs, sn_pred_pair)),
        },
        "S2n": {
            "n": len(s2n_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(s2n_obs, s2n_pred_unc)),
            "rms_resid_shell_MeV": rms(residuals_sep(s2n_obs, s2n_pred_shell)),
            "rms_resid_shell_pairing_MeV": rms(residuals_sep(s2n_obs, s2n_pred_pair)),
        },
        "Sp": {
            "n": len(sp_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sp_obs, sp_pred_unc)),
            "rms_resid_shell_MeV": rms(residuals_sep(sp_obs, sp_pred_shell)),
            "rms_resid_shell_pairing_MeV": rms(residuals_sep(sp_obs, sp_pred_pair)),
        },
        "S2p": {
            "n": len(s2p_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(s2p_obs, s2p_pred_unc)),
            "rms_resid_shell_MeV": rms(residuals_sep(s2p_obs, s2p_pred_shell)),
            "rms_resid_shell_pairing_MeV": rms(residuals_sep(s2p_obs, s2p_pred_pair)),
        },
        "gap_Sn": summarize_gaps_3(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_shell, gap_sn_pred_pair, train_set={50, 82}, key_is_magic="N"),
        "gap_S2n": summarize_gaps_3(gap_s2n_obs, gap_s2n_pred_unc, gap_s2n_pred_shell, gap_s2n_pred_pair, train_set={50, 82}, key_is_magic="N"),
        "gap_Sp": summarize_gaps_3(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_shell, gap_sp_pred_pair, train_set={50, 82}, key_is_magic="Z"),
        "gap_S2p": summarize_gaps_3(gap_s2p_obs, gap_s2p_pred_unc, gap_s2p_pred_shell, gap_s2p_pred_pair, train_set={50, 82}, key_is_magic="Z"),
    }

    # Plot.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_sp, ax_gsn, ax_gsp = axes.flat

    model_lines_n = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_n]
    model_lines_z = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_z]

    def _draw_magic_lines(ax, *, obs: list[int], model: list[int]) -> None:
        for n0 in obs[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.10)
        for n0 in model:
            ax.axvline(int(n0), color="#d62728", lw=0.6, alpha=0.10, linestyle="--")

    def scatter_sep_n(ax, obs_map, pred_u, pred_s, pred_p, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ys_s = [float(pred_s[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ys_p = [float(pred_p[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_s, s=6, alpha=0.16, c="#1f77b4", label="shell (degeneracy model)")
        ax.scatter(xs, ys_p, s=6, alpha=0.18, c="#2ca02c", label="shell + pairing")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_n)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    def scatter_sep_p(ax, obs_map, pred_u, pred_s, pred_p, *, title: str) -> None:
        xs = [int(Z) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ys_s = [float(pred_s[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ys_p = [float(pred_p[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_s and (Z, N) in pred_p]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_s, s=6, alpha=0.16, c="#1f77b4", label="shell (degeneracy model)")
        ax.scatter(xs, ys_p, s=6, alpha=0.18, c="#2ca02c", label="shell + pairing")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_z)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("Z (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    scatter_sep_n(ax_sn, sn_obs, sn_pred_unc, sn_pred_shell, sn_pred_pair, title=f"S_n residuals (A>={domain_min_a})")
    scatter_sep_p(ax_sp, sp_obs, sp_pred_unc, sp_pred_shell, sp_pred_pair, title=f"S_p residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_s, gap_p, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float, float]] = []  # (m0, obs, u, s, p)
        for key, g_obs in gap_obs.items():
            gu = gap_u.get(key)
            gs = gap_s.get(key)
            gp = gap_p.get(key)
            if gu is None or gs is None or gp is None:
                continue
            m0 = int(key[1])
            rows.append((m0, float(g_obs), float(gu), float(gs), float(gp)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float, float]]] = {}
        for m0, obs, gu, gs, gp in rows:
            by_magic.setdefault(int(m0), []).append((obs, gu, gs, gp))
        for i, m0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[m0]
            xs = [o for (o, _, _, _) in items]
            ys_u = [u for (_, u, _, _) in items]
            ys_s = [s for (_, _, s, _) in items]
            ys_p = [p for (_, _, _, p) in items]
            col = colors[i % len(colors)]
            ax.scatter(xs, ys_u, s=18, alpha=0.25, color=col, marker="o", label=f"{m0} (unc)")
            ax.scatter(xs, ys_s, s=26, alpha=0.65, color=col, marker="x", label=f"{m0} (shell)")
            ax.scatter(xs, ys_p, s=30, alpha=0.65, color=col, marker="+", label=f"{m0} (pair)")

        lo = min([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [s for _, _, _, s, _ in rows] + [p for _, _, _, _, p in rows])
        hi = max([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [s for _, _, _, s, _ in rows] + [p for _, _, _, _, p in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.35)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=6, ncol=2)

    scatter_gaps(ax_gsn, gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_shell, gap_sn_pred_pair, title="Shell gaps at observed magic N (1n): obs vs pred", xlab="gap_n obs (MeV)", ylab="gap_n pred (MeV)")
    scatter_gaps(ax_gsp, gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_shell, gap_sp_pred_pair, title="Shell gaps at observed magic Z (1p): obs vs pred", xlab="gap_p obs (MeV)", ylab="gap_p pred (MeV)")

    fig.suptitle("Phase 7 / Step 7.13.15.14: minimal pairing term on top of degeneracy-model shell mapping", fontsize=12)
    fig.text(0.01, 0.01, f"a_p={a_p:.4g} MeV (OES 3-point; n={len(ap_n_list)}/{len(ap_p_list)})", ha="left", va="bottom", fontsize=9, color="#444444")

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_model.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_model.csv"
    header = [
        "kind",
        "key1",
        "key2",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_shell_MeV",
        "pred_shell_pairing_MeV",
        "resid_uncorrected_MeV",
        "resid_shell_MeV",
        "resid_shell_pairing_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gs = gap_sn_pred_shell.get((Z, N0, 1))
            gp = gap_sn_pred_pair.get((Z, N0, 1))
            if gu is None or gs is None or gp is None:
                continue
            w.writerow(
                [
                    "gap_Sn",
                    f"Z{Z}",
                    f"N{N0}",
                    f"{g_obs:.12g}",
                    f"{gu:.12g}",
                    f"{gs:.12g}",
                    f"{gp:.12g}",
                    f"{(gu-g_obs):.12g}",
                    f"{(gs-g_obs):.12g}",
                    f"{(gp-g_obs):.12g}",
                ]
            )
        for (N, Z0, _step), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gs = gap_sp_pred_shell.get((N, Z0, 1))
            gp = gap_sp_pred_pair.get((N, Z0, 1))
            if gu is None or gs is None or gp is None:
                continue
            w.writerow(
                [
                    "gap_Sp",
                    f"N{N}",
                    f"Z{Z0}",
                    f"{g_obs:.12g}",
                    f"{gu:.12g}",
                    f"{gs:.12g}",
                    f"{gp:.12g}",
                    f"{(gu-g_obs):.12g}",
                    f"{(gs-g_obs):.12g}",
                    f"{(gp-g_obs):.12g}",
                ]
            )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_model_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.14",
                "inputs": {
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_13": {"path": str(metrics_71513_path), "sha256": _sha256(metrics_71513_path)},
                },
                "definition": {
                    "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
                    "S_shell": "p(p-g)/g  within MODEL_MAGIC shell [Mk, Mk1] (0..g)",
                    "pairing": "B_pair = B_shell + a_p*s(Z,N)/sqrt(A); s=+1 even-even, -1 odd-odd, 0 odd-A",
                    "freeze_pairing": "a_p frozen from OES (3-point) on B_obs using mid-shell nuclei (exclude near observed magic; tol=1)",
                },
                "diag": diag,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_15(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.15 (initial): Keep pairing amplitude a_p fixed (from Step 7.13.15.14),
    then refreeze shell coefficients (kN,kZ) under the pairing-corrected baseline, and
    re-evaluate shell-gap extrapolation.

    Motivation (from 7.13.15.14): adding pairing improves other-magic extrapolation, but
    degrades train-magic gaps because kN/kZ were frozen without pairing. Here we refreeze
    kN/kZ while holding a_p fixed, keeping identifiability and a strict fit/predict split.

    Baseline:
      - MODEL_MAGIC from Step 7.13.15.13 (frozen).
      - a_p from Step 7.13.15.14 (frozen; OES 3-point).
      - B_base = B_pred + a_p*s(Z,N)/sqrt(A)

    Refreeze protocol (same training region as before):
      - kN: fit on gap_n at observed magic N in {50,82} (1D LS)
      - kZ: fit on gap_p at observed magic Z in {50,82} (1D LS)

    Correction:
      - B_corr = B_base + kN*ħω(A)*S_shell(N) + kZ*ħω(A)*S_shell(Z)

    Input:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit).
      - Step 7.13.15.13 metrics (MODEL_MAGIC).
      - Step 7.13.15.14 metrics (a_p).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    metrics_71513_path = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_model_metrics.json"
    if not metrics_71513_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.13 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.13\n"
            f"Expected: {metrics_71513_path}"
        )

    metrics_71514_path = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_model_metrics.json"
    if not metrics_71514_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.14 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.14\n"
            f"Expected: {metrics_71514_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    m13 = _load_json(metrics_71513_path)
    diag13 = m13.get("diag") if isinstance(m13.get("diag"), dict) else {}
    def13 = m13.get("definition") if isinstance(m13.get("definition"), dict) else {}

    model_magic_info = diag13.get("model_magic") if isinstance(diag13.get("model_magic"), dict) else def13.get("model_magic")
    if not isinstance(model_magic_info, dict):
        raise SystemExit("[fail] Step 7.13.15.13 metrics missing model_magic")
    MODEL_MAGIC = model_magic_info.get("magic_boundaries")
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        raise SystemExit("[fail] Step 7.13.15.13 metrics: invalid model_magic.magic_boundaries")

    OBS_MAGIC = diag13.get("observed_magic_boundaries") if isinstance(diag13.get("observed_magic_boundaries"), list) else def13.get("observed_magic_boundaries")
    if not isinstance(OBS_MAGIC, list) or len(OBS_MAGIC) < 2:
        OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]

    m14 = _load_json(metrics_71514_path)
    diag14 = m14.get("diag") if isinstance(m14.get("diag"), dict) else {}
    pairing14 = diag14.get("pairing") if isinstance(diag14.get("pairing"), dict) else {}

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    a_p = fnum(pairing14.get("a_p_MeV"), ctx="7.13.15.14 diag.pairing.a_p_MeV")

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def shell_S_model(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    def parity_sign(Z: int, N: int) -> int:
        z_even = (int(Z) % 2) == 0
        n_even = (int(N) % 2) == 0
        if z_even and n_even:
            return 1
        if (not z_even) and (not n_even):
            return -1
        return 0

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}

    max_n = 0
    max_z = 0
    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)
        max_n = max(max_n, int(N))
        max_z = max(max_z, int(Z))

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.15")

    # Pairing baseline binding energies.
    b_base: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        sgn = parity_sign(Z, N)
        term = float(a_p) * float(sgn) / math.sqrt(float(A)) if sgn != 0 else 0.0
        b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term)

    # Shell correction basis terms.
    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        hw = hw_mev(int(A))
        cN[(Z, N)] = float(hw) * float(shell_S_model(int(N)))
        cZ[(Z, N)] = float(hw) * float(shell_S_model(int(Z)))

    # Build separation energies and gaps helpers.
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (Z, N_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (N, Z_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    # Observables (obs).
    sn_obs = build_sep_n(b_obs, dN=1)
    s2n_obs = build_sep_n(b_obs, dN=2)
    sp_obs = build_sep_p(b_obs, dZ=1)
    s2p_obs = build_sep_p(b_obs, dZ=2)

    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_s2n_obs = build_gap_n(s2n_obs, step=2)
    gap_sp_obs = build_gap_p(sp_obs, step=1)
    gap_s2p_obs = build_gap_p(s2p_obs, step=2)

    # Predictions: uncorrected (B_pred), pairing-only (B_base).
    sn_pred_unc = build_sep_n(b_pred, dN=1)
    s2n_pred_unc = build_sep_n(b_pred, dN=2)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    s2p_pred_unc = build_sep_p(b_pred, dZ=2)

    sn_pred_base = build_sep_n(b_base, dN=1)
    s2n_pred_base = build_sep_n(b_base, dN=2)
    sp_pred_base = build_sep_p(b_base, dZ=1)
    s2p_pred_base = build_sep_p(b_base, dZ=2)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_s2n_pred_unc = build_gap_n(s2n_pred_unc, step=2)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_s2p_pred_unc = build_gap_p(s2p_pred_unc, step=2)

    gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
    gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

    # Unit-basis maps for kN/kZ fits, around the pairing baseline.
    bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
    bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}

    gap_sn_pred_N1 = build_gap_n(build_sep_n(bN1, dN=1), step=1)
    gap_sp_pred_Z1 = build_gap_p(build_sep_p(bZ1, dZ=1), step=1)

    # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
    fit_n: list[tuple[float, float]] = []  # y, x
    for (Z, N0, step), g_obs in gap_sn_obs.items():
        if int(step) != 1 or int(N0) not in {50, 82}:
            continue
        g_base = gap_sn_pred_base.get((Z, N0, 1))
        g_1 = gap_sn_pred_N1.get((Z, N0, 1))
        if g_base is None or g_1 is None:
            continue
        x = float(g_1 - g_base)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_base)
        fit_n.append((y, x))
    if not fit_n:
        raise SystemExit("[fail] no fit data for kN (gap_n at observed magic N=50/82)")
    kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

    # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
    fit_z: list[tuple[float, float]] = []  # y, x
    for (N, Z0, step), g_obs in gap_sp_obs.items():
        if int(step) != 1 or int(Z0) not in {50, 82}:
            continue
        g_base = gap_sp_pred_base.get((N, Z0, 1))
        g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
        if g_base is None or g_1 is None:
            continue
        x = float(g_1 - g_base)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_base)
        fit_z.append((y, x))
    if not fit_z:
        raise SystemExit("[fail] no fit data for kZ (gap_p at observed magic Z=50/82)")
    kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))

    ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

    # Corrected bindings.
    b_cor: dict[tuple[int, int], float] = {}
    for zn, b0 in b_base.items():
        b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    sn_pred_cor = build_sep_n(b_cor, dN=1)
    s2n_pred_cor = build_sep_n(b_cor, dN=2)
    sp_pred_cor = build_sep_p(b_cor, dZ=1)
    s2p_pred_cor = build_sep_p(b_cor, dZ=2)

    gap_sn_pred_cor = build_gap_n(sn_pred_cor, step=1)
    gap_s2n_pred_cor = build_gap_n(s2n_pred_cor, step=2)
    gap_sp_pred_cor = build_gap_p(sp_pred_cor, step=1)
    gap_s2p_pred_cor = build_gap_p(s2p_pred_cor, step=2)

    def residuals_sep(obs_map, pred_map) -> list[float]:
        return [float(pred_map[k] - v) for k, v in obs_map.items() if k in pred_map]

    def summarize_gaps_3(obs_gap, pred_u, pred_b, pred_c, *, train_set: set[int]) -> dict[str, object]:
        rows_all: list[tuple[int, float, float, float]] = []
        rows_train: list[tuple[int, float, float, float]] = []
        rows_other: list[tuple[int, float, float, float]] = []
        for key, g_obs in obs_gap.items():
            gu = pred_u.get(key)
            gb = pred_b.get(key)
            gc = pred_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            r_u = float(gu - g_obs)
            r_b = float(gb - g_obs)
            r_c = float(gc - g_obs)
            rows_all.append((m0, r_u, r_b, r_c))
            if int(m0) in train_set:
                rows_train.append((m0, r_u, r_b, r_c))
            else:
                rows_other.append((m0, r_u, r_b, r_c))

        def rms_from(items: list[tuple[int, float, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_pairing_only_MeV": rms_from(rows_all, 2),
            "rms_resid_pairing_shell_MeV": rms_from(rows_all, 3),
            "train_magic": {"n": len(rows_train), "rms_resid_uncorrected_MeV": rms_from(rows_train, 1), "rms_resid_pairing_only_MeV": rms_from(rows_train, 2), "rms_resid_pairing_shell_MeV": rms_from(rows_train, 3)},
            "other_magic": {"n": len(rows_other), "rms_resid_uncorrected_MeV": rms_from(rows_other, 1), "rms_resid_pairing_only_MeV": rms_from(rows_other, 2), "rms_resid_pairing_shell_MeV": rms_from(rows_other, 3)},
        }

    diag = {
        "domain_min_A": int(domain_min_a),
        "observed_magic_boundaries": [int(x) for x in OBS_MAGIC],
        "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
        "pairing": {"a_p_MeV": float(a_p), "source_step": "7.13.15.14", "metrics_path": str(metrics_71514_path), "sha256": _sha256(metrics_71514_path)},
        "fit": {
            "fit_target": "gap_n@N=50/82 and gap_p@Z=50/82 (separate 1D fits) under pairing baseline",
            "n_fit_pairs_kN": len(fit_n),
            "n_fit_pairs_kZ": len(fit_z),
            "kN": float(kN),
            "kZ": float(kZ),
            "kZ_over_kN": ratio_kZ_over_kN,
        },
        "Sn": {
            "n": len(sn_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)),
            "rms_resid_pairing_only_MeV": rms(residuals_sep(sn_obs, sn_pred_base)),
            "rms_resid_pairing_shell_MeV": rms(residuals_sep(sn_obs, sn_pred_cor)),
        },
        "Sp": {
            "n": len(sp_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sp_obs, sp_pred_unc)),
            "rms_resid_pairing_only_MeV": rms(residuals_sep(sp_obs, sp_pred_base)),
            "rms_resid_pairing_shell_MeV": rms(residuals_sep(sp_obs, sp_pred_cor)),
        },
        "gap_Sn": summarize_gaps_3(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor, train_set={50, 82}),
        "gap_Sp": summarize_gaps_3(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor, train_set={50, 82}),
        "gap_S2n": summarize_gaps_3(gap_s2n_obs, gap_s2n_pred_unc, build_gap_n(s2n_pred_base, step=2), gap_s2n_pred_cor, train_set={50, 82}),
        "gap_S2p": summarize_gaps_3(gap_s2p_obs, gap_s2p_pred_unc, build_gap_p(s2p_pred_base, step=2), gap_s2p_pred_cor, train_set={50, 82}),
    }

    # Plot.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_sp, ax_gsn, ax_gsp = axes.flat

    model_lines_n = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_n]
    model_lines_z = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_z]

    def _draw_magic_lines(ax, *, obs: list[int], model: list[int]) -> None:
        for n0 in obs[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.10)
        for n0 in model:
            ax.axvline(int(n0), color="#d62728", lw=0.6, alpha=0.10, linestyle="--")

    def scatter_sep_n(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing-only")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="pairing + shell (refrozen)")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_n)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    def scatter_sep_p(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(Z) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing-only")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="pairing + shell (refrozen)")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_z)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("Z (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    scatter_sep_n(ax_sn, sn_obs, sn_pred_unc, sn_pred_base, sn_pred_cor, title=f"S_n residuals (A>={domain_min_a})")
    scatter_sep_p(ax_sp, sp_obs, sp_pred_unc, sp_pred_base, sp_pred_cor, title=f"S_p residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_b, gap_c, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float, float]] = []
        for key, g_obs in gap_obs.items():
            gu = gap_u.get(key)
            gb = gap_b.get(key)
            gc = gap_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            rows.append((m0, float(g_obs), float(gu), float(gb), float(gc)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float, float]]] = {}
        for m0, obs, gu, gb, gc in rows:
            by_magic.setdefault(int(m0), []).append((obs, gu, gb, gc))
        for i, m0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[m0]
            xs = [o for (o, _, _, _) in items]
            ys_u = [u for (_, u, _, _) in items]
            ys_b = [b for (_, _, b, _) in items]
            ys_c = [c for (_, _, _, c) in items]
            col = colors[i % len(colors)]
            ax.scatter(xs, ys_u, s=18, alpha=0.25, color=col, marker="o", label=f"{m0} (unc)")
            ax.scatter(xs, ys_b, s=26, alpha=0.65, color=col, marker="x", label=f"{m0} (pair)")
            ax.scatter(xs, ys_c, s=30, alpha=0.65, color=col, marker="+", label=f"{m0} (pair+shell)")

        lo = min([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        hi = max([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.35)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=6, ncol=2)

    scatter_gaps(ax_gsn, gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor, title="Shell gaps at observed magic N (1n): obs vs pred", xlab="gap_n obs (MeV)", ylab="gap_n pred (MeV)")
    scatter_gaps(ax_gsp, gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor, title="Shell gaps at observed magic Z (1p): obs vs pred", xlab="gap_p obs (MeV)", ylab="gap_p pred (MeV)")

    fig.suptitle("Phase 7 / Step 7.13.15.15: refreeze kN/kZ under fixed pairing baseline", fontsize=12)
    fig.text(0.01, 0.01, f"a_p={a_p:.4g} MeV, kN={kN:.4g}, kZ={kZ:.4g}", ha="left", va="bottom", fontsize=9, color="#444444")

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_refreeze.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_refreeze.csv"
    header = [
        "kind",
        "key1",
        "key2",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_pairing_only_MeV",
        "pred_pairing_shell_MeV",
        "resid_uncorrected_MeV",
        "resid_pairing_only_MeV",
        "resid_pairing_shell_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gb = gap_sn_pred_base.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sn", f"Z{Z}", f"N{N0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])
        for (N, Z0, _step), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gb = gap_sp_pred_base.get((N, Z0, 1))
            gc = gap_sp_pred_cor.get((N, Z0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sp", f"N{N}", f"Z{Z0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_refreeze_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.15",
                "inputs": {
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_13": {"path": str(metrics_71513_path), "sha256": _sha256(metrics_71513_path)},
                    "metrics_7_13_15_14": {"path": str(metrics_71514_path), "sha256": _sha256(metrics_71514_path)},
                },
                "definition": {
                    "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
                    "pairing": "B_base = B_pred + a_p*s(Z,N)/sqrt(A)  (a_p frozen from 7.13.15.14)",
                    "B_corr": "B_base + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)  (kN/kZ refrozen on gap_n/gap_p @ 50/82)",
                },
                "diag": diag,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_16(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.16 (initial): Improve the minimal pairing ansatz by allowing odd-A nuclei
    (separate neutron/proton parity contributions), then refreeze shell coefficients (kN,kZ)
    under this pairing baseline and re-evaluate 1n/1p shell-gap extrapolation.

    Baseline:
      - MODEL_MAGIC from Step 7.13.15.13 (frozen).
      - Freeze (a_n, a_p) from observed odd-even staggering (OES; 3-point formula) on B_obs,
        using a mid-shell set (exclude nuclei near observed shell closures; tol=1).
      - B_base = B_pred + a_n*(-1)^N/sqrt(A) + a_p*(-1)^Z/sqrt(A)

    Refreeze protocol (same training region as before):
      - kN: fit on gap_n at observed magic N in {50,82} (1D LS)
      - kZ: fit on gap_p at observed magic Z in {50,82} (1D LS)

    Correction:
      - B_corr = B_base + kN*ħω(A)*S_shell(N) + kZ*ħω(A)*S_shell(Z)

    Input:
      - Step 7.13.15.7 metrics (surface-term frozen by radii-only fit).
      - Step 7.13.15.13 metrics (MODEL_MAGIC).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    metrics_71513_path = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_model_metrics.json"
    if not metrics_71513_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.13 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.13\n"
            f"Expected: {metrics_71513_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    m13 = _load_json(metrics_71513_path)
    diag13 = m13.get("diag") if isinstance(m13.get("diag"), dict) else {}
    def13 = m13.get("definition") if isinstance(m13.get("definition"), dict) else {}

    model_magic_info = diag13.get("model_magic") if isinstance(diag13.get("model_magic"), dict) else def13.get("model_magic")
    if not isinstance(model_magic_info, dict):
        raise SystemExit("[fail] Step 7.13.15.13 metrics missing model_magic")
    MODEL_MAGIC = model_magic_info.get("magic_boundaries")
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        raise SystemExit("[fail] Step 7.13.15.13 metrics: invalid model_magic.magic_boundaries")

    OBS_MAGIC = diag13.get("observed_magic_boundaries") if isinstance(diag13.get("observed_magic_boundaries"), list) else def13.get("observed_magic_boundaries")
    if not isinstance(OBS_MAGIC, list) or len(OBS_MAGIC) < 2:
        OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def shell_S_model(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        for m0 in OBS_MAGIC:
            if abs(int(x) - int(m0)) <= int(tol):
                return True
        return False

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}

    max_n = 0
    max_z = 0
    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)
        max_n = max(max_n, int(N))
        max_z = max(max_z, int(Z))

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.16")

    # Freeze (a_n, a_p) from observed odd-even staggering (3-point formula), independent of the model.
    # Use a mid-shell set by excluding nuclei near observed shell closures (tol=1).
    an_list: list[float] = []
    ap_list: list[float] = []
    for (Z, N), A in a_by_zn.items():
        if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
            continue

        if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
            dn = ((-1) ** int(N)) * (
                float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])
            ) / 2.0
            if math.isfinite(dn):
                # For an ansatz ~ a_n*(-1)^N/sqrt(A), the 3-point OES gives ~ 2*a_n/sqrt(A).
                an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)

        if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
            dp = ((-1) ** int(Z)) * (
                float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])
            ) / 2.0
            if math.isfinite(dp):
                ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)

    a_n = _median(an_list)
    a_p = _median(ap_list)
    if not (math.isfinite(a_n) and math.isfinite(a_p)):
        raise SystemExit("[fail] could not estimate pairing amplitudes (a_n, a_p) from OES (3-point) in mid-shell set")

    # Pairing baseline binding energies.
    b_base: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
        term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
        b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

    # Shell correction basis terms.
    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        hw = hw_mev(int(A))
        cN[(Z, N)] = float(hw) * float(shell_S_model(int(N)))
        cZ[(Z, N)] = float(hw) * float(shell_S_model(int(Z)))

    # Helpers.
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (Z, N_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (N, Z_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    # Observables (obs).
    sn_obs = build_sep_n(b_obs, dN=1)
    s2n_obs = build_sep_n(b_obs, dN=2)
    sp_obs = build_sep_p(b_obs, dZ=1)
    s2p_obs = build_sep_p(b_obs, dZ=2)

    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_s2n_obs = build_gap_n(s2n_obs, step=2)
    gap_sp_obs = build_gap_p(sp_obs, step=1)
    gap_s2p_obs = build_gap_p(s2p_obs, step=2)

    # Predictions: uncorrected (B_pred), pairing-only (B_base).
    sn_pred_unc = build_sep_n(b_pred, dN=1)
    s2n_pred_unc = build_sep_n(b_pred, dN=2)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    s2p_pred_unc = build_sep_p(b_pred, dZ=2)

    sn_pred_base = build_sep_n(b_base, dN=1)
    s2n_pred_base = build_sep_n(b_base, dN=2)
    sp_pred_base = build_sep_p(b_base, dZ=1)
    s2p_pred_base = build_sep_p(b_base, dZ=2)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_s2n_pred_unc = build_gap_n(s2n_pred_unc, step=2)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_s2p_pred_unc = build_gap_p(s2p_pred_unc, step=2)

    gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
    gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

    # Unit-basis maps for kN/kZ fits, around the pairing baseline.
    bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
    bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}

    gap_sn_pred_N1 = build_gap_n(build_sep_n(bN1, dN=1), step=1)
    gap_sp_pred_Z1 = build_gap_p(build_sep_p(bZ1, dZ=1), step=1)

    # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
    fit_n: list[tuple[float, float]] = []  # y, x
    for (Z, N0, step), g_obs in gap_sn_obs.items():
        if int(step) != 1 or int(N0) not in {50, 82}:
            continue
        g_base = gap_sn_pred_base.get((Z, N0, 1))
        g_1 = gap_sn_pred_N1.get((Z, N0, 1))
        if g_base is None or g_1 is None:
            continue
        x = float(g_1 - g_base)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_base)
        fit_n.append((y, x))
    if not fit_n:
        raise SystemExit("[fail] no fit data for kN (gap_n at observed magic N=50/82)")
    kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

    # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
    fit_z: list[tuple[float, float]] = []  # y, x
    for (N, Z0, step), g_obs in gap_sp_obs.items():
        if int(step) != 1 or int(Z0) not in {50, 82}:
            continue
        g_base = gap_sp_pred_base.get((N, Z0, 1))
        g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
        if g_base is None or g_1 is None:
            continue
        x = float(g_1 - g_base)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_base)
        fit_z.append((y, x))
    if not fit_z:
        raise SystemExit("[fail] no fit data for kZ (gap_p at observed magic Z=50/82)")
    kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))

    ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

    # Corrected bindings.
    b_cor: dict[tuple[int, int], float] = {}
    for zn, b0 in b_base.items():
        b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    sn_pred_cor = build_sep_n(b_cor, dN=1)
    s2n_pred_cor = build_sep_n(b_cor, dN=2)
    sp_pred_cor = build_sep_p(b_cor, dZ=1)
    s2p_pred_cor = build_sep_p(b_cor, dZ=2)

    gap_sn_pred_cor = build_gap_n(sn_pred_cor, step=1)
    gap_s2n_pred_cor = build_gap_n(s2n_pred_cor, step=2)
    gap_sp_pred_cor = build_gap_p(sp_pred_cor, step=1)
    gap_s2p_pred_cor = build_gap_p(s2p_pred_cor, step=2)

    def residuals_sep(obs_map, pred_map) -> list[float]:
        return [float(pred_map[k] - v) for k, v in obs_map.items() if k in pred_map]

    def summarize_gaps_3(obs_gap, pred_u, pred_b, pred_c, *, train_set: set[int]) -> dict[str, object]:
        rows_all: list[tuple[int, float, float, float]] = []
        rows_train: list[tuple[int, float, float, float]] = []
        rows_other: list[tuple[int, float, float, float]] = []
        for key, g_obs in obs_gap.items():
            gu = pred_u.get(key)
            gb = pred_b.get(key)
            gc = pred_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            r_u = float(gu - g_obs)
            r_b = float(gb - g_obs)
            r_c = float(gc - g_obs)
            rows_all.append((m0, r_u, r_b, r_c))
            if int(m0) in train_set:
                rows_train.append((m0, r_u, r_b, r_c))
            else:
                rows_other.append((m0, r_u, r_b, r_c))

        def rms_from(items: list[tuple[int, float, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_pairing_only_MeV": rms_from(rows_all, 2),
            "rms_resid_pairing_shell_MeV": rms_from(rows_all, 3),
            "train_magic": {"n": len(rows_train), "rms_resid_uncorrected_MeV": rms_from(rows_train, 1), "rms_resid_pairing_only_MeV": rms_from(rows_train, 2), "rms_resid_pairing_shell_MeV": rms_from(rows_train, 3)},
            "other_magic": {"n": len(rows_other), "rms_resid_uncorrected_MeV": rms_from(rows_other, 1), "rms_resid_pairing_only_MeV": rms_from(rows_other, 2), "rms_resid_pairing_shell_MeV": rms_from(rows_other, 3)},
        }

    diag = {
        "domain_min_A": int(domain_min_a),
        "observed_magic_boundaries": [int(x) for x in OBS_MAGIC],
        "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
        "pairing": {
            "form": "B_base = B_pred + a_n*(-1)^N/sqrt(A) + a_p*(-1)^Z/sqrt(A)",
            "a_n_MeV": float(a_n),
            "a_p_MeV": float(a_p),
            "freeze_method": "OES 3-point on B_obs (independent of model)",
            "exclude_near_observed_magic_tol": 1,
            "n_oed_pairs_n": int(len(an_list)),
            "n_oed_pairs_p": int(len(ap_list)),
        },
        "fit": {
            "fit_target": "gap_n@N=50/82 and gap_p@Z=50/82 (separate 1D fits) under separated pairing baseline",
            "n_fit_pairs_kN": len(fit_n),
            "n_fit_pairs_kZ": len(fit_z),
            "kN": float(kN),
            "kZ": float(kZ),
            "kZ_over_kN": ratio_kZ_over_kN,
        },
        "Sn": {
            "n": len(sn_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)),
            "rms_resid_pairing_only_MeV": rms(residuals_sep(sn_obs, sn_pred_base)),
            "rms_resid_pairing_shell_MeV": rms(residuals_sep(sn_obs, sn_pred_cor)),
        },
        "Sp": {
            "n": len(sp_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sp_obs, sp_pred_unc)),
            "rms_resid_pairing_only_MeV": rms(residuals_sep(sp_obs, sp_pred_base)),
            "rms_resid_pairing_shell_MeV": rms(residuals_sep(sp_obs, sp_pred_cor)),
        },
        "gap_Sn": summarize_gaps_3(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor, train_set={50, 82}),
        "gap_Sp": summarize_gaps_3(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor, train_set={50, 82}),
        "gap_S2n": summarize_gaps_3(gap_s2n_obs, gap_s2n_pred_unc, build_gap_n(s2n_pred_base, step=2), gap_s2n_pred_cor, train_set={50, 82}),
        "gap_S2p": summarize_gaps_3(gap_s2p_obs, gap_s2p_pred_unc, build_gap_p(s2p_pred_base, step=2), gap_s2p_pred_cor, train_set={50, 82}),
    }

    # Plot.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_sp, ax_gsn, ax_gsp = axes.flat

    model_lines_n = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_n]
    model_lines_z = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_z]

    def _draw_magic_lines(ax, *, obs: list[int], model: list[int]) -> None:
        for n0 in obs[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.10)
        for n0 in model:
            ax.axvline(int(n0), color="#d62728", lw=0.6, alpha=0.10, linestyle="--")

    def scatter_sep_n(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing-only")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="pairing + shell (refrozen)")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_n)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    def scatter_sep_p(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(Z) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing-only")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="pairing + shell (refrozen)")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_z)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("Z (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    scatter_sep_n(ax_sn, sn_obs, sn_pred_unc, sn_pred_base, sn_pred_cor, title=f"S_n residuals (A>={domain_min_a})")
    scatter_sep_p(ax_sp, sp_obs, sp_pred_unc, sp_pred_base, sp_pred_cor, title=f"S_p residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_b, gap_c, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float, float]] = []  # (m0, obs, u, b, c)
        for key, g_obs in gap_obs.items():
            gu = gap_u.get(key)
            gb = gap_b.get(key)
            gc = gap_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            rows.append((m0, float(g_obs), float(gu), float(gb), float(gc)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float, float]]] = {}
        for m0, obs, gu, gb, gc in rows:
            by_magic.setdefault(int(m0), []).append((obs, gu, gb, gc))
        for i, m0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[m0]
            xs = [o for (o, _, _, _) in items]
            ys_u = [u for (_, u, _, _) in items]
            ys_b = [b for (_, _, b, _) in items]
            ys_c = [c for (_, _, _, c) in items]
            col = colors[i % len(colors)]
            ax.scatter(xs, ys_u, s=18, alpha=0.25, color=col, marker="o", label=f"{m0} (unc)")
            ax.scatter(xs, ys_b, s=26, alpha=0.65, color=col, marker="x", label=f"{m0} (pair)")
            ax.scatter(xs, ys_c, s=30, alpha=0.65, color=col, marker="+", label=f"{m0} (pair+shell)")

        lo = min([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        hi = max([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.35)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=6, ncol=2)

    scatter_gaps(ax_gsn, gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor, title="Shell gaps at observed magic N (1n): obs vs pred", xlab="gap_n obs (MeV)", ylab="gap_n pred (MeV)")
    scatter_gaps(ax_gsp, gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor, title="Shell gaps at observed magic Z (1p): obs vs pred", xlab="gap_p obs (MeV)", ylab="gap_p pred (MeV)")

    fig.suptitle("Phase 7 / Step 7.13.15.16: refreeze kN/kZ under separated n/p pairing baseline", fontsize=12)
    fig.text(0.01, 0.01, f"a_n={a_n:.4g} MeV, a_p={a_p:.4g} MeV, kN={kN:.4g}, kZ={kZ:.4g}", ha="left", va="bottom", fontsize=9, color="#444444")

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze.csv"
    header = [
        "kind",
        "key1",
        "key2",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_pairing_only_MeV",
        "pred_pairing_shell_MeV",
        "resid_uncorrected_MeV",
        "resid_pairing_only_MeV",
        "resid_pairing_shell_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gb = gap_sn_pred_base.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sn", f"Z{Z}", f"N{N0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])
        for (N, Z0, _step), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gb = gap_sp_pred_base.get((N, Z0, 1))
            gc = gap_sp_pred_cor.get((N, Z0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sp", f"N{N}", f"Z{Z0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.16",
                "inputs": {
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_13": {"path": str(metrics_71513_path), "sha256": _sha256(metrics_71513_path)},
                },
                "definition": {
                    "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
                    "pairing": "B_base = B_pred + a_n*(-1)^N/sqrt(A) + a_p*(-1)^Z/sqrt(A)  (a_n/a_p frozen from OES 3-point on B_obs)",
                    "B_corr": "B_base + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)  (kN/kZ refrozen on gap_n/gap_p @ 50/82)",
                },
                "diag": diag,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_17(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.17 (initial): Add one minimal "essential correlation" proxy (pn-collectivity)
    as an explicit DoF, freeze it from separation-energy residuals away from shell closures (no gap fit),
    and evaluate whether 1n/1p shell-gap extrapolation improves.

    Frozen baseline (from Step 7.13.15.16):
      - MODEL_MAGIC
      - pairing: a_n, a_p (OES 3-point; independent of the model)
      - shell: kN, kZ (refrozen on gap_n/gap_p @ N/Z=50/82 under the pairing baseline)

    New DoF (fit away from closures):
      - pn-collectivity proxy:
          B_corr = B_base + kNZ * ħω(A) * q(N) * q(Z)
        where q=p(g-p)/g^2 in [0,1/4] is an open-shell indicator based on fractional occupancy, and
        B_base includes pairing + (kN,kZ) shell correction. kNZ is frozen by LS on Sn/Sp residuals
        using nuclei not near observed magic numbers (tol=1). This avoids fitting shell gaps directly.

    Input:
      - Step 7.13.15.7 metrics (rows; B_obs, B_pred_mean).
      - Step 7.13.15.16 metrics (frozen a_n/a_p and kN/kZ).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    metrics_71516_path = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze_metrics.json"
    if not metrics_71516_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.16 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.16\n"
            f"Expected: {metrics_71516_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    m16 = _load_json(metrics_71516_path)
    diag16 = m16.get("diag") if isinstance(m16.get("diag"), dict) else {}
    def16 = m16.get("definition") if isinstance(m16.get("definition"), dict) else {}

    MODEL_MAGIC = def16.get("model_magic_boundaries")
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        MODEL_MAGIC = diag16.get("model_magic_boundaries")
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        raise SystemExit("[fail] Step 7.13.15.16 metrics missing model_magic_boundaries")

    OBS_MAGIC = diag16.get("observed_magic_boundaries")
    if not isinstance(OBS_MAGIC, list) or len(OBS_MAGIC) < 2:
        OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]

    fit16 = diag16.get("fit") if isinstance(diag16.get("fit"), dict) else {}
    pairing16 = diag16.get("pairing") if isinstance(diag16.get("pairing"), dict) else {}

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    a_n = fnum(pairing16.get("a_n_MeV"), ctx="7.13.15.16 diag.pairing.a_n_MeV")
    a_p = fnum(pairing16.get("a_p_MeV"), ctx="7.13.15.16 diag.pairing.a_p_MeV")
    kN = fnum(fit16.get("kN"), ctx="7.13.15.16 diag.fit.kN")
    kZ = fnum(fit16.get("kZ"), ctx="7.13.15.16 diag.fit.kZ")

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def shell_S_model(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        for m0 in OBS_MAGIC:
            if abs(int(x) - int(m0)) <= int(tol):
                return True
        return False

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}

    max_n = 0
    max_z = 0
    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)
        max_n = max(max_n, int(N))
        max_z = max(max_z, int(Z))

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.17")

    # Pairing baseline binding energies (frozen a_n/a_p).
    b_pair: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
        term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
        b_pair[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

    # Shell correction basis terms (frozen from 7.13.15.16) and a minimal collectivity proxy.
    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}

    def shell_open_q(x: int) -> float:
        """
        Open-shell indicator q in [0, 1/4], based on the fractional occupancy f=p/g:
          q = f*(1-f) = p*(g-p)/g^2
        This intentionally removes the explicit shell-degeneracy scaling (g) from S_shell,
        so a pn-collectivity proxy does not explode with increasing g.
        """
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (g - p) / float(g * g))

    x_coll: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        hw = hw_mev(int(A))
        sN = float(shell_S_model(int(N)))
        sZ = float(shell_S_model(int(Z)))
        cN[(Z, N)] = float(hw) * float(sN)
        cZ[(Z, N)] = float(hw) * float(sZ)
        qN = float(shell_open_q(int(N)))
        qZ = float(shell_open_q(int(Z)))
        x_coll[(Z, N)] = float(hw) * float(qN) * float(qZ)

    # Frozen pairing+shell baseline (kN/kZ frozen from 7.13.15.16).
    b_base: dict[tuple[int, int], float] = {}
    for zn, b0 in b_pair.items():
        b_base[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    # Freeze kNZ from separation-energy residuals (Sn/Sp) on a mid-shell training set (avoid closures).
    # This avoids absorbing the large global B residual scale (B/A is not calibrated here), while still
    # being independent from shell-gap targets.
    fit_pairs: list[tuple[float, float]] = []  # y, x where y=(obs-base) and x=(x_parent-x_child)
    n_fit_sn = 0
    n_fit_sp = 0
    for (Z, N), _A in a_by_zn.items():
        child = (Z, int(N) - 1)
        if child not in a_by_zn:
            continue
        if near_observed_magic(int(N), tol=1) or near_observed_magic(int(N) - 1, tol=1) or near_observed_magic(int(Z), tol=1):
            continue
        x = float(x_coll[(Z, N)] - x_coll[child])
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        sn_obs_i = float(b_obs[(Z, N)] - b_obs[child])
        sn_base_i = float(b_base[(Z, N)] - b_base[child])
        y = float(sn_obs_i - sn_base_i)
        if not math.isfinite(y):
            continue
        fit_pairs.append((y, x))
        n_fit_sn += 1

    for (Z, N), _A in a_by_zn.items():
        child = (int(Z) - 1, N)
        if child not in a_by_zn:
            continue
        if near_observed_magic(int(Z), tol=1) or near_observed_magic(int(Z) - 1, tol=1) or near_observed_magic(int(N), tol=1):
            continue
        x = float(x_coll[(Z, N)] - x_coll[child])
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        sp_obs_i = float(b_obs[(Z, N)] - b_obs[child])
        sp_base_i = float(b_base[(Z, N)] - b_base[child])
        y = float(sp_obs_i - sp_base_i)
        if not math.isfinite(y):
            continue
        fit_pairs.append((y, x))
        n_fit_sp += 1

    if not fit_pairs:
        raise SystemExit("[fail] no fit data for kNZ (mid-shell Sn/Sp residuals; excluded near observed magic)")
    kNZ = float(sum(y * x for y, x in fit_pairs) / sum(x * x for _y, x in fit_pairs))

    # Corrected bindings.
    b_cor: dict[tuple[int, int], float] = {}
    for zn, b0 in b_base.items():
        b_cor[zn] = float(b0) + float(kNZ) * float(x_coll[zn])

    # Helpers for separation energies and gaps.
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (Z, N_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        # keyed by (N, Z_magic, step)
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    # Observables (obs).
    sn_obs = build_sep_n(b_obs, dN=1)
    s2n_obs = build_sep_n(b_obs, dN=2)
    sp_obs = build_sep_p(b_obs, dZ=1)
    s2p_obs = build_sep_p(b_obs, dZ=2)

    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_s2n_obs = build_gap_n(s2n_obs, step=2)
    gap_sp_obs = build_gap_p(sp_obs, step=1)
    gap_s2p_obs = build_gap_p(s2p_obs, step=2)

    # Predictions: uncorrected (B_pred), frozen baseline (B_base), corrected (B_cor).
    sn_pred_unc = build_sep_n(b_pred, dN=1)
    s2n_pred_unc = build_sep_n(b_pred, dN=2)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    s2p_pred_unc = build_sep_p(b_pred, dZ=2)

    sn_pred_base = build_sep_n(b_base, dN=1)
    s2n_pred_base = build_sep_n(b_base, dN=2)
    sp_pred_base = build_sep_p(b_base, dZ=1)
    s2p_pred_base = build_sep_p(b_base, dZ=2)

    sn_pred_cor = build_sep_n(b_cor, dN=1)
    s2n_pred_cor = build_sep_n(b_cor, dN=2)
    sp_pred_cor = build_sep_p(b_cor, dZ=1)
    s2p_pred_cor = build_sep_p(b_cor, dZ=2)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_s2n_pred_unc = build_gap_n(s2n_pred_unc, step=2)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_s2p_pred_unc = build_gap_p(s2p_pred_unc, step=2)

    gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
    gap_s2n_pred_base = build_gap_n(s2n_pred_base, step=2)
    gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)
    gap_s2p_pred_base = build_gap_p(s2p_pred_base, step=2)

    gap_sn_pred_cor = build_gap_n(sn_pred_cor, step=1)
    gap_s2n_pred_cor = build_gap_n(s2n_pred_cor, step=2)
    gap_sp_pred_cor = build_gap_p(sp_pred_cor, step=1)
    gap_s2p_pred_cor = build_gap_p(s2p_pred_cor, step=2)

    def residuals_sep(obs_map, pred_map) -> list[float]:
        return [float(pred_map[k] - v) for k, v in obs_map.items() if k in pred_map]

    def summarize_gaps_3(obs_gap, pred_u, pred_b, pred_c, *, train_set: set[int]) -> dict[str, object]:
        rows_all: list[tuple[int, float, float, float]] = []
        rows_train: list[tuple[int, float, float, float]] = []
        rows_other: list[tuple[int, float, float, float]] = []
        for key, g_obs in obs_gap.items():
            gu = pred_u.get(key)
            gb = pred_b.get(key)
            gc = pred_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            r_u = float(gu - g_obs)
            r_b = float(gb - g_obs)
            r_c = float(gc - g_obs)
            rows_all.append((m0, r_u, r_b, r_c))
            if int(m0) in train_set:
                rows_train.append((m0, r_u, r_b, r_c))
            else:
                rows_other.append((m0, r_u, r_b, r_c))

        def rms_from(items: list[tuple[int, float, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_baseline_MeV": rms_from(rows_all, 2),
            "rms_resid_collective_MeV": rms_from(rows_all, 3),
            "train_magic": {
                "n": len(rows_train),
                "rms_resid_uncorrected_MeV": rms_from(rows_train, 1),
                "rms_resid_baseline_MeV": rms_from(rows_train, 2),
                "rms_resid_collective_MeV": rms_from(rows_train, 3),
            },
            "other_magic": {
                "n": len(rows_other),
                "rms_resid_uncorrected_MeV": rms_from(rows_other, 1),
                "rms_resid_baseline_MeV": rms_from(rows_other, 2),
                "rms_resid_collective_MeV": rms_from(rows_other, 3),
            },
        }

    diag = {
        "domain_min_A": int(domain_min_a),
        "observed_magic_boundaries": [int(x) for x in OBS_MAGIC],
        "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
        "frozen_from_step_7_13_15_16": {
            "path": str(metrics_71516_path),
            "sha256": _sha256(metrics_71516_path),
            "a_n_MeV": float(a_n),
            "a_p_MeV": float(a_p),
            "kN": float(kN),
            "kZ": float(kZ),
        },
        "collective_pn": {
            "form": "B_corr = B_base + kNZ*hw*q(N)*q(Z),  q=p(g-p)/g^2 in [0,1/4]",
            "fit_target": "Sn/Sp residuals (mid-shell; excluded near observed magic; tol=1)",
            "n_fit_pairs": int(len(fit_pairs)),
            "n_fit_pairs_Sn": int(n_fit_sn),
            "n_fit_pairs_Sp": int(n_fit_sp),
            "kNZ": float(kNZ),
        },
        "Sn": {
            "n": len(sn_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)),
            "rms_resid_baseline_MeV": rms(residuals_sep(sn_obs, sn_pred_base)),
            "rms_resid_collective_MeV": rms(residuals_sep(sn_obs, sn_pred_cor)),
        },
        "Sp": {
            "n": len(sp_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sp_obs, sp_pred_unc)),
            "rms_resid_baseline_MeV": rms(residuals_sep(sp_obs, sp_pred_base)),
            "rms_resid_collective_MeV": rms(residuals_sep(sp_obs, sp_pred_cor)),
        },
        "gap_Sn": summarize_gaps_3(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor, train_set={50, 82}),
        "gap_Sp": summarize_gaps_3(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor, train_set={50, 82}),
        "gap_S2n": summarize_gaps_3(gap_s2n_obs, gap_s2n_pred_unc, gap_s2n_pred_base, gap_s2n_pred_cor, train_set={50, 82}),
        "gap_S2p": summarize_gaps_3(gap_s2p_obs, gap_s2p_pred_unc, gap_s2p_pred_base, gap_s2p_pred_cor, train_set={50, 82}),
    }

    # Plot.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_sp, ax_gsn, ax_gsp = axes.flat

    model_lines_n = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_n]
    model_lines_z = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_z]

    def _draw_magic_lines(ax, *, obs: list[int], model: list[int]) -> None:
        for n0 in obs[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.10)
        for n0 in model:
            ax.axvline(int(n0), color="#d62728", lw=0.6, alpha=0.10, linestyle="--")

    def scatter_sep_n(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing+shell (frozen)")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="baseline + pn-collective")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_n)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    def scatter_sep_p(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(Z) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing+shell (frozen)")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="baseline + pn-collective")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_z)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("Z (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    scatter_sep_n(ax_sn, sn_obs, sn_pred_unc, sn_pred_base, sn_pred_cor, title=f"S_n residuals (A>={domain_min_a})")
    scatter_sep_p(ax_sp, sp_obs, sp_pred_unc, sp_pred_base, sp_pred_cor, title=f"S_p residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_b, gap_c, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float, float]] = []  # (m0, obs, u, b, c)
        for key, g_obs in gap_obs.items():
            gu = gap_u.get(key)
            gb = gap_b.get(key)
            gc = gap_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            rows.append((m0, float(g_obs), float(gu), float(gb), float(gc)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float, float]]] = {}
        for m0, obs, gu, gb, gc in rows:
            by_magic.setdefault(int(m0), []).append((obs, gu, gb, gc))
        for i, m0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[m0]
            xs = [o for (o, _, _, _) in items]
            ys_u = [u for (_, u, _, _) in items]
            ys_b = [b for (_, _, b, _) in items]
            ys_c = [c for (_, _, _, c) in items]
            col = colors[i % len(colors)]
            ax.scatter(xs, ys_u, s=18, alpha=0.25, color=col, marker="o", label=f"{m0} (unc)")
            ax.scatter(xs, ys_b, s=26, alpha=0.65, color=col, marker="x", label=f"{m0} (base)")
            ax.scatter(xs, ys_c, s=30, alpha=0.65, color=col, marker="+", label=f"{m0} (coll)")

        lo = min([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        hi = max([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.35)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=6, ncol=2)

    scatter_gaps(
        ax_gsn,
        gap_sn_obs,
        gap_sn_pred_unc,
        gap_sn_pred_base,
        gap_sn_pred_cor,
        title="Shell gaps at observed magic N (1n): obs vs pred",
        xlab="gap_n obs (MeV)",
        ylab="gap_n pred (MeV)",
    )
    scatter_gaps(
        ax_gsp,
        gap_sp_obs,
        gap_sp_pred_unc,
        gap_sp_pred_base,
        gap_sp_pred_cor,
        title="Shell gaps at observed magic Z (1p): obs vs pred",
        xlab="gap_p obs (MeV)",
        ylab="gap_p pred (MeV)",
    )

    fig.suptitle("Phase 7 / Step 7.13.15.17: minimal pn-collective proxy under frozen pairing+shell baseline", fontsize=12)
    fig.text(0.01, 0.01, f"a_n={a_n:.4g}, a_p={a_p:.4g}, kN={kN:.4g}, kZ={kZ:.4g}, kNZ={kNZ:.4g}", ha="left", va="bottom", fontsize=9, color="#444444")

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_pn.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_pn.csv"
    header = [
        "kind",
        "key1",
        "key2",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_baseline_MeV",
        "pred_collective_MeV",
        "resid_uncorrected_MeV",
        "resid_baseline_MeV",
        "resid_collective_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gb = gap_sn_pred_base.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sn", f"Z{Z}", f"N{N0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])
        for (N, Z0, _step), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gb = gap_sp_pred_base.get((N, Z0, 1))
            gc = gap_sp_pred_cor.get((N, Z0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sp", f"N{N}", f"Z{Z0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_pn_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.17",
                "inputs": {
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_16": {"path": str(metrics_71516_path), "sha256": _sha256(metrics_71516_path)},
                },
                "definition": {
                    "pairing": "B_pair = B_pred + a_n*(-1)^N/sqrt(A) + a_p*(-1)^Z/sqrt(A)  (a_n/a_p frozen from 7.13.15.16)",
                    "baseline": "B_base = B_pair + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)  (kN/kZ frozen from 7.13.15.16)",
                    "collective_pn": "B_corr = B_base + kNZ*hw*q(N)*q(Z)  (q=p(g-p)/g^2; kNZ fit on mid-shell Sn/Sp residuals; no gap fit)",
                },
                "diag": diag,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_18(*, out_dir: Path, domain_min_a: int) -> None:
    """
    Step 7.13.15.18 (initial): Extend the correlation proxy with the minimal identifiability-preserving
    increment (2 DoF): add separate open-shell terms for neutrons and protons, freeze them from mid-shell
    Sn and Sp residuals separately (no shell-gap fit), then test whether both gap_n and gap_p improve in
    other-magic extrapolation.

    Frozen baseline (from Step 7.13.15.16):
      - MODEL_MAGIC
      - pairing: a_n, a_p (OES 3-point; independent of the model)
      - shell: kN, kZ (refrozen on gap_n/gap_p @ N/Z=50/82 under the pairing baseline)

    New DoF (fit away from closures; identifiability split):
      - q(x)=p(g-p)/g^2 in [0,1/4] as an open-shell indicator from MODEL_MAGIC occupancy fraction.
      - B_corr = B_base + kqN*ħω(A)*q(N) + kqZ*ħω(A)*q(Z)
      - Freeze kqN from mid-shell Sn residuals only; freeze kqZ from mid-shell Sp residuals only.

    Input:
      - Step 7.13.15.7 metrics (rows; B_obs, B_pred_mean).
      - Step 7.13.15.16 metrics (frozen a_n/a_p and kN/kZ).
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")

    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )

    metrics_71516_path = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze_metrics.json"
    if not metrics_71516_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.16 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.16\n"
            f"Expected: {metrics_71516_path}"
        )

    m = _load_json(metrics_7157_path)
    rows_in = m.get("rows")
    if not isinstance(rows_in, list) or not rows_in:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: rows missing/empty: {metrics_7157_path}")

    m16 = _load_json(metrics_71516_path)
    diag16 = m16.get("diag") if isinstance(m16.get("diag"), dict) else {}
    def16 = m16.get("definition") if isinstance(m16.get("definition"), dict) else {}

    MODEL_MAGIC = def16.get("model_magic_boundaries")
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        MODEL_MAGIC = diag16.get("model_magic_boundaries")
    if not isinstance(MODEL_MAGIC, list) or len(MODEL_MAGIC) < 2:
        raise SystemExit("[fail] Step 7.13.15.16 metrics missing model_magic_boundaries")

    OBS_MAGIC = diag16.get("observed_magic_boundaries")
    if not isinstance(OBS_MAGIC, list) or len(OBS_MAGIC) < 2:
        OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]

    fit16 = diag16.get("fit") if isinstance(diag16.get("fit"), dict) else {}
    pairing16 = diag16.get("pairing") if isinstance(diag16.get("pairing"), dict) else {}

    def fnum(x: object, *, ctx: str) -> float:
        if not isinstance(x, (int, float)) or not math.isfinite(float(x)):
            raise SystemExit(f"[fail] missing/invalid numeric value: {ctx}")
        return float(x)

    a_n = fnum(pairing16.get("a_n_MeV"), ctx="7.13.15.16 diag.pairing.a_n_MeV")
    a_p = fnum(pairing16.get("a_p_MeV"), ctx="7.13.15.16 diag.pairing.a_p_MeV")
    kN = fnum(fit16.get("kN"), ctx="7.13.15.16 diag.fit.kN")
    kZ = fnum(fit16.get("kZ"), ctx="7.13.15.16 diag.fit.kZ")

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def shell_S_model(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    def shell_open_q(x: int) -> float:
        # Open-shell indicator q=f(1-f) in [0, 1/4], with f=p/g.
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (g - p) / float(g * g))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        for m0 in OBS_MAGIC:
            if abs(int(x) - int(m0)) <= int(tol):
                return True
        return False

    # Build a single (Z,N) map. Prefer published radii if duplicates exist.
    nuc_by_zn: dict[tuple[int, int], dict[str, object]] = {}
    for r in rows_in:
        if not isinstance(r, dict):
            continue
        try:
            Z = int(r.get("Z", -999))
            N = int(r.get("N", -999))
            A = int(r.get("A", -999))
        except Exception:
            continue
        if Z < 0 or N < 0 or A < 1:
            continue
        key = (Z, N)
        if key in nuc_by_zn:
            prev_used = str(nuc_by_zn[key].get("radii_used", "")).strip().lower()
            curr_used = str(r.get("radii_used", "")).strip().lower()
            if prev_used == "published":
                continue
            if curr_used == "published":
                nuc_by_zn[key] = r
            continue
        nuc_by_zn[key] = r

    if not nuc_by_zn:
        raise SystemExit("[fail] no nuclei rows found after parsing Step 7.13.15.7 metrics")

    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}

    max_n = 0
    max_z = 0
    for (Z, N), r in nuc_by_zn.items():
        A = int(r.get("A", 0))
        if A < int(domain_min_a):
            continue
        a_by_zn[(Z, N)] = int(A)
        ba_obs = fnum(r.get("B_over_A_obs_MeV"), ctx=f"B/A obs Z{Z} N{N}")
        ba_pred = fnum(r.get("B_over_A_pred_mean_MeV"), ctx=f"B/A pred_mean Z{Z} N{N}")
        b_obs[(Z, N)] = float(A) * float(ba_obs)
        b_pred[(Z, N)] = float(A) * float(ba_pred)
        max_n = max(max_n, int(N))
        max_z = max(max_z, int(Z))

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found for Step 7.13.15.18")

    # Pairing baseline binding energies (frozen a_n/a_p).
    b_pair: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
        term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
        b_pair[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

    # Shell correction basis terms (frozen kN/kZ from 7.13.15.16) and q-bases.
    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}
    xqN: dict[tuple[int, int], float] = {}
    xqZ: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        hw = hw_mev(int(A))
        cN[(Z, N)] = float(hw) * float(shell_S_model(int(N)))
        cZ[(Z, N)] = float(hw) * float(shell_S_model(int(Z)))
        xqN[(Z, N)] = float(hw) * float(shell_open_q(int(N)))
        xqZ[(Z, N)] = float(hw) * float(shell_open_q(int(Z)))

    # Frozen pairing+shell baseline (kN/kZ).
    b_base: dict[tuple[int, int], float] = {}
    for zn, b0 in b_pair.items():
        b_base[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    # Freeze kqN from mid-shell Sn residuals only.
    fit_n: list[tuple[float, float]] = []  # y, x
    for (Z, N), _A in a_by_zn.items():
        child = (Z, int(N) - 1)
        if child not in a_by_zn:
            continue
        if near_observed_magic(int(Z), tol=1):
            continue
        if near_observed_magic(int(N), tol=1) or near_observed_magic(int(N) - 1, tol=1):
            continue
        x = float(xqN[(Z, N)] - xqN[child])
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        sn_obs = float(b_obs[(Z, N)] - b_obs[child])
        sn_base = float(b_base[(Z, N)] - b_base[child])
        y = float(sn_obs - sn_base)
        if not math.isfinite(y):
            continue
        fit_n.append((y, x))
    if not fit_n:
        raise SystemExit("[fail] no fit data for kqN (mid-shell Sn residuals; excluded near observed magic)")
    kqN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

    # Freeze kqZ from mid-shell Sp residuals only.
    fit_z: list[tuple[float, float]] = []  # y, x
    for (Z, N), _A in a_by_zn.items():
        child = (int(Z) - 1, N)
        if child not in a_by_zn:
            continue
        if near_observed_magic(int(N), tol=1):
            continue
        if near_observed_magic(int(Z), tol=1) or near_observed_magic(int(Z) - 1, tol=1):
            continue
        x = float(xqZ[(Z, N)] - xqZ[child])
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        sp_obs = float(b_obs[(Z, N)] - b_obs[child])
        sp_base = float(b_base[(Z, N)] - b_base[child])
        y = float(sp_obs - sp_base)
        if not math.isfinite(y):
            continue
        fit_z.append((y, x))
    if not fit_z:
        raise SystemExit("[fail] no fit data for kqZ (mid-shell Sp residuals; excluded near observed magic)")
    kqZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))

    # Corrected bindings.
    b_cor: dict[tuple[int, int], float] = {}
    for (Z, N), _A in a_by_zn.items():
        b_cor[(Z, N)] = float(b_base[(Z, N)]) + float(kqN) * float(xqN[(Z, N)]) + float(kqZ) * float(xqZ[(Z, N)])

    # Helpers for separation energies and gaps.
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    # Observables (obs).
    sn_obs = build_sep_n(b_obs, dN=1)
    s2n_obs = build_sep_n(b_obs, dN=2)
    sp_obs = build_sep_p(b_obs, dZ=1)
    s2p_obs = build_sep_p(b_obs, dZ=2)

    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_s2n_obs = build_gap_n(s2n_obs, step=2)
    gap_sp_obs = build_gap_p(sp_obs, step=1)
    gap_s2p_obs = build_gap_p(s2p_obs, step=2)

    # Predictions: uncorrected (B_pred), frozen baseline (B_base), corrected (B_cor).
    sn_pred_unc = build_sep_n(b_pred, dN=1)
    s2n_pred_unc = build_sep_n(b_pred, dN=2)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    s2p_pred_unc = build_sep_p(b_pred, dZ=2)

    sn_pred_base = build_sep_n(b_base, dN=1)
    s2n_pred_base = build_sep_n(b_base, dN=2)
    sp_pred_base = build_sep_p(b_base, dZ=1)
    s2p_pred_base = build_sep_p(b_base, dZ=2)

    sn_pred_cor = build_sep_n(b_cor, dN=1)
    s2n_pred_cor = build_sep_n(b_cor, dN=2)
    sp_pred_cor = build_sep_p(b_cor, dZ=1)
    s2p_pred_cor = build_sep_p(b_cor, dZ=2)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_s2n_pred_unc = build_gap_n(s2n_pred_unc, step=2)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_s2p_pred_unc = build_gap_p(s2p_pred_unc, step=2)

    gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
    gap_s2n_pred_base = build_gap_n(s2n_pred_base, step=2)
    gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)
    gap_s2p_pred_base = build_gap_p(s2p_pred_base, step=2)

    gap_sn_pred_cor = build_gap_n(sn_pred_cor, step=1)
    gap_s2n_pred_cor = build_gap_n(s2n_pred_cor, step=2)
    gap_sp_pred_cor = build_gap_p(sp_pred_cor, step=1)
    gap_s2p_pred_cor = build_gap_p(s2p_pred_cor, step=2)

    def residuals_sep(obs_map, pred_map) -> list[float]:
        return [float(pred_map[k] - v) for k, v in obs_map.items() if k in pred_map]

    def summarize_gaps_3(obs_gap, pred_u, pred_b, pred_c, *, train_set: set[int]) -> dict[str, object]:
        rows_all: list[tuple[int, float, float, float]] = []
        rows_train: list[tuple[int, float, float, float]] = []
        rows_other: list[tuple[int, float, float, float]] = []
        for key, g_obs in obs_gap.items():
            gu = pred_u.get(key)
            gb = pred_b.get(key)
            gc = pred_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            r_u = float(gu - g_obs)
            r_b = float(gb - g_obs)
            r_c = float(gc - g_obs)
            rows_all.append((m0, r_u, r_b, r_c))
            if int(m0) in train_set:
                rows_train.append((m0, r_u, r_b, r_c))
            else:
                rows_other.append((m0, r_u, r_b, r_c))

        def rms_from(items: list[tuple[int, float, float, float]], idx: int) -> float:
            return rms([float(x[idx]) for x in items]) if items else float("nan")

        return {
            "n": len(rows_all),
            "rms_resid_uncorrected_MeV": rms_from(rows_all, 1),
            "rms_resid_baseline_MeV": rms_from(rows_all, 2),
            "rms_resid_collective_MeV": rms_from(rows_all, 3),
            "train_magic": {
                "n": len(rows_train),
                "rms_resid_uncorrected_MeV": rms_from(rows_train, 1),
                "rms_resid_baseline_MeV": rms_from(rows_train, 2),
                "rms_resid_collective_MeV": rms_from(rows_train, 3),
            },
            "other_magic": {
                "n": len(rows_other),
                "rms_resid_uncorrected_MeV": rms_from(rows_other, 1),
                "rms_resid_baseline_MeV": rms_from(rows_other, 2),
                "rms_resid_collective_MeV": rms_from(rows_other, 3),
            },
        }

    diag = {
        "domain_min_A": int(domain_min_a),
        "observed_magic_boundaries": [int(x) for x in OBS_MAGIC],
        "model_magic_boundaries": [int(x) for x in MODEL_MAGIC],
        "frozen_from_step_7_13_15_16": {
            "path": str(metrics_71516_path),
            "sha256": _sha256(metrics_71516_path),
            "a_n_MeV": float(a_n),
            "a_p_MeV": float(a_p),
            "kN": float(kN),
            "kZ": float(kZ),
        },
        "collective_q": {
            "form": "B_corr = B_base + kqN*hw*q(N) + kqZ*hw*q(Z),  q=p(g-p)/g^2 in [0,1/4]",
            "fit_target": "kqN: Sn residuals (mid-shell), kqZ: Sp residuals (mid-shell); excluded near observed magic; tol=1",
            "n_fit_pairs_kqN": int(len(fit_n)),
            "n_fit_pairs_kqZ": int(len(fit_z)),
            "kqN": float(kqN),
            "kqZ": float(kqZ),
        },
        "Sn": {
            "n": len(sn_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sn_obs, sn_pred_unc)),
            "rms_resid_baseline_MeV": rms(residuals_sep(sn_obs, sn_pred_base)),
            "rms_resid_collective_MeV": rms(residuals_sep(sn_obs, sn_pred_cor)),
        },
        "Sp": {
            "n": len(sp_obs),
            "rms_resid_uncorrected_MeV": rms(residuals_sep(sp_obs, sp_pred_unc)),
            "rms_resid_baseline_MeV": rms(residuals_sep(sp_obs, sp_pred_base)),
            "rms_resid_collective_MeV": rms(residuals_sep(sp_obs, sp_pred_cor)),
        },
        "gap_Sn": summarize_gaps_3(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor, train_set={50, 82}),
        "gap_Sp": summarize_gaps_3(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor, train_set={50, 82}),
        "gap_S2n": summarize_gaps_3(gap_s2n_obs, gap_s2n_pred_unc, gap_s2n_pred_base, gap_s2n_pred_cor, train_set={50, 82}),
        "gap_S2p": summarize_gaps_3(gap_s2p_obs, gap_s2p_pred_unc, gap_s2p_pred_base, gap_s2p_pred_cor, train_set={50, 82}),
    }

    # Plot.
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_sn, ax_sp, ax_gsn, ax_gsp = axes.flat

    model_lines_n = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_n]
    model_lines_z = [int(x) for x in MODEL_MAGIC[1:] if int(x) <= max_z]

    def _draw_magic_lines(ax, *, obs: list[int], model: list[int]) -> None:
        for n0 in obs[1:]:
            ax.axvline(int(n0), color="k", lw=0.6, alpha=0.10)
        for n0 in model:
            ax.axvline(int(n0), color="#d62728", lw=0.6, alpha=0.10, linestyle="--")

    def scatter_sep_n(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(N) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing+shell (frozen)")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="baseline + q(N/Z)")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_n)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("N (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    def scatter_sep_p(ax, obs_map, pred_u, pred_b, pred_c, *, title: str) -> None:
        xs = [int(Z) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_u = [float(pred_u[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_b = [float(pred_b[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ys_c = [float(pred_c[(Z, N)] - obs_map[(Z, N)]) for (Z, N) in obs_map.keys() if (Z, N) in pred_u and (Z, N) in pred_b and (Z, N) in pred_c]
        ax.scatter(xs, ys_u, s=6, alpha=0.10, c="#7f7f7f", label="uncorrected")
        ax.scatter(xs, ys_b, s=6, alpha=0.16, c="#ff7f0e", label="pairing+shell (frozen)")
        ax.scatter(xs, ys_c, s=6, alpha=0.18, c="#1f77b4", label="baseline + q(N/Z)")
        _draw_magic_lines(ax, obs=[int(x) for x in OBS_MAGIC], model=model_lines_z)
        ax.axhline(0.0, color="k", lw=0.8, alpha=0.25)
        ax.set_xlabel("Z (parent)")
        ax.set_ylabel("pred - obs (MeV)")
        ax.set_title(title)
        ax.legend(loc="upper right", fontsize=7, ncol=1)

    scatter_sep_n(ax_sn, sn_obs, sn_pred_unc, sn_pred_base, sn_pred_cor, title=f"S_n residuals (A>={domain_min_a})")
    scatter_sep_p(ax_sp, sp_obs, sp_pred_unc, sp_pred_base, sp_pred_cor, title=f"S_p residuals (A>={domain_min_a})")

    def scatter_gaps(ax, gap_obs, gap_u, gap_b, gap_c, *, title: str, xlab: str, ylab: str) -> None:
        rows: list[tuple[int, float, float, float, float]] = []  # (m0, obs, u, b, c)
        for key, g_obs in gap_obs.items():
            gu = gap_u.get(key)
            gb = gap_b.get(key)
            gc = gap_c.get(key)
            if gu is None or gb is None or gc is None:
                continue
            m0 = int(key[1])
            rows.append((m0, float(g_obs), float(gu), float(gb), float(gc)))
        if not rows:
            ax.text(0.5, 0.5, "no gap data", ha="center", va="center")
            ax.set_title(title)
            return

        colors = plt.cm.tab10.colors
        by_magic: dict[int, list[tuple[float, float, float, float]]] = {}
        for m0, obs, gu, gb, gc in rows:
            by_magic.setdefault(int(m0), []).append((obs, gu, gb, gc))
        for i, m0 in enumerate(sorted(by_magic.keys())):
            items = by_magic[m0]
            xs = [o for (o, _, _, _) in items]
            ys_u = [u for (_, u, _, _) in items]
            ys_b = [b for (_, _, b, _) in items]
            ys_c = [c for (_, _, _, c) in items]
            col = colors[i % len(colors)]
            ax.scatter(xs, ys_u, s=18, alpha=0.25, color=col, marker="o", label=f"{m0} (unc)")
            ax.scatter(xs, ys_b, s=26, alpha=0.65, color=col, marker="x", label=f"{m0} (base)")
            ax.scatter(xs, ys_c, s=30, alpha=0.65, color=col, marker="+", label=f"{m0} (q)")

        lo = min([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        hi = max([o for _, o, _, _, _ in rows] + [u for _, _, u, _, _ in rows] + [b for _, _, _, b, _ in rows] + [c for _, _, _, _, c in rows])
        pad = 0.1 * (hi - lo) if math.isfinite(lo) and math.isfinite(hi) and hi > lo else 1.0
        ax.plot([lo - pad, hi + pad], [lo - pad, hi + pad], "k--", lw=0.8, alpha=0.35)
        ax.set_xlabel(xlab)
        ax.set_ylabel(ylab)
        ax.set_title(title)
        ax.legend(loc="best", fontsize=6, ncol=2)

    scatter_gaps(
        ax_gsn,
        gap_sn_obs,
        gap_sn_pred_unc,
        gap_sn_pred_base,
        gap_sn_pred_cor,
        title="Shell gaps at observed magic N (1n): obs vs pred",
        xlab="gap_n obs (MeV)",
        ylab="gap_n pred (MeV)",
    )
    scatter_gaps(
        ax_gsp,
        gap_sp_obs,
        gap_sp_pred_unc,
        gap_sp_pred_base,
        gap_sp_pred_cor,
        title="Shell gaps at observed magic Z (1p): obs vs pred",
        xlab="gap_p obs (MeV)",
        ylab="gap_p pred (MeV)",
    )

    fig.suptitle("Phase 7 / Step 7.13.15.18: minimal q(N)+q(Z) correlation (2DoF) under frozen pairing+shell baseline", fontsize=12)
    fig.text(0.01, 0.01, f"a_n={a_n:.4g}, a_p={a_p:.4g}, kN={kN:.4g}, kZ={kZ:.4g}, kqN={kqN:.4g}, kqZ={kqZ:.4g}", ha="left", va="bottom", fontsize=9, color="#444444")

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_q_sep.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_q_sep.csv"
    header = [
        "kind",
        "key1",
        "key2",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_baseline_MeV",
        "pred_collective_MeV",
        "resid_uncorrected_MeV",
        "resid_baseline_MeV",
        "resid_collective_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gb = gap_sn_pred_base.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sn", f"Z{Z}", f"N{N0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])
        for (N, Z0, _step), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gb = gap_sp_pred_base.get((N, Z0, 1))
            gc = gap_sp_pred_cor.get((N, Z0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(["gap_Sp", f"N{N}", f"Z{Z0}", f"{g_obs:.12g}", f"{gu:.12g}", f"{gb:.12g}", f"{gc:.12g}", f"{(gu-g_obs):.12g}", f"{(gb-g_obs):.12g}", f"{(gc-g_obs):.12g}"])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_q_sep_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.18",
                "inputs": {
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_16": {"path": str(metrics_71516_path), "sha256": _sha256(metrics_71516_path)},
                },
                "definition": {
                    "pairing": "B_pair = B_pred + a_n*(-1)^N/sqrt(A) + a_p*(-1)^Z/sqrt(A)  (a_n/a_p frozen from 7.13.15.16)",
                    "baseline": "B_base = B_pair + kN*hw*S_shell(N) + kZ*hw*S_shell(Z)  (kN/kZ frozen from 7.13.15.16)",
                    "collective_q": "B_corr = B_base + kqN*hw*q(N) + kqZ*hw*q(Z)  (q=p(g-p)/g^2; kqN fit on mid-shell Sn residuals; kqZ fit on mid-shell Sp residuals; no gap fit)",
                },
                "diag": diag,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_19(*, out_dir: Path) -> None:
    """
    Step 7.13.15.19 (initial): "no-go pack" for shell-gap extrapolation within the current model class.

    This step does not introduce a new model. It mechanically summarizes steps 7.13.15.13–.18 and fixes
    the conclusion that (mean-field + shell mapping + minimal correlations frozen independently) cannot
    achieve a simultaneous improvement of both gap_n and gap_p in the other-magic extrapolation while
    keeping train-magic performance.
    """

    steps: list[tuple[str, str, Path]] = [
        ("7.13.15.13", "shell (MODEL_MAGIC)", out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_model_metrics.json"),
        ("7.13.15.14", "+ pairing (a_p, no refreeze)", out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_model_metrics.json"),
        ("7.13.15.15", "pairing fixed -> refreeze kN/kZ", out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_refreeze_metrics.json"),
        ("7.13.15.16", "pairing sep (a_n/a_p) -> refreeze kN/kZ", out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze_metrics.json"),
        ("7.13.15.17", "+ pn-collective (1DoF)", out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_pn_metrics.json"),
        ("7.13.15.18", "+ q(N)+q(Z) (2DoF)", out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_collective_q_sep_metrics.json"),
    ]

    for step_id, _label, path in steps:
        if not path.exists():
            raise SystemExit(
                f"[fail] missing required metrics for Step {step_id}:\n"
                f"  {path}\n"
                "Re-run the corresponding step first (see doc/ROADMAP.md)."
            )

    def _as_dict(x: object) -> dict:
        return x if isinstance(x, dict) else {}

    def _pick_train_other(gap: dict) -> tuple[dict, dict]:
        train = _as_dict(gap.get("train_magic")) or _as_dict(gap.get("train_magicN")) or _as_dict(gap.get("train_magicZ"))
        other = _as_dict(gap.get("other_magic")) or _as_dict(gap.get("other_magicN")) or _as_dict(gap.get("other_magicZ"))
        return train, other

    def _pick_rms(d: dict) -> tuple[float, str]:
        # Prefer the "most corrected" variant when multiple are present.
        candidates = [
            "rms_resid_collective_MeV",
            "rms_resid_shell_pairing_MeV",
            "rms_resid_pairing_shell_MeV",
            "rms_resid_corrected_MeV",
            "rms_resid_shell_MeV",
            "rms_resid_baseline_MeV",
        ]
        for k in candidates:
            v = d.get(k)
            if isinstance(v, (int, float)) and math.isfinite(float(v)):
                return float(v), str(k)
        raise SystemExit(f"[fail] could not extract RMS from keys {candidates}; available keys={sorted(d.keys())}")

    rows: list[dict[str, object]] = []
    for step_id, label, path in steps:
        m = _load_json(path)
        diag = _as_dict(m.get("diag"))
        gap_n = _as_dict(diag.get("gap_Sn"))
        gap_p = _as_dict(diag.get("gap_Sp"))
        if not gap_n or not gap_p:
            raise SystemExit(f"[fail] missing diag.gap_Sn/gap_Sp in: {path}")

        train_n, other_n = _pick_train_other(gap_n)
        train_p, other_p = _pick_train_other(gap_p)
        if not train_n or not other_n or not train_p or not other_p:
            raise SystemExit(f"[fail] missing train/other magic splits in gap diag for: {path}")

        train_n_rms, train_n_key = _pick_rms(train_n)
        other_n_rms, other_n_key = _pick_rms(other_n)
        train_p_rms, train_p_key = _pick_rms(train_p)
        other_p_rms, other_p_key = _pick_rms(other_p)

        rows.append(
            {
                "step": str(step_id),
                "label": str(label),
                "metrics_path": str(path),
                "sha256": _sha256(path),
                "gap_n_train_rms_MeV": float(train_n_rms),
                "gap_n_other_rms_MeV": float(other_n_rms),
                "gap_p_train_rms_MeV": float(train_p_rms),
                "gap_p_other_rms_MeV": float(other_p_rms),
                "gap_n_train_key": str(train_n_key),
                "gap_n_other_key": str(other_n_key),
                "gap_p_train_key": str(train_p_key),
                "gap_p_other_key": str(other_p_key),
            }
        )

    baseline_step = "7.13.15.16"
    baseline = next((r for r in rows if r.get("step") == baseline_step), None)
    if not isinstance(baseline, dict):
        raise SystemExit(f"[fail] baseline step not found in rows: {baseline_step}")

    base_train_n = float(baseline["gap_n_train_rms_MeV"])
    base_other_n = float(baseline["gap_n_other_rms_MeV"])
    base_train_p = float(baseline["gap_p_train_rms_MeV"])
    base_other_p = float(baseline["gap_p_other_rms_MeV"])

    tol_train_abs = 0.5  # MeV; "do not break train-magic" guardrail.
    # For the "no-go pack" we require strict improvement in the extrapolation domain.
    # (Equality would allow the baseline to "pass", which is misleading here.)

    for r in rows:
        tn = float(r["gap_n_train_rms_MeV"])
        on = float(r["gap_n_other_rms_MeV"])
        tp = float(r["gap_p_train_rms_MeV"])
        op = float(r["gap_p_other_rms_MeV"])

        r["delta_gap_n_train_MeV"] = float(tn - base_train_n)
        r["delta_gap_n_other_MeV"] = float(on - base_other_n)
        r["delta_gap_p_train_MeV"] = float(tp - base_train_p)
        r["delta_gap_p_other_MeV"] = float(op - base_other_p)

        r["train_ok"] = bool((tn <= base_train_n + tol_train_abs) and (tp <= base_train_p + tol_train_abs))
        r["other_ok"] = bool((on < base_other_n) and (op < base_other_p))
        r["pass_all"] = bool(r["train_ok"] and r["other_ok"])

        r["gap_n_other_improves"] = bool(on < base_other_n)
        r["gap_p_other_improves"] = bool(op < base_other_p)

    n_pass = sum(1 for r in rows if bool(r.get("pass_all")))

    # Plot summary.
    import matplotlib.pyplot as plt

    xs = list(range(len(rows)))
    xt = [str(r["step"]).split(".")[-1] for r in rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    ax_tn, ax_on, ax_tp, ax_op = axes.flat

    def _plot(ax, ys, *, title: str, ylabel: str, base: float, tol: float | None = None) -> None:
        ax.plot(xs, ys, marker="o", lw=1.6)
        ax.axhline(base, color="k", lw=1.0, alpha=0.35, linestyle="--", label="baseline")
        if tol is not None and tol > 0:
            ax.axhline(base + tol, color="#d62728", lw=1.0, alpha=0.45, linestyle="--", label=f"baseline+{tol:g}")
        ax.set_xticks(xs, xt)
        ax.set_title(title)
        ax.set_xlabel("step suffix")
        ax.set_ylabel(ylabel)
        ax.grid(True, alpha=0.25)
        ax.legend(loc="best", fontsize=8)

    _plot(ax_tn, [float(r["gap_n_train_rms_MeV"]) for r in rows], title="gap_n train RMS", ylabel="RMS (MeV)", base=base_train_n, tol=tol_train_abs)
    _plot(ax_on, [float(r["gap_n_other_rms_MeV"]) for r in rows], title="gap_n other RMS", ylabel="RMS (MeV)", base=base_other_n, tol=None)
    _plot(ax_tp, [float(r["gap_p_train_rms_MeV"]) for r in rows], title="gap_p train RMS", ylabel="RMS (MeV)", base=base_train_p, tol=tol_train_abs)
    _plot(ax_op, [float(r["gap_p_other_rms_MeV"]) for r in rows], title="gap_p other RMS", ylabel="RMS (MeV)", base=base_other_p, tol=None)

    fig.suptitle("Phase 7 / Step 7.13.15.19: no-go pack (shell-gap extrapolation within current model class)", fontsize=12)
    fig.text(
        0.01,
        0.01,
        f"baseline={baseline_step}, tol_train={tol_train_abs:g} MeV, pass_all={n_pass}/{len(rows)}",
        ha="left",
        va="bottom",
        fontsize=9,
        color="#444444",
    )

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_no_go_pack.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_no_go_pack.csv"
    header = [
        "step",
        "label",
        "gap_n_train_rms_MeV",
        "gap_n_other_rms_MeV",
        "gap_p_train_rms_MeV",
        "gap_p_other_rms_MeV",
        "delta_gap_n_train_MeV",
        "delta_gap_n_other_MeV",
        "delta_gap_p_train_MeV",
        "delta_gap_p_other_MeV",
        "train_ok",
        "other_ok",
        "pass_all",
        "gap_n_other_improves",
        "gap_p_other_improves",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            w.writerow([r.get(k, "") for k in header])

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_no_go_pack_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.19",
                "baseline_step": baseline_step,
                "baseline": {
                    "gap_n_train_rms_MeV": base_train_n,
                    "gap_n_other_rms_MeV": base_other_n,
                    "gap_p_train_rms_MeV": base_train_p,
                    "gap_p_other_rms_MeV": base_other_p,
                },
                "criteria": {
                    "train_ok": f"train RMS <= baseline_train + {tol_train_abs:g} MeV (for both gap_n and gap_p)",
                    "other_ok": "other-magic RMS strictly improves simultaneously for gap_n and gap_p",
                },
                "diag": {"n_steps": len(rows), "n_pass_all": n_pass, "rows": rows},
                "inputs": {sid: {"path": str(p), "sha256": _sha256(p)} for (sid, _lab, p) in steps},
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_20(*, out_dir: Path) -> None:
    """
    Step 7.13.15.20 (initial): "next design pack" for the post no-go shell-gap extrapolation problem.

    This step does *not* add a new physics term yet. Instead, it decomposes the baseline shell-gap
    residuals by (magic number) and by (A-range), and records coverage limitations implied by the
    current radii-joined dataset. The goal is to define the smallest *next* extension that can be
    frozen independently and decided by extrapolation, without repeating p-hacking loops.

    Inputs:
      - Baseline CSV from Step 7.13.15.16 (pairing sep + shell refreeze).

    Outputs:
      - nuclear_a_dependence_hf_three_body_shellgap_failure_modes.png
      - nuclear_a_dependence_hf_three_body_shellgap_failure_modes.csv
      - nuclear_a_dependence_hf_three_body_shellgap_failure_modes_metrics.json
    """
    baseline_step = "7.13.15.16"
    baseline_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze.csv"
    if not baseline_csv.exists():
        raise SystemExit(
            "[fail] missing baseline CSV for Step 7.13.15.20.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.16\n"
            f"Expected: {baseline_csv}"
        )

    TRAIN_MAGIC = {50, 82}

    def _rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def _mean(vals: list[float]) -> float:
        return float(sum(vals) / len(vals)) if vals else float("nan")

    resid_key = "resid_pairing_shell_MeV"
    pred_key = "pred_pairing_shell_MeV"

    gap_rows: list[dict[str, object]] = []
    with baseline_csv.open("r", newline="", encoding="utf-8") as f:
        r = csv.DictReader(f)
        for row in r:
            if not isinstance(row, dict):
                continue
            kind = str(row.get("kind", ""))
            if kind not in {"gap_Sn", "gap_Sp"}:
                continue

            try:
                obs = float(row.get("obs_MeV", "nan"))
                pred = float(row.get(pred_key, "nan"))
                resid = float(row.get(resid_key, "nan"))
            except Exception:
                continue
            if not (math.isfinite(obs) and math.isfinite(pred) and math.isfinite(resid)):
                continue

            key1 = str(row.get("key1", ""))
            key2 = str(row.get("key2", ""))
            if not (key1 and key2 and key1[0] in {"Z", "N"} and key2[0] in {"Z", "N"}):
                continue
            try:
                if kind == "gap_Sn":
                    Z = int(key1[1:])
                    N_magic = int(key2[1:])
                    N = int(N_magic)
                    magic = int(N_magic)
                else:
                    N = int(key1[1:])
                    Z_magic = int(key2[1:])
                    Z = int(Z_magic)
                    magic = int(Z_magic)
            except Exception:
                continue
            A = int(Z + N)
            split = "train" if int(magic) in TRAIN_MAGIC else "other"

            gap_rows.append(
                {
                    "kind": kind,
                    "split": split,
                    "magic": int(magic),
                    "Z": int(Z),
                    "N": int(N),
                    "A": int(A),
                    "obs_MeV": float(obs),
                    "pred_MeV": float(pred),
                    "resid_MeV": float(resid),
                }
            )

    if not gap_rows:
        raise SystemExit(f"[fail] no gap rows parsed from baseline CSV: {baseline_csv}")

    # Summaries by magic number.
    by_magic: dict[tuple[str, str, int], list[dict[str, object]]] = {}
    for gr in gap_rows:
        k = (str(gr["kind"]), str(gr["split"]), int(gr["magic"]))
        by_magic.setdefault(k, []).append(gr)

    by_magic_rows: list[dict[str, object]] = []
    for (kind, split, magic), items in sorted(by_magic.items(), key=lambda x: (x[0][0], x[0][1], x[0][2])):
        resid_vals = [float(it["resid_MeV"]) for it in items]
        worst = max(items, key=lambda it: abs(float(it["resid_MeV"])))
        by_magic_rows.append(
            {
                "kind": str(kind),
                "split": str(split),
                "magic": int(magic),
                "count": int(len(items)),
                "rms_resid_MeV": float(_rms(resid_vals)),
                "mean_resid_MeV": float(_mean(resid_vals)),
                "max_abs_resid_MeV": float(max(abs(v) for v in resid_vals)) if resid_vals else float("nan"),
                "worst_Z": int(worst["Z"]),
                "worst_N": int(worst["N"]),
                "worst_A": int(worst["A"]),
                "worst_resid_MeV": float(worst["resid_MeV"]),
                "worst_obs_MeV": float(worst["obs_MeV"]),
                "worst_pred_MeV": float(worst["pred_MeV"]),
            }
        )

    # Summaries by A-min threshold (focused on extrapolation domain).
    a_mins = [0, 16, 40, 60, 80]
    by_a_rows: list[dict[str, object]] = []
    for kind in ["gap_Sn", "gap_Sp"]:
        for split in ["train", "other"]:
            for a_min in a_mins:
                vals = [float(gr["resid_MeV"]) for gr in gap_rows if gr["kind"] == kind and gr["split"] == split and int(gr["A"]) >= int(a_min)]
                by_a_rows.append(
                    {
                        "kind": str(kind),
                        "split": str(split),
                        "A_min": int(a_min),
                        "count": int(len(vals)),
                        "rms_resid_MeV": float(_rms(vals)),
                    }
                )

    # Worst offenders (for spec: where physics is missing).
    def _worst(kind: str, split: str, n: int) -> list[dict[str, object]]:
        xs = [gr for gr in gap_rows if gr["kind"] == kind and gr["split"] == split]
        xs_sorted = sorted(xs, key=lambda gr: abs(float(gr["resid_MeV"])), reverse=True)
        out: list[dict[str, object]] = []
        for gr in xs_sorted[:n]:
            out.append(
                {
                    "magic": int(gr["magic"]),
                    "Z": int(gr["Z"]),
                    "N": int(gr["N"]),
                    "A": int(gr["A"]),
                    "obs_MeV": float(gr["obs_MeV"]),
                    "pred_MeV": float(gr["pred_MeV"]),
                    "resid_MeV": float(gr["resid_MeV"]),
                }
            )
        return out

    worst_pack = {
        "gap_Sn_train": _worst("gap_Sn", "train", 5),
        "gap_Sn_other": _worst("gap_Sn", "other", 8),
        "gap_Sp_train": _worst("gap_Sp", "train", 5),
        "gap_Sp_other": _worst("gap_Sp", "other", 8),
    }

    # Plot: RMS by magic + RMS vs A-min + coverage counts.
    import matplotlib.pyplot as plt

    def _plot_by_magic(ax, *, kind: str, title: str) -> None:
        mags = sorted({int(r["magic"]) for r in by_magic_rows if r["kind"] == kind})
        if not mags:
            ax.text(0.5, 0.5, "no data", ha="center", va="center")
            ax.set_title(title)
            return
        xs = list(range(len(mags)))
        ys = []
        cs = []
        labels = []
        for m0 in mags:
            row = next((r for r in by_magic_rows if r["kind"] == kind and r["split"] == ("train" if m0 in TRAIN_MAGIC else "other") and int(r["magic"]) == m0), None)
            if row is None:
                ys.append(float("nan"))
                cs.append("#7f7f7f")
                labels.append(str(m0))
                continue
            ys.append(float(row["rms_resid_MeV"]))
            cs.append("#1f77b4" if m0 in TRAIN_MAGIC else "#ff7f0e")
            labels.append(str(m0))
        ax.bar(xs, ys, color=cs, alpha=0.85)
        ax.set_xticks(xs, labels)
        ax.set_xlabel("magic number")
        ax.set_ylabel("RMS(resid) (MeV)")
        ax.set_title(title)
        ax.grid(True, axis="y", alpha=0.25)
        ax.text(
            0.01,
            0.99,
            f"train={sorted(TRAIN_MAGIC)}",
            transform=ax.transAxes,
            ha="left",
            va="top",
            fontsize=9,
            color="#444444",
        )

    def _plot_rms_vs_amin(ax) -> None:
        xs = a_mins
        for kind, col in [("gap_Sn", "#1f77b4"), ("gap_Sp", "#d62728")]:
            ys = []
            ns = []
            for a_min in xs:
                row = next((r for r in by_a_rows if r["kind"] == kind and r["split"] == "other" and int(r["A_min"]) == int(a_min)), None)
                ys.append(float(row["rms_resid_MeV"]) if isinstance(row, dict) else float("nan"))
                ns.append(int(row["count"]) if isinstance(row, dict) else 0)
            ax.plot(xs, ys, marker="o", color=col, lw=1.6, label=f"{kind} other (n@A>=0={ns[0]})")
        ax.set_xlabel("A_min")
        ax.set_ylabel("RMS(resid) other-magic (MeV)")
        ax.set_title("Other-magic RMS vs A_min (domain stress test)")
        ax.grid(True, alpha=0.25)
        ax.legend(loc="best", fontsize=8)

    def _plot_coverage(ax) -> None:
        kinds = ["gap_Sn", "gap_Sp"]
        mags_all = sorted({int(r["magic"]) for r in by_magic_rows})
        if not mags_all:
            ax.text(0.5, 0.5, "no data", ha="center", va="center")
            ax.set_title("Coverage")
            return
        xs = list(range(len(mags_all)))
        width = 0.38
        for i, kind in enumerate(kinds):
            counts = []
            for m0 in mags_all:
                row_train = next((r for r in by_magic_rows if r["kind"] == kind and int(r["magic"]) == m0 and r["split"] == "train"), None)
                row_other = next((r for r in by_magic_rows if r["kind"] == kind and int(r["magic"]) == m0 and r["split"] == "other"), None)
                c = 0
                if isinstance(row_train, dict):
                    c += int(row_train["count"])
                if isinstance(row_other, dict):
                    c += int(row_other["count"])
                counts.append(c)
            xshift = [x + (-0.5 * width if i == 0 else 0.5 * width) for x in xs]
            ax.bar(xshift, counts, width=width, alpha=0.65, label=kind)
        ax.set_xticks(xs, [str(m) for m in mags_all])
        ax.set_xlabel("magic number")
        ax.set_ylabel("count")
        ax.set_title("Coverage of gap rows (radii-joined set)")
        ax.grid(True, axis="y", alpha=0.25)
        ax.legend(loc="best", fontsize=8)

    fig, axes = plt.subplots(2, 2, figsize=(14, 9), constrained_layout=True)
    _plot_by_magic(axes[0][0], kind="gap_Sn", title="gap_n RMS by magic N (baseline corrected)")
    _plot_by_magic(axes[0][1], kind="gap_Sp", title="gap_p RMS by magic Z (baseline corrected)")
    _plot_rms_vs_amin(axes[1][0])
    _plot_coverage(axes[1][1])

    fig.suptitle("Phase 7 / Step 7.13.15.20: shell-gap failure modes + next design points", fontsize=12)
    fig.text(
        0.01,
        0.01,
        f"baseline={baseline_step} (resid key: {resid_key}); input={baseline_csv.name}",
        ha="left",
        va="bottom",
        fontsize=9,
        color="#444444",
    )

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_failure_modes.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_failure_modes.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(["section", "kind", "split", "magic", "A_min", "count", "rms_resid_MeV", "mean_resid_MeV", "max_abs_resid_MeV", "worst_Z", "worst_N", "worst_A", "worst_resid_MeV"])
        for r0 in by_magic_rows:
            w.writerow(
                [
                    "by_magic",
                    r0["kind"],
                    r0["split"],
                    r0["magic"],
                    "",
                    r0["count"],
                    f"{float(r0['rms_resid_MeV']):.12g}",
                    f"{float(r0['mean_resid_MeV']):.12g}",
                    f"{float(r0['max_abs_resid_MeV']):.12g}",
                    r0["worst_Z"],
                    r0["worst_N"],
                    r0["worst_A"],
                    f"{float(r0['worst_resid_MeV']):.12g}",
                ]
            )
        for r1 in by_a_rows:
            w.writerow(
                [
                    "by_A_min",
                    r1["kind"],
                    r1["split"],
                    "",
                    r1["A_min"],
                    r1["count"],
                    f"{float(r1['rms_resid_MeV']):.12g}",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                ]
            )

    conclusion = (
        "Failure localization (baseline): the dominant other-magic shell-gap residuals are concentrated in light nuclei "
        "(notably N=8/20 and Z=20), while the heavy-domain other-magic coverage is sparse and much smaller in RMS. "
        "Therefore the next extension should first (i) make the applicability domain explicit and/or (ii) expand "
        "coverage beyond the radii-joined set (e.g., via a frozen radius model) before introducing additional "
        "correlation DoF such as deformation/configuration-mixing."
    )
    next_design_points = [
        "Decide an explicit domain boundary for the mean-field+shell model (A_min) and avoid mixing few-body light nuclei into the same extrapolation test without additional physics.",
        "Expand shell-gap coverage beyond the radii-joined set by introducing a frozen charge-radius model (r_charge(A,Z,N)) so that B_pred can be evaluated for a wider mass table (enabling Z=28 etc).",
        "After coverage is expanded, introduce one minimal collective/deformation proxy DoF that can be frozen independently (not by gap fitting) and re-run the strict other-magic decision test.",
    ]

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_failure_modes_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.20",
                "baseline_step": baseline_step,
                "train_magic": sorted(TRAIN_MAGIC),
                "inputs": {"baseline_csv": {"path": str(baseline_csv), "sha256": _sha256(baseline_csv)}},
                "diag": {
                    "by_magic": by_magic_rows,
                    "by_A_min": by_a_rows,
                    "worst": worst_pack,
                },
                "conclusion": conclusion,
                "next_design_points": next_design_points,
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_21(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.21 (initial): Expand shell-gap decision coverage beyond the radii-joined set by
    introducing a frozen charge-radius model and evaluating B_pred on a wider AME2020 mass table.

    Approach (minimal):
      1) Fit a 1-parameter radius model from IAEA charge radii:
           r_charge(A) = r0 * A^(1/3)   (fit via median on A>=radius_fit_min_a; radii-only)
      2) Use frozen HF+surface-term parameters (Step 7.13.15.7) with r_charge(A) to compute B_pred
         for each AME2020 nucleus in-domain, and define B_pred_mean as mean(eq18, eq19).
      3) Run the same frozen protocol as Step 7.13.15.16 on the expanded set:
         - freeze pairing (a_n,a_p) from OES (B_obs only; exclude near magic),
         - refreeze (kN,kZ) on gap_n/gap_p at magic 50/82 under the pairing baseline,
         - report shell-gap coverage and RMS on train vs other magic.

    Outputs:
      - nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded.png
      - nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded.csv
      - nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded_metrics.json
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if radius_fit_min_a < 1:
        raise SystemExit("[fail] radius_fit_min_a must be >= 1")

    # Frozen HF configuration (pn mix, etc).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)
    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    # Frozen surface-term fit (C3_inf, C_surf) from Step 7.13.15.7.
    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m7157 = _load_json(metrics_7157_path)
    fit_by_eq = m7157.get("fit_by_eq")
    if not isinstance(fit_by_eq, dict) or not fit_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: fit_by_eq missing/empty: {metrics_7157_path}")
    eq_labels = sorted(int(k) for k in fit_by_eq.keys() if str(k).isdigit())
    if not eq_labels:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: eq labels missing: {metrics_7157_path}")

    # Common potential inputs (eq18/eq19 sets).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    root = Path(__file__).resolve().parents[2]
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N) -> (A, B/A, sigma, symbol)
    ame_map: dict[tuple[int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N)] = {
            "A": int(A),
            "symbol": str(r.get("symbol", "")),
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
        }

    if not ame_map:
        raise SystemExit("[fail] AME2020 map is empty after parsing (unexpected)")

    # Fixed protocol (same structure as Step 7.13.15.22): pairing OES freeze -> kN/kZ refreeze -> shell-gap decision.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    e2_mev_fm = 1.43996448

    def coulomb_exchange_slater_mev_per_a(*, Z: int, A: int, volume_fm3: float) -> float:
        """
        Coulomb exchange energy (Slater approximation) for a uniform proton gas in a volume V:
          E_x/V = -(3/4) (3/π)^(1/3) e^2 ρ_p^(4/3)
        Return per-nucleon (MeV per A).
        """
        if not (A > 0 and Z >= 0 and math.isfinite(volume_fm3) and volume_fm3 > 0):
            return float("nan")
        if Z <= 0:
            return 0.0
        rho_p = float(Z) / float(volume_fm3)
        if not (math.isfinite(rho_p) and rho_p > 0):
            return float("nan")
        coef = -(3.0 / 4.0) * ((3.0 / math.pi) ** (1.0 / 3.0)) * float(e2_mev_fm)
        e_density = float(coef) * (float(rho_p) ** (4.0 / 3.0))  # MeV fm^-3
        e_total = float(e_density) * float(volume_fm3)  # MeV
        return float(e_total) / float(A)

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    OBS_MAGIC_SET = {int(x) for x in OBS_MAGIC}
    TRAIN_MAGIC = {50, 82}
    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    shell_variants = [
        {"name": "model_magic", "magic": list(MODEL_MAGIC), "note": "S_shell uses model magic list (legacy in 7.13.15.*)."},
        {"name": "obs_magic", "magic": list(OBS_MAGIC), "note": "S_shell uses observed magic list (domain-independent mapping)."},
    ]

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        return any(abs(int(x) - int(m0)) <= int(tol) for m0 in OBS_MAGIC)

    def shell_S_factory(magic_list: list[int]):
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            return float(p * (p - g) / float(g))

        return shell_S

    # Predict B (total) for the expanded AME2020 set using the frozen radius model + Coulomb exchange.
    a_by_zn_all: dict[tuple[int, int], int] = {}
    b_obs_all: dict[tuple[int, int], float] = {}
    b_pred_all: dict[tuple[int, int], float] = {}
    n_skipped = 0
    n_beta2_direct = 0
    n_beta2_imputed = 0
    n_beta2_missing = 0
    include_beta2 = False
    beta2_imputation = "neighbors"
    beta2_apply_surface = False
    beta2_by_zn: dict[tuple[int, int], float] = {}

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue

        a13 = float(A) ** (1.0 / 3.0)
        r_charge = float(r0) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho = float(A) / float(V_sphere)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not math.isfinite(base_e):
                continue
            e_cx = coulomb_exchange_slater_mev_per_a(Z=int(Z), A=int(A), volume_fm3=float(V_sphere))
            if not math.isfinite(e_cx):
                continue
            e_total = float(base_e) + float(e_cx) + float(c3_inf) * (float(rho) ** 2) + float(c_surf) / (6.0 * float(R_sharp))
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn_all[(int(Z), int(N))] = int(A)
        b_obs_all[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred_all[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not a_by_zn_all:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after radius-model prediction")

    # Optional robustness pass: recompute the same prediction with β2 direct-only (no neighbor imputation),
    # and require the strict decision to agree (p-hacking avoidance).
    # Candidate domain boundaries (same as Step 7.13.15.22).
    scan_a_mins = sorted({int(domain_min_a), 40, 60, 80, 100})
    scan_a_mins = [a for a in scan_a_mins if a >= int(domain_min_a)]

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    # Helpers for separations and gaps.
    def build_sep_n(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    def summarize_gaps(
        g_obs: dict[tuple[int, int, int], float],
        g_unc: dict[tuple[int, int, int], float],
        g_base: dict[tuple[int, int, int], float],
        g_cor: dict[tuple[int, int, int], float],
    ) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []
        rows_other: list[tuple[float, float, float]] = []
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            by_magic.setdefault(magic, []).append((resid_u, resid_b, resid_c))
            if magic in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        by_magic_rows: dict[str, dict[str, object]] = {}
        for m, rows in sorted(by_magic.items()):
            by_magic_rows[str(int(m))] = {
                "n": int(len(rows)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows)),
            }

        return {
            "train_magic": {
                "n": int(len(rows_train)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_train)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_train)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_train)),
            },
            "other_magic": {
                "n": int(len(rows_other)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_other)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_other)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_other)),
            },
            "by_magic": by_magic_rows,
        }

    def run_config(*, a_min: int, shell_magic: list[int]) -> dict[str, object]:
        # Domain slice
        a_by_zn = {zn: A for zn, A in a_by_zn_all.items() if int(A) >= int(a_min)}
        b_obs = {zn: b_obs_all[zn] for zn in a_by_zn.keys()}
        b_pred = {zn: b_pred_all[zn] for zn in a_by_zn.keys()}
        if not a_by_zn:
            raise RuntimeError(f"empty domain slice at A_min={a_min}")

        # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
        an_list: list[float] = []
        ap_list: list[float] = []
        for (Z, N), A in a_by_zn.items():
            if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
                continue
            if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
                dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
                if math.isfinite(dn):
                    an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
            if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
                dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
                if math.isfinite(dp):
                    ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
        a_n = _median(an_list)
        a_p = _median(ap_list)
        if not (math.isfinite(a_n) and math.isfinite(a_p) and a_n > 0 and a_p > 0):
            raise RuntimeError(f"pairing freeze failed (no OES samples) at A_min={a_min}")

        # Pairing baseline binding energies.
        b_base: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
            term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
            b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

        # Shell correction basis terms.
        shell_S = shell_S_factory(shell_magic)
        cN: dict[tuple[int, int], float] = {}
        cZ: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            hw = hw_mev(int(A))
            cN[(Z, N)] = float(hw) * float(shell_S(int(N)))
            cZ[(Z, N)] = float(hw) * float(shell_S(int(Z)))

        # Observables (obs).
        sn_obs = build_sep_n(a_by_zn, b_obs, dN=1)
        sp_obs = build_sep_p(a_by_zn, b_obs, dZ=1)
        gap_sn_obs = build_gap_n(sn_obs, step=1)
        gap_sp_obs = build_gap_p(sp_obs, step=1)

        # Predictions: uncorrected (B_pred), pairing-only (B_base).
        sn_pred_unc = build_sep_n(a_by_zn, b_pred, dN=1)
        sp_pred_unc = build_sep_p(a_by_zn, b_pred, dZ=1)
        sn_pred_base = build_sep_n(a_by_zn, b_base, dN=1)
        sp_pred_base = build_sep_p(a_by_zn, b_base, dZ=1)

        gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
        gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
        gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
        gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

        # Unit-basis maps for kN/kZ fits, around the pairing baseline.
        bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
        bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}
        gap_sn_pred_N1 = build_gap_n(build_sep_n(a_by_zn, bN1, dN=1), step=1)
        gap_sp_pred_Z1 = build_gap_p(build_sep_p(a_by_zn, bZ1, dZ=1), step=1)

        # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
        fit_n: list[tuple[float, float]] = []
        for (Z, N0, step), g_obs in gap_sn_obs.items():
            if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sn_pred_base.get((Z, N0, 1))
            g_1 = gap_sn_pred_N1.get((Z, N0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_n.append((y, x))
        if not fit_n:
            raise RuntimeError(f"no fit data for kN at A_min={a_min}")
        kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

        # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
        fit_z: list[tuple[float, float]] = []
        for (N, Z0, step), g_obs in gap_sp_obs.items():
            if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sp_pred_base.get((N, Z0, 1))
            g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_z.append((y, x))
        if not fit_z:
            raise RuntimeError(f"no fit data for kZ at A_min={a_min}")
        kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))
        ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

        # Corrected binding energies (pairing + refrozen shell).
        b_cor: dict[tuple[int, int], float] = {}
        for zn, b0 in b_base.items():
            b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

        # Corrected gap predictions.
        gap_sn_pred_cor = build_gap_n(build_sep_n(a_by_zn, b_cor, dN=1), step=1)
        gap_sp_pred_cor = build_gap_p(build_sep_p(a_by_zn, b_cor, dZ=1), step=1)

        diag_gap_sn = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor)
        diag_gap_sp = summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor)

        # Strict decision: train guardrail + other strict improvement (Sn and Sp).
        train_guard_mev = 0.5
        ok_train = (
            float(diag_gap_sn["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sn["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
            and float(diag_gap_sp["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sp["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
        )
        ok_other = (
            float(diag_gap_sn["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sn["other_magic"]["rms_resid_pairing_only_MeV"])
            and float(diag_gap_sp["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sp["other_magic"]["rms_resid_pairing_only_MeV"])
        )
        pass_strict = bool(ok_train and ok_other)

        return {
            "status": "ok",
            "domain_min_A": int(a_min),
            "n_in_domain": int(len(a_by_zn)),
            "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "n_samples_a_n": int(len(an_list)), "n_samples_a_p": int(len(ap_list))},
            "fit": {"kN": float(kN), "kZ": float(kZ), "kZ_over_kN": float(ratio_kZ_over_kN), "n_fit_pairs_kN": int(len(fit_n)), "n_fit_pairs_kZ": int(len(fit_z))},
            "gap_Sn": diag_gap_sn,
            "gap_Sp": diag_gap_sp,
            "decision": {"train_guard_mev": float(train_guard_mev), "pass_strict": bool(pass_strict)},
        }

    rows: list[dict[str, object]] = []
    for sv in shell_variants:
        shell_name = str(sv["name"])
        shell_magic = list(sv["magic"])
        for a_min in scan_a_mins:
            try:
                pack = run_config(a_min=int(a_min), shell_magic=shell_magic)
                pack["shell_variant"] = {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))}
                rows.append(pack)
            except Exception as e:
                rows.append(
                    {
                        "status": "skipped",
                        "shell_variant": {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))},
                        "domain_min_A": int(a_min),
                        "reason": str(e),
                    }
                )

    # Fit radius model (published only; radii-only fit).
    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    ratios: list[float] = []
    fit_rows: list[dict[str, float]] = []
    with radii_path.open("r", encoding="utf-8", newline="") as f:
        rr = csv.DictReader(f)
        for row in rr:
            if not isinstance(row, dict):
                continue
            Z = int(row.get("z", "-1"))
            N = int(row.get("n", "-1"))
            A = int(row.get("a", "-1"))
            if Z < 1 or N < 0 or A < int(radius_fit_min_a):
                continue
            # Use published radii only here (avoid mixing prelim into the fit).
            try:
                r_val = float(str(row.get("radius_val", "")).strip() or "nan")
            except Exception:
                r_val = float("nan")
            if not (math.isfinite(r_val) and r_val > 0):
                continue
            a13 = float(A) ** (1.0 / 3.0)
            if not (math.isfinite(a13) and a13 > 0):
                continue
            ratios.append(float(r_val) / float(a13))
            fit_rows.append({"A": float(A), "r_charge_fm": float(r_val), "a13": float(a13), "Z": float(Z), "N": float(N)})

    r0 = _median(ratios)
    if not (math.isfinite(r0) and r0 > 0):
        raise SystemExit("[fail] could not fit r0 from radii-only data (median ratio invalid)")

    fit_resids = [float(fr["r_charge_fm"] - float(r0) * float(fr["a13"])) for fr in fit_rows]
    fit_rms = math.sqrt(sum(x * x for x in fit_resids) / len(fit_resids)) if fit_resids else float("nan")

    # Baseline coverage from the radii-joined CSV (for comparison).
    baseline_csv = out_dir / "nuclear_a_dependence_hf_three_body_shell_degeneracy_pairing_sep_refreeze.csv"
    baseline_counts: dict[tuple[str, int], int] = {}
    if baseline_csv.exists():
        with baseline_csv.open("r", newline="", encoding="utf-8") as f:
            br = csv.DictReader(f)
            for row in br:
                kind = str(row.get("kind", ""))
                if kind not in {"gap_Sn", "gap_Sp"}:
                    continue
                key1 = str(row.get("key1", ""))
                key2 = str(row.get("key2", ""))
                if kind == "gap_Sn" and key2.startswith("N"):
                    magic = int(key2[1:])
                    baseline_counts[(kind, magic)] = baseline_counts.get((kind, magic), 0) + 1
                if kind == "gap_Sp" and key2.startswith("Z"):
                    magic = int(key2[1:])
                    baseline_counts[(kind, magic)] = baseline_counts.get((kind, magic), 0) + 1

    # Compute B_pred_mean for the expanded AME2020 set using the frozen radius model.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    TRAIN_MAGIC = {50, 82}

    def shell_S_model(x: int) -> float:
        if x <= 0:
            return 0.0
        Mk = None
        Mk1 = None
        for a, b in zip(MODEL_MAGIC[:-1], MODEL_MAGIC[1:], strict=True):
            if int(a) < int(x) <= int(b):
                Mk = int(a)
                Mk1 = int(b)
                break
        if Mk is None or Mk1 is None:
            Mk = int(MODEL_MAGIC[-2])
            Mk1 = int(MODEL_MAGIC[-1])
            if x > Mk1:
                Mk = int(MODEL_MAGIC[-1])
                Mk1 = int(MODEL_MAGIC[-1] + 1)
        g = int(Mk1 - Mk)
        if g <= 0:
            return 0.0
        p = int(x - Mk)
        if p < 0:
            p = 0
        if p > g:
            p = g
        return float(p * (p - g) / float(g))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        for m0 in OBS_MAGIC:
            if abs(int(x) - int(m0)) <= int(tol):
                return True
        return False

    a_by_zn: dict[tuple[int, int], int] = {}
    b_obs: dict[tuple[int, int], float] = {}
    b_pred: dict[tuple[int, int], float] = {}
    n_skipped = 0

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue

        a13 = float(A) ** (1.0 / 3.0)
        r_charge = float(r0) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        rho = float(A) / ((4.0 / 3.0) * math.pi * float(R_sharp) ** 3)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not math.isfinite(base_e):
                continue
            e_total = float(base_e) + float(c3_inf) * (float(rho) ** 2) + float(c_surf) / (6.0 * float(R_sharp))
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            # Fall back to any available eq (keeps the step runnable even if only one exists).
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn[(int(Z), int(N))] = int(A)
        b_obs[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not b_obs:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after radius-model expansion")

    # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
    an_list: list[float] = []
    ap_list: list[float] = []
    for (Z, N), A in a_by_zn.items():
        if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
            continue
        if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
            dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
            if math.isfinite(dn):
                an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
        if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
            dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
            if math.isfinite(dp):
                ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
    a_n = _median(an_list)
    a_p = _median(ap_list)
    if not (math.isfinite(a_n) and math.isfinite(a_p)):
        raise SystemExit("[fail] could not estimate pairing amplitudes (a_n, a_p) from OES (3-point) in mid-shell set")

    # Pairing baseline binding energies.
    b_base: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
        term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
        b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

    # Shell correction basis terms.
    cN: dict[tuple[int, int], float] = {}
    cZ: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        hw = hw_mev(int(A))
        cN[(Z, N)] = float(hw) * float(shell_S_model(int(N)))
        cZ[(Z, N)] = float(hw) * float(shell_S_model(int(Z)))

    # Helpers for separations and gaps.
    def build_sep_n(b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N), _A in a_by_zn.items():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    # Observables (obs).
    sn_obs = build_sep_n(b_obs, dN=1)
    sp_obs = build_sep_p(b_obs, dZ=1)
    gap_sn_obs = build_gap_n(sn_obs, step=1)
    gap_sp_obs = build_gap_p(sp_obs, step=1)

    # Predictions: uncorrected (B_pred), pairing-only (B_base).
    sn_pred_unc = build_sep_n(b_pred, dN=1)
    sp_pred_unc = build_sep_p(b_pred, dZ=1)
    sn_pred_base = build_sep_n(b_base, dN=1)
    sp_pred_base = build_sep_p(b_base, dZ=1)

    gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
    gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
    gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
    gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

    # Unit-basis maps for kN/kZ fits, around the pairing baseline.
    bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
    bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}
    gap_sn_pred_N1 = build_gap_n(build_sep_n(bN1, dN=1), step=1)
    gap_sp_pred_Z1 = build_gap_p(build_sep_p(bZ1, dZ=1), step=1)

    # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
    fit_n: list[tuple[float, float]] = []
    for (Z, N0, step), g_obs in gap_sn_obs.items():
        if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
            continue
        g_base = gap_sn_pred_base.get((Z, N0, 1))
        g_1 = gap_sn_pred_N1.get((Z, N0, 1))
        if g_base is None or g_1 is None:
            continue
        x = float(g_1 - g_base)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_base)
        fit_n.append((y, x))
    if not fit_n:
        raise SystemExit("[fail] no fit data for kN (gap_n at observed magic N=50/82)")
    kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

    # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
    fit_z: list[tuple[float, float]] = []
    for (N, Z0, step), g_obs in gap_sp_obs.items():
        if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
            continue
        g_base = gap_sp_pred_base.get((N, Z0, 1))
        g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
        if g_base is None or g_1 is None:
            continue
        x = float(g_1 - g_base)
        if not math.isfinite(x) or abs(x) < 1e-12:
            continue
        y = float(g_obs - g_base)
        fit_z.append((y, x))
    if not fit_z:
        raise SystemExit("[fail] no fit data for kZ (gap_p at observed magic Z=50/82)")
    kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))
    ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

    # Corrected binding energies (pairing + refrozen shell).
    b_cor: dict[tuple[int, int], float] = {}
    for zn, b0 in b_base.items():
        b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

    # Corrected gap predictions.
    sn_pred_cor = build_sep_n(b_cor, dN=1)
    sp_pred_cor = build_sep_p(b_cor, dZ=1)
    gap_sn_pred_cor = build_gap_n(sn_pred_cor, step=1)
    gap_sp_pred_cor = build_gap_p(sp_pred_cor, step=1)

    # Summaries (train vs other) + coverage by magic.
    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def _summarize_gaps(g_obs: dict, g_unc: dict, g_base: dict, g_cor: dict, *, key_is_magic: str) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []  # (unc, base, cor) residuals
        rows_other: list[tuple[float, float, float]] = []
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1]) if key_is_magic == "N" else int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            if int(magic) in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        return {
            "train_magic": {"n": len(rows_train), "rms_resid_uncorrected_MeV": _r(0, rows_train), "rms_resid_pairing_only_MeV": _r(1, rows_train), "rms_resid_pairing_shell_MeV": _r(2, rows_train)},
            "other_magic": {"n": len(rows_other), "rms_resid_uncorrected_MeV": _r(0, rows_other), "rms_resid_pairing_only_MeV": _r(1, rows_other), "rms_resid_pairing_shell_MeV": _r(2, rows_other)},
        }

    diag_gap_sn = _summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor, key_is_magic="N")
    diag_gap_sp = _summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor, key_is_magic="Z")

    # Coverage counts by magic number (obs gaps).
    cov_expanded: dict[tuple[str, int], int] = {}
    for (Z, N0, step) in gap_sn_obs.keys():
        if int(step) != 1:
            continue
        cov_expanded[("gap_Sn", int(N0))] = cov_expanded.get(("gap_Sn", int(N0)), 0) + 1
    for (N, Z0, step) in gap_sp_obs.keys():
        if int(step) != 1:
            continue
        cov_expanded[("gap_Sp", int(Z0))] = cov_expanded.get(("gap_Sp", int(Z0)), 0) + 1

    # CSV of gap rows (expanded).
    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded.csv"
    header = [
        "kind",
        "key1",
        "key2",
        "obs_MeV",
        "pred_uncorrected_MeV",
        "pred_pairing_only_MeV",
        "pred_pairing_shell_MeV",
        "resid_uncorrected_MeV",
        "resid_pairing_only_MeV",
        "resid_pairing_shell_MeV",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for (Z, N0, _dN), g_obs in sorted(gap_sn_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sn_pred_unc.get((Z, N0, 1))
            gb = gap_sn_pred_base.get((Z, N0, 1))
            gc = gap_sn_pred_cor.get((Z, N0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(
                [
                    "gap_Sn",
                    f"Z{Z}",
                    f"N{N0}",
                    f"{float(g_obs):.12g}",
                    f"{float(gu):.12g}",
                    f"{float(gb):.12g}",
                    f"{float(gc):.12g}",
                    f"{float(gu - g_obs):.12g}",
                    f"{float(gb - g_obs):.12g}",
                    f"{float(gc - g_obs):.12g}",
                ]
            )
        for (N, Z0, _dZ), g_obs in sorted(gap_sp_obs.items(), key=lambda x: (x[0][1], x[0][0])):
            gu = gap_sp_pred_unc.get((N, Z0, 1))
            gb = gap_sp_pred_base.get((N, Z0, 1))
            gc = gap_sp_pred_cor.get((N, Z0, 1))
            if gu is None or gb is None or gc is None:
                continue
            w.writerow(
                [
                    "gap_Sp",
                    f"N{N}",
                    f"Z{Z0}",
                    f"{float(g_obs):.12g}",
                    f"{float(gu):.12g}",
                    f"{float(gb):.12g}",
                    f"{float(gc):.12g}",
                    f"{float(gu - g_obs):.12g}",
                    f"{float(gb - g_obs):.12g}",
                    f"{float(gc - g_obs):.12g}",
                ]
            )

    # Plot coverage baseline vs expanded.
    import matplotlib.pyplot as plt

    mags = sorted({m for (_k, m) in (baseline_counts.keys() | cov_expanded.keys())})
    if not mags:
        mags = [2, 8, 20, 28, 50, 82, 126]

    def _counts(kind: str, *, src: dict[tuple[str, int], int]) -> list[int]:
        return [int(src.get((kind, int(m)), 0)) for m in mags]

    fig, axes = plt.subplots(1, 2, figsize=(14, 5), constrained_layout=True)
    for ax, kind, title in [
        (axes[0], "gap_Sn", "Coverage: gap_n rows by magic N"),
        (axes[1], "gap_Sp", "Coverage: gap_p rows by magic Z"),
    ]:
        x = list(range(len(mags)))
        w = 0.38
        base = _counts(kind, src=baseline_counts)
        exp = _counts(kind, src=cov_expanded)
        ax.bar([xi - w / 2 for xi in x], base, width=w, alpha=0.65, label="baseline (radii-joined)")
        ax.bar([xi + w / 2 for xi in x], exp, width=w, alpha=0.65, label="expanded (radius model)")
        ax.set_xticks(x, [str(m) for m in mags])
        ax.set_xlabel("magic number")
        ax.set_ylabel("count")
        ax.set_title(title)
        ax.grid(True, axis="y", alpha=0.25)
        ax.legend(loc="best", fontsize=8)

    fig.suptitle("Phase 7 / Step 7.13.15.21: shell-gap coverage expanded via frozen radius model", fontsize=12)
    fig.text(
        0.01,
        0.01,
        f"r_charge=r0*A^(1/3), r0={r0:.6g} fm (fit A>={radius_fit_min_a}, n={len(fit_rows)}, rms={fit_rms:.4g} fm); domain A>={domain_min_a}; skipped={n_skipped}",
        ha="left",
        va="bottom",
        fontsize=9,
        color="#444444",
    )
    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded.png"
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.21",
                "domain_min_A": int(domain_min_a),
                "radius_model": {
                    "form": "r_charge = r0*A^(1/3)",
                    "r0_fm": float(r0),
                    "fit_min_A": int(radius_fit_min_a),
                    "n_fit": int(len(fit_rows)),
                    "fit_rms_fm": float(fit_rms),
                },
                "frozen_inputs": {
                    "pn_triplet_weight": float(pn_triplet_weight),
                    "surface_term_fit_by_eq": {str(k): {"C3_inf": float(v.get("C3_inf", float("nan"))), "C_surf_MeV_fm": float(v.get("C_surf_MeV_fm", float("nan")))} for k, v in fit_by_eq.items() if isinstance(v, dict)},
                },
                "diag": {
                    "n_ame_total": int(len(ame_map)),
                    "n_in_domain": int(len(a_by_zn)),
                    "n_skipped": int(n_skipped),
                    "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "exclude_near_observed_magic_tol": 1},
                    "fit": {"kN": float(kN), "kZ": float(kZ), "kZ_over_kN": float(ratio_kZ_over_kN), "n_fit_pairs_kN": int(len(fit_n)), "n_fit_pairs_kZ": int(len(fit_z))},
                    "coverage": {
                        "baseline_counts": {f"{k}:{m}": int(v) for (k, m), v in baseline_counts.items()},
                        "expanded_counts": {f"{k}:{m}": int(v) for (k, m), v in cov_expanded.items()},
                    },
                    "gap_Sn": diag_gap_sn,
                    "gap_Sp": diag_gap_sp,
                },
                "inputs": {
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                    "metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_22(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.22 (initial): Resolve the expanded-set shell-gap decision by scanning
    (i) applicability domain A_min and (ii) fixed shell-mapping variants (no new fitted DoF),
    then re-evaluate the strict train/other behavior on the expanded AME2020 set.

    Outputs (fixed names):
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded.png
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded.csv
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_metrics.json
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if radius_fit_min_a < 1:
        raise SystemExit("[fail] radius_fit_min_a must be >= 1")

    include_beta2 = False
    beta2_by_zn: dict[tuple[int, int], float] = {}

    # Frozen HF configuration (pn mix, etc).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)
    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    # Frozen surface-term fit (C3_inf, C_surf) from Step 7.13.15.7.
    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m7157 = _load_json(metrics_7157_path)
    fit_by_eq = m7157.get("fit_by_eq")
    if not isinstance(fit_by_eq, dict) or not fit_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: fit_by_eq missing/empty: {metrics_7157_path}")
    eq_labels = sorted(int(k) for k in fit_by_eq.keys() if str(k).isdigit())
    if not eq_labels:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: eq labels missing: {metrics_7157_path}")

    # Common potential inputs (eq18/eq19 sets).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    root = Path(__file__).resolve().parents[2]
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N) -> (A, B/A, sigma, symbol)
    ame_map: dict[tuple[int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N)] = {
            "A": int(A),
            "symbol": str(r.get("symbol", "")),
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
        }
    if not ame_map:
        raise SystemExit("[fail] AME2020 map is empty after parsing (unexpected)")

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    # Fit radius model (published only; radii-only fit).
    ratios: list[float] = []
    fit_rows: list[dict[str, float]] = []
    with radii_path.open("r", encoding="utf-8", newline="") as f:
        rr = csv.DictReader(f)
        for row in rr:
            if not isinstance(row, dict):
                continue
            Z = int(row.get("z", "-1"))
            N = int(row.get("n", "-1"))
            A = int(row.get("a", "-1"))
            if Z < 1 or N < 0 or A < int(radius_fit_min_a):
                continue
            try:
                r_val = float(str(row.get("radius_val", "")).strip() or "nan")
            except Exception:
                r_val = float("nan")
            if not (math.isfinite(r_val) and r_val > 0):
                continue
            a13 = float(A) ** (1.0 / 3.0)
            if not (math.isfinite(a13) and a13 > 0):
                continue
            ratios.append(float(r_val) / float(a13))
            fit_rows.append({"A": float(A), "r_charge_fm": float(r_val), "a13": float(a13), "Z": float(Z), "N": float(N)})
    r0 = _median(ratios)
    if not (math.isfinite(r0) and r0 > 0):
        raise SystemExit("[fail] could not fit r0 from radii-only data (median ratio invalid)")
    fit_resids = [float(fr["r_charge_fm"] - float(r0) * float(fr["a13"])) for fr in fit_rows]
    fit_rms = math.sqrt(sum(x * x for x in fit_resids) / len(fit_resids)) if fit_resids else float("nan")

    # Predict B (total) for all nuclei at/above the minimum domain threshold.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    TRAIN_MAGIC = {50, 82}

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        return any(abs(int(x) - int(m0)) <= int(tol) for m0 in OBS_MAGIC)

    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    shell_variants = [
        {"name": "model_magic", "magic": list(MODEL_MAGIC), "note": "S_shell uses model magic list (legacy in 7.13.15.*)."},
        {"name": "obs_magic", "magic": list(OBS_MAGIC), "note": "S_shell uses observed magic list (domain-independent mapping)."},
    ]

    a_by_zn_all: dict[tuple[int, int], int] = {}
    b_obs_all: dict[tuple[int, int], float] = {}
    b_pred_all: dict[tuple[int, int], float] = {}
    n_skipped = 0
    n_beta2_direct = 0
    n_beta2_imputed = 0
    n_beta2_missing = 0

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue

        a13 = float(A) ** (1.0 / 3.0)
        r_charge = float(r0) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        rho = float(A) / ((4.0 / 3.0) * math.pi * float(R_sharp) ** 3)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not math.isfinite(base_e):
                continue
            e_total = float(base_e) + float(c3_inf) * (float(rho) ** 2) + float(c_surf) / (6.0 * float(R_sharp))
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn_all[(int(Z), int(N))] = int(A)
        b_obs_all[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred_all[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not a_by_zn_all:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after AME2020 parsing")

    # Candidate domain boundaries (explicitly test a few cuts; no fitting).
    scan_a_mins = sorted({int(domain_min_a), 40, 60, 80, 100})
    scan_a_mins = [a for a in scan_a_mins if a >= int(domain_min_a)]

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def shell_S_factory(magic_list: list[int]):
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            return float(p * (p - g) / float(g))

        return shell_S

    def build_sep_n(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    def summarize_gaps(
        g_obs: dict[tuple[int, int, int], float],
        g_unc: dict[tuple[int, int, int], float],
        g_base: dict[tuple[int, int, int], float],
        g_cor: dict[tuple[int, int, int], float],
    ) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []
        rows_other: list[tuple[float, float, float]] = []
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            by_magic.setdefault(magic, []).append((resid_u, resid_b, resid_c))
            if magic in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        by_magic_rows: dict[str, dict[str, object]] = {}
        for m, rows in sorted(by_magic.items()):
            by_magic_rows[str(int(m))] = {
                "n": int(len(rows)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows)),
            }

        return {
            "train_magic": {
                "n": int(len(rows_train)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_train)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_train)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_train)),
            },
            "other_magic": {
                "n": int(len(rows_other)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_other)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_other)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_other)),
            },
            "by_magic": by_magic_rows,
        }

    def run_config(*, a_min: int, shell_magic: list[int]) -> dict[str, object]:
        # Domain slice
        a_by_zn = {zn: A for zn, A in a_by_zn_all.items() if int(A) >= int(a_min)}
        b_obs = {zn: b_obs_all[zn] for zn in a_by_zn.keys()}
        b_pred = {zn: b_pred_all[zn] for zn in a_by_zn.keys()}
        if not a_by_zn:
            raise RuntimeError(f"empty domain slice at A_min={a_min}")

        # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
        an_list: list[float] = []
        ap_list: list[float] = []
        for (Z, N), A in a_by_zn.items():
            if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
                continue
            if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
                dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
                if math.isfinite(dn):
                    an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
            if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
                dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
                if math.isfinite(dp):
                    ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
        a_n = _median(an_list)
        a_p = _median(ap_list)
        if not (math.isfinite(a_n) and math.isfinite(a_p)):
            raise RuntimeError(f"pairing freeze failed (no OES samples) at A_min={a_min}")

        # Pairing baseline binding energies.
        b_base: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
            term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
            b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

        # Shell correction basis terms.
        shell_S = shell_S_factory(shell_magic)
        cN: dict[tuple[int, int], float] = {}
        cZ: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            hw = hw_mev(int(A))
            cN[(Z, N)] = float(hw) * float(shell_S(int(N)))
            cZ[(Z, N)] = float(hw) * float(shell_S(int(Z)))

        # Observables (obs).
        sn_obs = build_sep_n(a_by_zn, b_obs, dN=1)
        sp_obs = build_sep_p(a_by_zn, b_obs, dZ=1)
        gap_sn_obs = build_gap_n(sn_obs, step=1)
        gap_sp_obs = build_gap_p(sp_obs, step=1)

        # Predictions: uncorrected (B_pred), pairing-only (B_base).
        sn_pred_unc = build_sep_n(a_by_zn, b_pred, dN=1)
        sp_pred_unc = build_sep_p(a_by_zn, b_pred, dZ=1)
        sn_pred_base = build_sep_n(a_by_zn, b_base, dN=1)
        sp_pred_base = build_sep_p(a_by_zn, b_base, dZ=1)

        gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
        gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
        gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
        gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

        # Unit-basis maps for kN/kZ fits, around the pairing baseline.
        bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
        bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}
        gap_sn_pred_N1 = build_gap_n(build_sep_n(a_by_zn, bN1, dN=1), step=1)
        gap_sp_pred_Z1 = build_gap_p(build_sep_p(a_by_zn, bZ1, dZ=1), step=1)

        # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
        fit_n: list[tuple[float, float]] = []
        for (Z, N0, step), g_obs in gap_sn_obs.items():
            if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sn_pred_base.get((Z, N0, 1))
            g_1 = gap_sn_pred_N1.get((Z, N0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_n.append((y, x))
        if not fit_n:
            raise RuntimeError(f"no fit data for kN at A_min={a_min}")
        kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

        # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
        fit_z: list[tuple[float, float]] = []
        for (N, Z0, step), g_obs in gap_sp_obs.items():
            if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sp_pred_base.get((N, Z0, 1))
            g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_z.append((y, x))
        if not fit_z:
            raise RuntimeError(f"no fit data for kZ at A_min={a_min}")
        kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))
        ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

        # Corrected binding energies (pairing + refrozen shell).
        b_cor: dict[tuple[int, int], float] = {}
        for zn, b0 in b_base.items():
            b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

        # Corrected gap predictions.
        gap_sn_pred_cor = build_gap_n(build_sep_n(a_by_zn, b_cor, dN=1), step=1)
        gap_sp_pred_cor = build_gap_p(build_sep_p(a_by_zn, b_cor, dZ=1), step=1)

        diag_gap_sn = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor)
        diag_gap_sp = summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor)

        # Strict decision: train guardrail + other strict improvement (Sn and Sp).
        train_guard_mev = 0.5
        ok_train = (
            float(diag_gap_sn["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sn["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
            and float(diag_gap_sp["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sp["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
        )
        ok_other = (
            float(diag_gap_sn["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sn["other_magic"]["rms_resid_pairing_only_MeV"])
            and float(diag_gap_sp["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sp["other_magic"]["rms_resid_pairing_only_MeV"])
        )
        pass_strict = bool(ok_train and ok_other)

        return {
            "status": "ok",
            "domain_min_A": int(a_min),
            "n_in_domain": int(len(a_by_zn)),
            "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "n_samples_a_n": int(len(an_list)), "n_samples_a_p": int(len(ap_list))},
            "fit": {"kN": float(kN), "kZ": float(kZ), "kZ_over_kN": float(ratio_kZ_over_kN), "n_fit_pairs_kN": int(len(fit_n)), "n_fit_pairs_kZ": int(len(fit_z))},
            "gap_Sn": diag_gap_sn,
            "gap_Sp": diag_gap_sp,
            "decision": {"train_guard_mev": float(train_guard_mev), "pass_strict": bool(pass_strict)},
        }

    rows: list[dict[str, object]] = []
    for sv in shell_variants:
        shell_name = str(sv["name"])
        shell_magic = list(sv["magic"])
        for a_min in scan_a_mins:
            try:
                pack = run_config(a_min=int(a_min), shell_magic=shell_magic)
                pack["shell_variant"] = {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))}
                rows.append(pack)
            except Exception as e:
                rows.append(
                    {
                        "status": "skipped",
                        "shell_variant": {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))},
                        "domain_min_A": int(a_min),
                        "reason": str(e),
                    }
                )

    # CSV (flat table).
    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded.csv"
    header = [
        "shell_variant",
        "domain_min_A",
        "status",
        "n_in_domain",
        "a_n_MeV",
        "a_p_MeV",
        "kN",
        "kZ",
        "kZ_over_kN",
        "gap_Sn_train_n",
        "gap_Sn_train_rms_pairing_only_MeV",
        "gap_Sn_train_rms_pairing_shell_MeV",
        "gap_Sn_other_n",
        "gap_Sn_other_rms_pairing_only_MeV",
        "gap_Sn_other_rms_pairing_shell_MeV",
        "gap_Sp_train_n",
        "gap_Sp_train_rms_pairing_only_MeV",
        "gap_Sp_train_rms_pairing_shell_MeV",
        "gap_Sp_other_n",
        "gap_Sp_other_rms_pairing_only_MeV",
        "gap_Sp_other_rms_pairing_shell_MeV",
        *(
            [
                "gap_Sn_spectro_peak_n_available",
                "gap_Sn_spectro_peak_n_peak",
                "gap_Sn_spectro_peak_rms_pairing_only_MeV",
                "gap_Sn_spectro_peak_rms_pairing_shell_MeV",
                "gap_Sp_spectro_peak_n_available",
                "gap_Sp_spectro_peak_n_peak",
                "gap_Sp_spectro_peak_rms_pairing_only_MeV",
                "gap_Sp_spectro_peak_rms_pairing_shell_MeV",
                "pass_strict_spectro",
            ]
            if include_e2plus
            else []
        ),
        "pass_strict",
        "reason",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            status = str(r.get("status", ""))
            sv = r.get("shell_variant") if isinstance(r.get("shell_variant"), dict) else {}
            name = str(sv.get("name", ""))
            domain_a = int(r.get("domain_min_A", -1))
            reason = str(r.get("reason", "")) if status != "ok" else ""
            n_in = int(r.get("n_in_domain", 0)) if status == "ok" else 0
            pairing = r.get("pairing") if isinstance(r.get("pairing"), dict) else {}
            fit = r.get("fit") if isinstance(r.get("fit"), dict) else {}
            gap_sn = r.get("gap_Sn") if isinstance(r.get("gap_Sn"), dict) else {}
            gap_sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
            spectro = r.get("spectro_e2plus") if isinstance(r.get("spectro_e2plus"), dict) else {}
            spec_sn = spectro.get("gap_Sn_peak") if isinstance(spectro.get("gap_Sn_peak"), dict) else {}
            spec_sp = spectro.get("gap_Sp_peak") if isinstance(spectro.get("gap_Sp_peak"), dict) else {}
            sn_tr = gap_sn.get("train_magic") if isinstance(gap_sn.get("train_magic"), dict) else {}
            sn_ot = gap_sn.get("other_magic") if isinstance(gap_sn.get("other_magic"), dict) else {}
            sp_tr = gap_sp.get("train_magic") if isinstance(gap_sp.get("train_magic"), dict) else {}
            sp_ot = gap_sp.get("other_magic") if isinstance(gap_sp.get("other_magic"), dict) else {}
            decision = r.get("decision") if isinstance(r.get("decision"), dict) else {}
            w.writerow(
                [
                    name,
                    domain_a,
                    status,
                    n_in,
                    f"{float(pairing.get('a_n_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(pairing.get('a_p_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kN', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ_over_kN', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    str(bool(decision.get("pass_strict", False))) if status == "ok" else "",
                    reason,
                ]
            )

    # Plot: delta RMS (shell - pairing) vs A_min for train/other and Sn/Sp.
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    fig, axes = plt.subplots(2, 2, figsize=(13, 7), constrained_layout=True)
    panels = [
        ("gap_Sn", "other_magic", axes[0][0], "ΔRMS other: gap Sn (shell - pairing)"),
        ("gap_Sp", "other_magic", axes[0][1], "ΔRMS other: gap Sp (shell - pairing)"),
        ("gap_Sn", "train_magic", axes[1][0], "ΔRMS train: gap Sn (shell - pairing)"),
        ("gap_Sp", "train_magic", axes[1][1], "ΔRMS train: gap Sp (shell - pairing)"),
    ]

    for sv in shell_variants:
        name = str(sv["name"])
        ok_rows = [r for r in rows if r.get("status") == "ok" and isinstance(r.get("shell_variant"), dict) and r["shell_variant"].get("name") == name]
        ok_rows = sorted(ok_rows, key=lambda x: int(x.get("domain_min_A", 0)))
        xs = [int(r.get("domain_min_A", 0)) for r in ok_rows]
        for kind, subset, ax, title in panels:
            ys: list[float] = []
            for r in ok_rows:
                g = r.get(kind) if isinstance(r.get(kind), dict) else {}
                sub = g.get(subset) if isinstance(g.get(subset), dict) else {}
                y = float(sub.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(sub.get("rms_resid_pairing_only_MeV", float("nan")))
                ys.append(float(y))
            ax.plot(xs, ys, marker="o", linestyle="-", label=name)
            ax.set_title(title)
            ax.set_xlabel("domain A_min")
            ax.set_ylabel("ΔRMS (MeV)")
            ax.axhline(0.0, color="k", linewidth=1.0, alpha=0.25)
            ax.grid(True, alpha=0.3)

    for ax in axes.flatten():
        ax.legend(fontsize=8)

    fig.suptitle("Phase 7 / Step 7.13.15.22: expanded-set shell-gap decision scan (domain vs shell mapping)", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded.png"
    fig.savefig(out_png, dpi=160)
    plt.close(fig)

    # Decision summary.
    ok_rows = [r for r in rows if r.get("status") == "ok"]
    n_pass = sum(1 for r in ok_rows if bool((r.get("decision") or {}).get("pass_strict", False)))
    conclusion = (
        f"strict_pass={n_pass}/{len(ok_rows)} over shell variants × A_min cuts. "
        "If strict_pass==0, the expanded-set shell refreeze improves train but does not generalize to other-magic "
        "under any tested domain boundary or fixed S_shell mapping variant (initial no-go remains)."
    )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.22",
                "scan": {"domain_min_A_base": int(domain_min_a), "domain_min_A_candidates": scan_a_mins, "shell_variants": shell_variants},
                "radius_model": {"form": "r_charge = r0*A^(1/3)", "r0_fm": float(r0), "fit_min_A": int(radius_fit_min_a), "n_fit": int(len(fit_rows)), "fit_rms_fm": float(fit_rms)},
                "diag": {
                    "n_ame_total": int(len(ame_map)),
                    "n_in_domain_base": int(len(a_by_zn_all)),
                    "n_skipped_base": int(n_skipped),
                    "conclusion": conclusion,
                },
                "results": rows,
                "inputs": {
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                    "metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_23(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.23 (initial): Proton-side shell-gap rescue attempt with a minimal independently
    frozen DoF: extend the frozen charge-radius model using isospin asymmetry, fit only to radii
    (not to mass/gap data), then re-run the expanded-set shell-gap strict decision.

    Radius model (radii-only fit; published radii; A>=radius_fit_min_a):
      r_charge(A,Z,N) = (r0 + rI * I) * A^(1/3), where I = (N-Z)/A

    Outputs (fixed names):
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin.png
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin.csv
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_metrics.json
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if radius_fit_min_a < 1:
        raise SystemExit("[fail] radius_fit_min_a must be >= 1")

    # Frozen HF configuration (pn mix, etc).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)
    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    # Frozen surface-term fit (C3_inf, C_surf) from Step 7.13.15.7.
    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m7157 = _load_json(metrics_7157_path)
    fit_by_eq = m7157.get("fit_by_eq")
    if not isinstance(fit_by_eq, dict) or not fit_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: fit_by_eq missing/empty: {metrics_7157_path}")
    eq_labels = sorted(int(k) for k in fit_by_eq.keys() if str(k).isdigit())
    if not eq_labels:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: eq labels missing: {metrics_7157_path}")

    # Common potential inputs (eq18/eq19 sets).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    root = Path(__file__).resolve().parents[2]
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N) -> (A, B/A, sigma, symbol)
    ame_map: dict[tuple[int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N)] = {
            "A": int(A),
            "symbol": str(r.get("symbol", "")),
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
        }
    if not ame_map:
        raise SystemExit("[fail] AME2020 map is empty after parsing (unexpected)")

    def _mean(vals: list[float]) -> float:
        return float(sum(vals) / len(vals)) if vals else float("nan")

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    # Fit radius model (published only; radii-only fit).
    x_list: list[float] = []
    y_list: list[float] = []
    fit_rows: list[dict[str, float]] = []
    with radii_path.open("r", encoding="utf-8", newline="") as f:
        rr = csv.DictReader(f)
        for row in rr:
            if not isinstance(row, dict):
                continue
            Z = int(row.get("z", "-1"))
            N = int(row.get("n", "-1"))
            A = int(row.get("a", "-1"))
            if Z < 1 or N < 0 or A < int(radius_fit_min_a):
                continue
            try:
                r_val = float(str(row.get("radius_val", "")).strip() or "nan")
            except Exception:
                r_val = float("nan")
            if not (math.isfinite(r_val) and r_val > 0):
                continue
            a13 = float(A) ** (1.0 / 3.0)
            if not (math.isfinite(a13) and a13 > 0):
                continue
            I = float(int(N) - int(Z)) / float(A)
            y = float(r_val) / float(a13)
            if not (math.isfinite(I) and math.isfinite(y)):
                continue
            x_list.append(float(I))
            y_list.append(float(y))
            fit_rows.append({"A": float(A), "Z": float(Z), "N": float(N), "I": float(I), "r_charge_fm": float(r_val), "r_over_a13": float(y)})

    if len(x_list) < 10:
        raise SystemExit("[fail] insufficient radii-only fit rows for isospin radius model (need >=10)")

    mx = _mean(x_list)
    my = _mean(y_list)
    vx = sum((x - mx) ** 2 for x in x_list)
    if not (math.isfinite(vx) and vx > 0):
        raise SystemExit("[fail] invalid variance in I for radius fit (vx<=0)")
    cov = sum((x - mx) * (y - my) for x, y in zip(x_list, y_list, strict=True))
    rI = float(cov / vx)
    r0 = float(my - rI * mx)

    # Fit RMS in radii space.
    fit_resids = [float(fr["r_charge_fm"] - (float(r0) + float(rI) * float(fr["I"])) * (float(fr["A"]) ** (1.0 / 3.0))) for fr in fit_rows]
    fit_rms = math.sqrt(sum(x * x for x in fit_resids) / len(fit_resids)) if fit_resids else float("nan")

    # Predict B (total) for the expanded AME2020 set using the isospin radius model.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    TRAIN_MAGIC = {50, 82}

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        return any(abs(int(x) - int(m0)) <= int(tol) for m0 in OBS_MAGIC)

    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    shell_variants = [
        {"name": "model_magic", "magic": list(MODEL_MAGIC), "note": "S_shell uses model magic list (legacy in 7.13.15.*)."},
        {"name": "obs_magic", "magic": list(OBS_MAGIC), "note": "S_shell uses observed magic list (domain-independent mapping)."},
    ]

    a_by_zn_all: dict[tuple[int, int], int] = {}
    b_obs_all: dict[tuple[int, int], float] = {}
    b_pred_all: dict[tuple[int, int], float] = {}
    n_skipped = 0

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue
        I = float(int(N) - int(Z)) / float(A)

        a13 = float(A) ** (1.0 / 3.0)
        r_over_a13 = float(r0) + float(rI) * float(I)
        r_charge = float(r_over_a13) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        rho = float(A) / ((4.0 / 3.0) * math.pi * float(R_sharp) ** 3)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not math.isfinite(base_e):
                continue
            e_total = float(base_e) + float(c3_inf) * (float(rho) ** 2) + float(c_surf) / (6.0 * float(R_sharp))
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn_all[(int(Z), int(N))] = int(A)
        b_obs_all[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred_all[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not a_by_zn_all:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after radius-model expansion")

    # Candidate domain boundaries (same as Step 7.13.15.22).
    scan_a_mins = sorted({int(domain_min_a), 40, 60, 80, 100})
    scan_a_mins = [a for a in scan_a_mins if a >= int(domain_min_a)]

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def shell_S_factory(magic_list: list[int]):
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            return float(p * (p - g) / float(g))

        return shell_S

    def build_sep_n(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    def summarize_gaps(
        g_obs: dict[tuple[int, int, int], float],
        g_unc: dict[tuple[int, int, int], float],
        g_base: dict[tuple[int, int, int], float],
        g_cor: dict[tuple[int, int, int], float],
    ) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []
        rows_other: list[tuple[float, float, float]] = []
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            by_magic.setdefault(magic, []).append((resid_u, resid_b, resid_c))
            if magic in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        by_magic_rows: dict[str, dict[str, object]] = {}
        for m, rows in sorted(by_magic.items()):
            by_magic_rows[str(int(m))] = {
                "n": int(len(rows)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows)),
            }

        return {
            "train_magic": {
                "n": int(len(rows_train)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_train)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_train)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_train)),
            },
            "other_magic": {
                "n": int(len(rows_other)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_other)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_other)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_other)),
            },
            "by_magic": by_magic_rows,
        }

    def run_config(*, a_min: int, shell_magic: list[int]) -> dict[str, object]:
        # Domain slice
        a_by_zn = {zn: A for zn, A in a_by_zn_all.items() if int(A) >= int(a_min)}
        b_obs = {zn: b_obs_all[zn] for zn in a_by_zn.keys()}
        b_pred = {zn: b_pred_all[zn] for zn in a_by_zn.keys()}
        if not a_by_zn:
            raise RuntimeError(f"empty domain slice at A_min={a_min}")

        # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
        an_list: list[float] = []
        ap_list: list[float] = []
        for (Z, N), A in a_by_zn.items():
            if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
                continue
            if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
                dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
                if math.isfinite(dn):
                    an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
            if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
                dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
                if math.isfinite(dp):
                    ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
        a_n = _median(an_list)
        a_p = _median(ap_list)
        if not (math.isfinite(a_n) and math.isfinite(a_p) and a_n > 0 and a_p > 0):
            raise RuntimeError(f"pairing freeze failed (no OES samples) at A_min={a_min}")

        # Pairing baseline binding energies.
        b_base: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
            term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
            b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

        # Shell correction basis terms.
        shell_S = shell_S_factory(shell_magic)
        cN: dict[tuple[int, int], float] = {}
        cZ: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            hw = hw_mev(int(A))
            cN[(Z, N)] = float(hw) * float(shell_S(int(N)))
            cZ[(Z, N)] = float(hw) * float(shell_S(int(Z)))

        # Observables (obs).
        sn_obs = build_sep_n(a_by_zn, b_obs, dN=1)
        sp_obs = build_sep_p(a_by_zn, b_obs, dZ=1)
        gap_sn_obs = build_gap_n(sn_obs, step=1)
        gap_sp_obs = build_gap_p(sp_obs, step=1)

        # Predictions: uncorrected (B_pred), pairing-only (B_base).
        sn_pred_unc = build_sep_n(a_by_zn, b_pred, dN=1)
        sp_pred_unc = build_sep_p(a_by_zn, b_pred, dZ=1)
        sn_pred_base = build_sep_n(a_by_zn, b_base, dN=1)
        sp_pred_base = build_sep_p(a_by_zn, b_base, dZ=1)

        gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
        gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
        gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
        gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

        # Unit-basis maps for kN/kZ fits, around the pairing baseline.
        bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
        bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}
        gap_sn_pred_N1 = build_gap_n(build_sep_n(a_by_zn, bN1, dN=1), step=1)
        gap_sp_pred_Z1 = build_gap_p(build_sep_p(a_by_zn, bZ1, dZ=1), step=1)

        # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
        fit_n: list[tuple[float, float]] = []
        for (Z, N0, step), g_obs in gap_sn_obs.items():
            if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sn_pred_base.get((Z, N0, 1))
            g_1 = gap_sn_pred_N1.get((Z, N0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_n.append((y, x))
        if not fit_n:
            raise RuntimeError(f"no fit data for kN at A_min={a_min}")
        kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

        # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
        fit_z: list[tuple[float, float]] = []
        for (N, Z0, step), g_obs in gap_sp_obs.items():
            if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sp_pred_base.get((N, Z0, 1))
            g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_z.append((y, x))
        if not fit_z:
            raise RuntimeError(f"no fit data for kZ at A_min={a_min}")
        kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))
        ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

        # Corrected binding energies (pairing + refrozen shell).
        b_cor: dict[tuple[int, int], float] = {}
        for zn, b0 in b_base.items():
            b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

        # Corrected gap predictions.
        gap_sn_pred_cor = build_gap_n(build_sep_n(a_by_zn, b_cor, dN=1), step=1)
        gap_sp_pred_cor = build_gap_p(build_sep_p(a_by_zn, b_cor, dZ=1), step=1)

        diag_gap_sn = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor)
        diag_gap_sp = summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor)

        # Strict decision: train guardrail + other strict improvement (Sn and Sp).
        train_guard_mev = 0.5
        ok_train = (
            float(diag_gap_sn["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sn["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
            and float(diag_gap_sp["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sp["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
        )
        ok_other = (
            float(diag_gap_sn["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sn["other_magic"]["rms_resid_pairing_only_MeV"])
            and float(diag_gap_sp["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sp["other_magic"]["rms_resid_pairing_only_MeV"])
        )
        pass_strict = bool(ok_train and ok_other)

        return {
            "status": "ok",
            "domain_min_A": int(a_min),
            "n_in_domain": int(len(a_by_zn)),
            "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "n_samples_a_n": int(len(an_list)), "n_samples_a_p": int(len(ap_list))},
            "fit": {"kN": float(kN), "kZ": float(kZ), "kZ_over_kN": float(ratio_kZ_over_kN), "n_fit_pairs_kN": int(len(fit_n)), "n_fit_pairs_kZ": int(len(fit_z))},
            "gap_Sn": diag_gap_sn,
            "gap_Sp": diag_gap_sp,
            "decision": {"train_guard_mev": float(train_guard_mev), "pass_strict": bool(pass_strict)},
        }

    rows: list[dict[str, object]] = []
    for sv in shell_variants:
        shell_name = str(sv["name"])
        shell_magic = list(sv["magic"])
        for a_min in scan_a_mins:
            try:
                pack = run_config(a_min=int(a_min), shell_magic=shell_magic)
                pack["shell_variant"] = {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))}
                rows.append(pack)
            except Exception as e:
                rows.append(
                    {
                        "status": "skipped",
                        "shell_variant": {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))},
                        "domain_min_A": int(a_min),
                        "reason": str(e),
                    }
                )

    # CSV (flat table).
    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin.csv"
    header = [
        "shell_variant",
        "domain_min_A",
        "status",
        "n_in_domain",
        "a_n_MeV",
        "a_p_MeV",
        "kN",
        "kZ",
        "kZ_over_kN",
        "gap_Sn_train_n",
        "gap_Sn_train_rms_pairing_only_MeV",
        "gap_Sn_train_rms_pairing_shell_MeV",
        "gap_Sn_other_n",
        "gap_Sn_other_rms_pairing_only_MeV",
        "gap_Sn_other_rms_pairing_shell_MeV",
        "gap_Sp_train_n",
        "gap_Sp_train_rms_pairing_only_MeV",
        "gap_Sp_train_rms_pairing_shell_MeV",
        "gap_Sp_other_n",
        "gap_Sp_other_rms_pairing_only_MeV",
        "gap_Sp_other_rms_pairing_shell_MeV",
        "pass_strict",
        "reason",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            status = str(r.get("status", ""))
            sv = r.get("shell_variant") if isinstance(r.get("shell_variant"), dict) else {}
            name = str(sv.get("name", ""))
            domain_a = int(r.get("domain_min_A", -1))
            reason = str(r.get("reason", "")) if status != "ok" else ""
            n_in = int(r.get("n_in_domain", 0)) if status == "ok" else 0
            pairing = r.get("pairing") if isinstance(r.get("pairing"), dict) else {}
            fit = r.get("fit") if isinstance(r.get("fit"), dict) else {}
            gap_sn = r.get("gap_Sn") if isinstance(r.get("gap_Sn"), dict) else {}
            gap_sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
            spectro = r.get("spectro_e2plus") if isinstance(r.get("spectro_e2plus"), dict) else {}
            spec_sn = spectro.get("gap_Sn_peak") if isinstance(spectro.get("gap_Sn_peak"), dict) else {}
            spec_sp = spectro.get("gap_Sp_peak") if isinstance(spectro.get("gap_Sp_peak"), dict) else {}
            sn_tr = gap_sn.get("train_magic") if isinstance(gap_sn.get("train_magic"), dict) else {}
            sn_ot = gap_sn.get("other_magic") if isinstance(gap_sn.get("other_magic"), dict) else {}
            sp_tr = gap_sp.get("train_magic") if isinstance(gap_sp.get("train_magic"), dict) else {}
            sp_ot = gap_sp.get("other_magic") if isinstance(gap_sp.get("other_magic"), dict) else {}
            decision = r.get("decision") if isinstance(r.get("decision"), dict) else {}
            w.writerow(
                [
                    name,
                    domain_a,
                    status,
                    n_in,
                    f"{float(pairing.get('a_n_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(pairing.get('a_p_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kN', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ_over_kN', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    str(bool(decision.get("pass_strict", False))) if status == "ok" else "",
                    reason,
                ]
            )

    # Plot: delta RMS (shell - pairing) vs A_min for train/other and Sn/Sp.
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    fig, axes = plt.subplots(2, 2, figsize=(13, 7), constrained_layout=True)
    panels = [
        ("gap_Sn", "other_magic", axes[0][0], "ΔRMS other: gap Sn (shell - pairing)"),
        ("gap_Sp", "other_magic", axes[0][1], "ΔRMS other: gap Sp (shell - pairing)"),
        ("gap_Sn", "train_magic", axes[1][0], "ΔRMS train: gap Sn (shell - pairing)"),
        ("gap_Sp", "train_magic", axes[1][1], "ΔRMS train: gap Sp (shell - pairing)"),
    ]

    for sv in shell_variants:
        name = str(sv["name"])
        ok_rows = [r for r in rows if r.get("status") == "ok" and isinstance(r.get("shell_variant"), dict) and r["shell_variant"].get("name") == name]
        ok_rows = sorted(ok_rows, key=lambda x: int(x.get("domain_min_A", 0)))
        xs = [int(r.get("domain_min_A", 0)) for r in ok_rows]
        for kind, subset, ax, title in panels:
            ys: list[float] = []
            for r in ok_rows:
                g = r.get(kind) if isinstance(r.get(kind), dict) else {}
                sub = g.get(subset) if isinstance(g.get(subset), dict) else {}
                y = float(sub.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(sub.get("rms_resid_pairing_only_MeV", float("nan")))
                ys.append(float(y))
            ax.plot(xs, ys, marker="o", linestyle="-", label=name)
            ax.set_title(title)
            ax.set_xlabel("domain A_min")
            ax.set_ylabel("ΔRMS (MeV)")
            ax.axhline(0.0, color="k", linewidth=1.0, alpha=0.25)
            ax.grid(True, alpha=0.3)

    for ax in axes.flatten():
        ax.legend(fontsize=8)

    fig.suptitle("Phase 7 / Step 7.13.15.23: expanded-set shell-gap decision with isospin radius model", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin.png"
    fig.savefig(out_png, dpi=160)
    plt.close(fig)

    # Decision summary.
    ok_rows = [r for r in rows if r.get("status") == "ok"]
    n_pass = sum(1 for r in ok_rows if bool((r.get("decision") or {}).get("pass_strict", False)))

    # Best (most negative) ΔRMS for proton-other, to quantify whether the new DoF helps at all.
    best_sp_other = None
    for r in ok_rows:
        sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
        other = sp.get("other_magic") if isinstance(sp.get("other_magic"), dict) else {}
        if int(other.get("n", 0)) <= 0:
            continue
        delta = float(other.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(other.get("rms_resid_pairing_only_MeV", float("nan")))
        if not math.isfinite(delta):
            continue
        if best_sp_other is None or delta < best_sp_other["delta"]:
            best_sp_other = {"shell_variant": r.get("shell_variant"), "domain_min_A": int(r.get("domain_min_A", -1)), "delta": float(delta), "pair": float(other.get("rms_resid_pairing_only_MeV", float("nan"))), "shell": float(other.get("rms_resid_pairing_shell_MeV", float("nan"))), "n": int(other.get("n", 0))}

    conclusion = (
        f"strict_pass={n_pass}/{len(ok_rows)} over shell variants × A_min cuts. "
        "This step adds only a radii-only isospin correction to r_charge; if strict_pass==0 then "
        "proton-side other-magic gaps still require additional (independently frozen) many-body/structure DoF."
    )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.23",
                "scan": {"domain_min_A_base": int(domain_min_a), "domain_min_A_candidates": scan_a_mins, "shell_variants": shell_variants},
                "radius_model": {
                    "form": "r_charge = (r0 + rI*I)*A^(1/3), I=(N-Z)/A",
                    "r0_fm": float(r0),
                    "rI_fm": float(rI),
                    "fit_min_A": int(radius_fit_min_a),
                    "n_fit": int(len(fit_rows)),
                    "fit_rms_fm": float(fit_rms),
                    "mean_I_fit": float(mx),
                },
                "diag": {
                    "n_ame_total": int(len(ame_map)),
                    "n_in_domain_base": int(len(a_by_zn_all)),
                    "n_skipped_base": int(n_skipped),
                    "best_gap_Sp_other_delta": best_sp_other,
                    "conclusion": conclusion,
                },
                "results": rows,
                "inputs": {
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                    "metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_24(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.24 (initial): Add a proton-specific deterministic correction (Coulomb exchange; no free parameter)
    and re-run the expanded-set strict shell-gap decision scan.

    Outputs (fixed names):
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_exchange.png
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_exchange.csv
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_exchange_metrics.json
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if radius_fit_min_a < 1:
        raise SystemExit("[fail] radius_fit_min_a must be >= 1")

    # Frozen HF configuration (pn mix, etc).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)
    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    # Frozen surface-term fit (C3_inf, C_surf) from Step 7.13.15.7.
    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m7157 = _load_json(metrics_7157_path)
    fit_by_eq = m7157.get("fit_by_eq")
    if not isinstance(fit_by_eq, dict) or not fit_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: fit_by_eq missing/empty: {metrics_7157_path}")
    eq_labels = sorted(int(k) for k in fit_by_eq.keys() if str(k).isdigit())
    if not eq_labels:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: eq labels missing: {metrics_7157_path}")

    # Common potential inputs (eq18/eq19 sets).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    root = Path(__file__).resolve().parents[2]
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    # Use the same frozen radius model as Step 7.13.15.21 (baseline), to isolate the proton-side correction here.
    metrics_71521_path = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded_metrics.json"
    if not metrics_71521_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.21 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.21\n"
            f"Expected: {metrics_71521_path}"
        )
    m71521 = _load_json(metrics_71521_path)
    radius_model = m71521.get("radius_model") if isinstance(m71521.get("radius_model"), dict) else {}
    r0 = float(radius_model.get("r0_fm", float("nan")))
    fit_rms = float(radius_model.get("fit_rms_fm", float("nan")))
    n_fit = int(radius_model.get("n_fit", 0))
    if not (math.isfinite(r0) and r0 > 0):
        raise SystemExit(f"[fail] invalid radius_model.r0_fm in 7.13.15.21 metrics: {metrics_71521_path}")

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N) -> (A, B/A, sigma, symbol)
    ame_map: dict[tuple[int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N)] = {
            "A": int(A),
            "symbol": str(r.get("symbol", "")),
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
        }
    if not ame_map:
        raise SystemExit("[fail] AME2020 map is empty after parsing (unexpected)")

    # Fixed protocol (same structure as Step 7.13.15.22):
    # pairing OES freeze -> kN/kZ refreeze -> shell-gap strict decision.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    e2_mev_fm = 1.43996448

    def coulomb_exchange_slater_mev_per_a(*, Z: int, A: int, volume_fm3: float) -> float:
        """
        Coulomb exchange energy (Slater approximation) for a uniform proton gas in a volume V:
          E_x/V = -(3/4) (3/π)^(1/3) e^2 ρ_p^(4/3)
        Return per-nucleon (MeV per A).
        """
        if not (A > 0 and Z >= 0 and math.isfinite(volume_fm3) and volume_fm3 > 0):
            return float("nan")
        if Z <= 0:
            return 0.0
        rho_p = float(Z) / float(volume_fm3)
        if not (math.isfinite(rho_p) and rho_p > 0):
            return float("nan")
        coef = -(3.0 / 4.0) * ((3.0 / math.pi) ** (1.0 / 3.0)) * float(e2_mev_fm)
        e_density = float(coef) * (float(rho_p) ** (4.0 / 3.0))  # MeV fm^-3
        e_total = float(e_density) * float(volume_fm3)  # MeV
        return float(e_total) / float(A)

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    OBS_MAGIC_SET = {int(x) for x in OBS_MAGIC}
    TRAIN_MAGIC = {50, 82}
    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    shell_variants = [
        {"name": "model_magic", "magic": list(MODEL_MAGIC), "note": "S_shell uses model magic list (legacy in 7.13.15.*)."},
        {"name": "obs_magic", "magic": list(OBS_MAGIC), "note": "S_shell uses observed magic list (domain-independent mapping)."},
    ]

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        return any(abs(int(x) - int(m0)) <= int(tol) for m0 in OBS_MAGIC)

    # Predict B (total) for the expanded AME2020 set using the frozen radius model + Coulomb exchange.
    a_by_zn_all: dict[tuple[int, int], int] = {}
    b_obs_all: dict[tuple[int, int], float] = {}
    b_pred_all: dict[tuple[int, int], float] = {}
    n_skipped = 0

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue

        a13 = float(A) ** (1.0 / 3.0)
        r_charge = float(r0) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho = float(A) / float(V_sphere)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not math.isfinite(base_e):
                continue
            e_cx = coulomb_exchange_slater_mev_per_a(Z=int(Z), A=int(A), volume_fm3=float(V_sphere))
            if not math.isfinite(e_cx):
                continue
            e_total = float(base_e) + float(e_cx) + float(c3_inf) * (float(rho) ** 2) + float(c_surf) / (6.0 * float(R_sharp))
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn_all[(int(Z), int(N))] = int(A)
        b_obs_all[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred_all[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not a_by_zn_all:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after radius-model prediction")

    # Candidate domain boundaries (same as Step 7.13.15.22).
    scan_a_mins = sorted({int(domain_min_a), 40, 60, 80, 100})
    scan_a_mins = [a for a in scan_a_mins if a >= int(domain_min_a)]

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    def shell_S_factory(magic_list: list[int]):
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            return float(p * (p - g) / float(g))

        return shell_S

    def shell_S_radius_factory(magic_list: list[int]):
        """
        A radius-friendly normalization of the bounded occupancy function:
          S = p(p-g)/g^2  within shell [Mk, Mk1] (0..g), so S in [-1/4, 0] independent of g.
        """
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            denom = float(g) * float(g)
            if not (math.isfinite(denom) and denom > 0):
                return 0.0
            return float(p * (p - g) / float(denom))

        return shell_S

    radii_shell_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_shell(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit a single shell/structure DoF in the radius mapping using IAEA charge radii only.

          r_charge = r_base + r_shell * (S(N) + S(Z))

        where r_base uses the frozen (r0,rI) from Step 7.13.15.23 and
        S(x)=p(p-g)/g^2 is computed on the provided magic list.
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {"status": "skipped", "reason": "radii_by_zn is empty", "r_shell_fm": 0.0, "n_fit": 0}
            radii_shell_fit_cache[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))

        num = 0.0
        den = 0.0
        rows_fit: list[tuple[float, float, float, float]] = []  # (r_obs, r_base, sigma, s_sum)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            s_sum = float(shell_S_r(int(N)) + shell_S_r(int(Z)))
            if not math.isfinite(s_sum):
                counts["skipped"] += 1
                continue
            if abs(float(s_sum)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            num += float(w) * float(s_sum) * (float(r_obs) - float(base))
            den += float(w) * float(s_sum) * float(s_sum)
            rows_fit.append((float(r_obs), float(base), float(sig), float(s_sum)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        r_shell = float(num / den) if (math.isfinite(den) and den > 0.0 and math.isfinite(num)) else 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, s_sum in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_shell.append((float(base) + float(r_shell) * float(s_sum) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_shell*(S(N)+S(Z))",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_shell_fm": float(r_shell),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
        }
        radii_shell_fit_cache[key] = out
        return out

    # Helpers for separations and gaps.
    def build_sep_n(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    def summarize_gaps(
        g_obs: dict[tuple[int, int, int], float],
        g_unc: dict[tuple[int, int, int], float],
        g_base: dict[tuple[int, int, int], float],
        g_cor: dict[tuple[int, int, int], float],
    ) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []
        rows_other: list[tuple[float, float, float]] = []
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            by_magic.setdefault(magic, []).append((resid_u, resid_b, resid_c))
            if magic in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        by_magic_rows: dict[str, dict[str, object]] = {}
        for m, rows in sorted(by_magic.items()):
            by_magic_rows[str(int(m))] = {
                "n": int(len(rows)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows)),
            }

        return {
            "train_magic": {
                "n": int(len(rows_train)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_train)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_train)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_train)),
            },
            "other_magic": {
                "n": int(len(rows_other)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_other)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_other)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_other)),
            },
            "by_magic": by_magic_rows,
        }

    def run_config(*, a_min: int, shell_magic: list[int]) -> dict[str, object]:
        # Domain slice
        a_by_zn = {zn: A for zn, A in a_by_zn_all.items() if int(A) >= int(a_min)}
        b_obs = {zn: b_obs_all[zn] for zn in a_by_zn.keys()}
        b_pred = {zn: b_pred_all[zn] for zn in a_by_zn.keys()}
        if not a_by_zn:
            raise RuntimeError(f"empty domain slice at A_min={a_min}")

        # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
        an_list: list[float] = []
        ap_list: list[float] = []
        for (Z, N), A in a_by_zn.items():
            if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
                continue
            if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
                dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
                if math.isfinite(dn):
                    an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
            if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
                dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
                if math.isfinite(dp):
                    ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
        a_n = _median(an_list)
        a_p = _median(ap_list)
        if not (math.isfinite(a_n) and math.isfinite(a_p)):
            raise RuntimeError(f"pairing freeze failed (no OES samples) at A_min={a_min}")

        # Pairing baseline binding energies.
        b_base: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
            term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
            b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

        # Shell correction basis terms.
        shell_S = shell_S_factory(shell_magic)
        cN: dict[tuple[int, int], float] = {}
        cZ: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            hw = hw_mev(int(A))
            cN[(Z, N)] = float(hw) * float(shell_S(int(N)))
            cZ[(Z, N)] = float(hw) * float(shell_S(int(Z)))

        # Observables (obs).
        sn_obs = build_sep_n(a_by_zn, b_obs, dN=1)
        sp_obs = build_sep_p(a_by_zn, b_obs, dZ=1)
        gap_sn_obs = build_gap_n(sn_obs, step=1)
        gap_sp_obs = build_gap_p(sp_obs, step=1)

        # Predictions: uncorrected (B_pred), pairing-only (B_base).
        sn_pred_unc = build_sep_n(a_by_zn, b_pred, dN=1)
        sp_pred_unc = build_sep_p(a_by_zn, b_pred, dZ=1)
        sn_pred_base = build_sep_n(a_by_zn, b_base, dN=1)
        sp_pred_base = build_sep_p(a_by_zn, b_base, dZ=1)

        gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
        gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
        gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
        gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

        # Unit-basis maps for kN/kZ fits, around the pairing baseline.
        bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
        bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}
        gap_sn_pred_N1 = build_gap_n(build_sep_n(a_by_zn, bN1, dN=1), step=1)
        gap_sp_pred_Z1 = build_gap_p(build_sep_p(a_by_zn, bZ1, dZ=1), step=1)

        # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
        fit_n: list[tuple[float, float]] = []
        for (Z, N0, step), g_obs in gap_sn_obs.items():
            if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sn_pred_base.get((Z, N0, 1))
            g_1 = gap_sn_pred_N1.get((Z, N0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_n.append((y, x))
        if not fit_n:
            raise RuntimeError(f"no fit data for kN at A_min={a_min}")
        kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

        # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
        fit_z: list[tuple[float, float]] = []
        for (N, Z0, step), g_obs in gap_sp_obs.items():
            if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sp_pred_base.get((N, Z0, 1))
            g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_z.append((y, x))
        if not fit_z:
            raise RuntimeError(f"no fit data for kZ at A_min={a_min}")
        kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))
        ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

        # Corrected binding energies (pairing + refrozen shell).
        b_cor: dict[tuple[int, int], float] = {}
        for zn, b0 in b_base.items():
            b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

        # Corrected gap predictions.
        gap_sn_pred_cor = build_gap_n(build_sep_n(a_by_zn, b_cor, dN=1), step=1)
        gap_sp_pred_cor = build_gap_p(build_sep_p(a_by_zn, b_cor, dZ=1), step=1)

        diag_gap_sn = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor)
        diag_gap_sp = summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor)

        # Strict decision: train guardrail + other strict improvement (Sn and Sp).
        train_guard_mev = 0.5
        ok_train = (
            float(diag_gap_sn["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sn["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
            and float(diag_gap_sp["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sp["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
        )
        ok_other = (
            float(diag_gap_sn["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sn["other_magic"]["rms_resid_pairing_only_MeV"])
            and float(diag_gap_sp["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sp["other_magic"]["rms_resid_pairing_only_MeV"])
        )
        pass_strict = bool(ok_train and ok_other)

        return {
            "status": "ok",
            "domain_min_A": int(a_min),
            "n_in_domain": int(len(a_by_zn)),
            "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "n_samples_a_n": int(len(an_list)), "n_samples_a_p": int(len(ap_list))},
            "fit": {"kN": float(kN), "kZ": float(kZ), "kZ_over_kN": float(ratio_kZ_over_kN), "n_fit_pairs_kN": int(len(fit_n)), "n_fit_pairs_kZ": int(len(fit_z))},
            "gap_Sn": diag_gap_sn,
            "gap_Sp": diag_gap_sp,
            "decision": {"train_guard_mev": float(train_guard_mev), "pass_strict": bool(pass_strict)},
        }

    rows: list[dict[str, object]] = []
    for sv in shell_variants:
        shell_name = str(sv["name"])
        shell_magic = list(sv["magic"])
        for a_min in scan_a_mins:
            try:
                pack = run_config(a_min=int(a_min), shell_magic=shell_magic)
                pack["shell_variant"] = {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))}
                rows.append(pack)
            except Exception as e:
                rows.append(
                    {
                        "status": "skipped",
                        "shell_variant": {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))},
                        "domain_min_A": int(a_min),
                        "reason": str(e),
                    }
                )

    # CSV (flat table).
    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_exchange.csv"
    header = [
        "shell_variant",
        "domain_min_A",
        "status",
        "n_in_domain",
        "a_n_MeV",
        "a_p_MeV",
        "kN",
        "kZ",
        "kZ_over_kN",
        "gap_Sn_train_n",
        "gap_Sn_train_rms_pairing_only_MeV",
        "gap_Sn_train_rms_pairing_shell_MeV",
        "gap_Sn_other_n",
        "gap_Sn_other_rms_pairing_only_MeV",
        "gap_Sn_other_rms_pairing_shell_MeV",
        "gap_Sp_train_n",
        "gap_Sp_train_rms_pairing_only_MeV",
        "gap_Sp_train_rms_pairing_shell_MeV",
        "gap_Sp_other_n",
        "gap_Sp_other_rms_pairing_only_MeV",
        "gap_Sp_other_rms_pairing_shell_MeV",
        "pass_strict",
        "reason",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            status = str(r.get("status", ""))
            sv = r.get("shell_variant") if isinstance(r.get("shell_variant"), dict) else {}
            name = str(sv.get("name", ""))
            domain_a = int(r.get("domain_min_A", -1))
            reason = str(r.get("reason", "")) if status != "ok" else ""
            n_in = int(r.get("n_in_domain", 0)) if status == "ok" else 0
            pairing = r.get("pairing") if isinstance(r.get("pairing"), dict) else {}
            fit = r.get("fit") if isinstance(r.get("fit"), dict) else {}
            gap_sn = r.get("gap_Sn") if isinstance(r.get("gap_Sn"), dict) else {}
            gap_sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
            spectro = r.get("spectro_e2plus") if isinstance(r.get("spectro_e2plus"), dict) else {}
            spec_sn = spectro.get("gap_Sn_peak") if isinstance(spectro.get("gap_Sn_peak"), dict) else {}
            spec_sp = spectro.get("gap_Sp_peak") if isinstance(spectro.get("gap_Sp_peak"), dict) else {}
            sn_tr = gap_sn.get("train_magic") if isinstance(gap_sn.get("train_magic"), dict) else {}
            sn_ot = gap_sn.get("other_magic") if isinstance(gap_sn.get("other_magic"), dict) else {}
            sp_tr = gap_sp.get("train_magic") if isinstance(gap_sp.get("train_magic"), dict) else {}
            sp_ot = gap_sp.get("other_magic") if isinstance(gap_sp.get("other_magic"), dict) else {}
            decision = r.get("decision") if isinstance(r.get("decision"), dict) else {}
            w.writerow(
                [
                    name,
                    domain_a,
                    status,
                    n_in,
                    f"{float(pairing.get('a_n_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(pairing.get('a_p_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kN', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ_over_kN', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    str(bool(decision.get("pass_strict", False))) if status == "ok" else "",
                    reason,
                ]
            )

    # Plot: delta RMS (shell - pairing) vs A_min for train/other and Sn/Sp.
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    fig, axes = plt.subplots(2, 2, figsize=(13, 7), constrained_layout=True)
    panels = [
        ("gap_Sn", "other_magic", axes[0][0], "ΔRMS other: gap Sn (shell - pairing)"),
        ("gap_Sp", "other_magic", axes[0][1], "ΔRMS other: gap Sp (shell - pairing)"),
        ("gap_Sn", "train_magic", axes[1][0], "ΔRMS train: gap Sn (shell - pairing)"),
        ("gap_Sp", "train_magic", axes[1][1], "ΔRMS train: gap Sp (shell - pairing)"),
    ]

    for sv in shell_variants:
        name = str(sv["name"])
        ok_rows = [r for r in rows if r.get("status") == "ok" and isinstance(r.get("shell_variant"), dict) and r["shell_variant"].get("name") == name]
        ok_rows = sorted(ok_rows, key=lambda x: int(x.get("domain_min_A", 0)))
        xs = [int(r.get("domain_min_A", 0)) for r in ok_rows]
        for kind, subset, ax, title in panels:
            ys: list[float] = []
            for r in ok_rows:
                g = r.get(kind) if isinstance(r.get(kind), dict) else {}
                sub = g.get(subset) if isinstance(g.get(subset), dict) else {}
                y = float(sub.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(sub.get("rms_resid_pairing_only_MeV", float("nan")))
                ys.append(float(y))
            ax.plot(xs, ys, marker="o", linestyle="-", label=name)
            ax.set_title(title)
            ax.set_xlabel("domain A_min")
            ax.set_ylabel("ΔRMS (MeV)")
            ax.axhline(0.0, color="k", linewidth=1.0, alpha=0.25)
            ax.grid(True, alpha=0.3)

    for ax in axes.flatten():
        ax.legend(fontsize=8)

    fig.suptitle("Phase 7 / Step 7.13.15.24: expanded-set shell-gap decision with Coulomb exchange (Slater)", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_exchange.png"
    fig.savefig(out_png, dpi=160)
    plt.close(fig)

    # Decision summary.
    ok_rows = [r for r in rows if r.get("status") == "ok"]
    n_pass = sum(1 for r in ok_rows if bool((r.get("decision") or {}).get("pass_strict", False)))

    # Best (most negative) ΔRMS for proton-other, to quantify whether this deterministic correction helps at all.
    best_sp_other = None
    for r in ok_rows:
        sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
        other = sp.get("other_magic") if isinstance(sp.get("other_magic"), dict) else {}
        if int(other.get("n", 0)) <= 0:
            continue
        delta = float(other.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(other.get("rms_resid_pairing_only_MeV", float("nan")))
        if not math.isfinite(delta):
            continue
        if best_sp_other is None or delta < best_sp_other["delta"]:
            best_sp_other = {
                "shell_variant": r.get("shell_variant"),
                "domain_min_A": int(r.get("domain_min_A", -1)),
                "delta": float(delta),
                "pair": float(other.get("rms_resid_pairing_only_MeV", float("nan"))),
                "shell": float(other.get("rms_resid_pairing_shell_MeV", float("nan"))),
                "n": int(other.get("n", 0)),
            }

    conclusion = (
        f"strict_pass={n_pass}/{len(ok_rows)} over shell variants × A_min cuts. "
        "This step adds Coulomb exchange (Slater, no free parameter) on top of the frozen HF+surface-term energy model. "
        "If strict_pass==0, proton-side other-magic gaps still require additional independently frozen many-body/structure DoF."
    )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_exchange_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.24",
                "scan": {"domain_min_A_base": int(domain_min_a), "domain_min_A_candidates": scan_a_mins, "shell_variants": shell_variants},
                "radius_model": {
                    "form": "r_charge = r0*A^(1/3) (frozen from 7.13.15.21 metrics)",
                    "r0_fm": float(r0),
                    "fit_min_A": int(radius_fit_min_a),
                    "n_fit": int(n_fit),
                    "fit_rms_fm": float(fit_rms),
                    "frozen_from_metrics": str(metrics_71521_path),
                },
                "coulomb_exchange": {
                    "model": "Slater uniform proton gas",
                    "formula": "E_x/V = -(3/4)(3/pi)^(1/3) e^2 rho_p^(4/3)",
                    "e2_MeV_fm": float(e2_mev_fm),
                },
                "diag": {
                    "n_ame_total": int(len(ame_map)),
                    "n_in_domain_base": int(len(a_by_zn_all)),
                    "n_skipped_base": int(n_skipped),
                    "best_gap_Sp_other_delta": best_sp_other,
                    "conclusion": conclusion,
                },
                "results": rows,
                "inputs": {
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                    "metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_21": {"path": str(metrics_71521_path), "sha256": _sha256(metrics_71521_path)},
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_25(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.25 (initial): Add proton-specific deterministic Coulomb/finite-size corrections
    and re-run the expanded-set strict shell-gap decision scan.

    Outputs (fixed names):
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_finite_size.png
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_finite_size.csv
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_finite_size_metrics.json
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if radius_fit_min_a < 1:
        raise SystemExit("[fail] radius_fit_min_a must be >= 1")

    # Frozen HF configuration (pn mix, etc).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)
    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    # Frozen surface-term fit (C3_inf, C_surf) from Step 7.13.15.7.
    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m7157 = _load_json(metrics_7157_path)
    fit_by_eq = m7157.get("fit_by_eq")
    if not isinstance(fit_by_eq, dict) or not fit_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: fit_by_eq missing/empty: {metrics_7157_path}")
    eq_labels = sorted(int(k) for k in fit_by_eq.keys() if str(k).isdigit())
    if not eq_labels:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: eq labels missing: {metrics_7157_path}")

    # Common potential inputs (eq18/eq19 sets).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    root = Path(__file__).resolve().parents[2]
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    # Use the same frozen radius model as Step 7.13.15.21 (baseline), to isolate the finite-size correction here.
    metrics_71521_path = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_coverage_expanded_metrics.json"
    if not metrics_71521_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.21 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.21\n"
            f"Expected: {metrics_71521_path}"
        )
    m71521 = _load_json(metrics_71521_path)
    radius_model = m71521.get("radius_model") if isinstance(m71521.get("radius_model"), dict) else {}
    r0 = float(radius_model.get("r0_fm", float("nan")))
    fit_rms = float(radius_model.get("fit_rms_fm", float("nan")))
    n_fit = int(radius_model.get("n_fit", 0))
    if not (math.isfinite(r0) and r0 > 0):
        raise SystemExit(f"[fail] invalid radius_model.r0_fm in 7.13.15.21 metrics: {metrics_71521_path}")

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N) -> (A, B/A, sigma, symbol)
    ame_map: dict[tuple[int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N)] = {
            "A": int(A),
            "symbol": str(r.get("symbol", "")),
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
        }
    if not ame_map:
        raise SystemExit("[fail] AME2020 map is empty after parsing (unexpected)")

    # Deterministic finite-size Coulomb model:
    # - direct: 2pF profile (fixed diffuseness a), c determined per-A from r_rms
    # - exchange: Slater (LDA) on the same non-uniform density
    e2_mev_fm = 1.43996448
    coef_slater = -(3.0 / 4.0) * ((3.0 / math.pi) ** (1.0 / 3.0))
    fourpi_m13 = (4.0 * math.pi) ** (-1.0 / 3.0)
    a_diff_fm = 0.523
    dr_fm = 0.02

    finite_cache: dict[int, dict[str, float]] = {}

    def finite_size_coeffs_for_A(A: int) -> dict[str, float]:
        if int(A) in finite_cache:
            return finite_cache[int(A)]
        if A <= 0:
            raise RuntimeError("A must be positive")

        a13 = float(A) ** (1.0 / 3.0)
        r_rms = float(r0) * float(a13)
        if not (math.isfinite(r_rms) and r_rms > 0):
            raise RuntimeError(f"invalid r_rms for A={A}")

        c_guess2 = (5.0 / 3.0) * (r_rms**2) - (7.0 / 3.0) * ((math.pi * float(a_diff_fm)) ** 2)
        c_guess = math.sqrt(c_guess2) if c_guess2 > 0 else max(0.1, float(r_rms) * 0.5)

        def rms_from_c(c_fm: float) -> float:
            if not (math.isfinite(c_fm) and c_fm > 0):
                return float("nan")
            r_max = max(20.0, 3.0 * float(r_rms) + 20.0 * float(a_diff_fm))
            n = int(math.ceil(r_max / float(dr_fm)))
            I2 = 0.0
            I4 = 0.0
            for i in range(n):
                r = (float(i) + 0.5) * float(dr_fm)
                f = 1.0 / (1.0 + math.exp((float(r) - float(c_fm)) / float(a_diff_fm)))
                r2 = float(r) * float(r)
                I2 += r2 * float(f)
                I4 += (r2 * r2) * float(f)
            I2 *= float(dr_fm)
            I4 *= float(dr_fm)
            if not (math.isfinite(I2) and I2 > 0 and math.isfinite(I4) and I4 > 0):
                return float("nan")
            return math.sqrt(float(I4) / float(I2))

        # Bracket and bisection (few iterations; cached per-A).
        lo = max(0.05, 0.25 * float(c_guess))
        hi = max(lo * 1.1, 3.0 * float(c_guess) + 10.0 * float(a_diff_fm))
        target = float(r_rms)
        for _ in range(6):
            r_lo = rms_from_c(lo)
            r_hi = rms_from_c(hi)
            if not (math.isfinite(r_lo) and math.isfinite(r_hi)):
                hi *= 1.5
                continue
            if r_lo <= target <= r_hi:
                break
            if target < r_lo:
                lo *= 0.7
            else:
                hi *= 1.5

        c = float(c_guess)
        for _ in range(18):
            mid = 0.5 * (float(lo) + float(hi))
            r_mid = rms_from_c(mid)
            if not math.isfinite(r_mid):
                break
            c = float(mid)
            if r_mid < target:
                lo = float(mid)
            else:
                hi = float(mid)

        # Coefficients for the final c.
        r_max = max(20.0, 3.0 * float(r_rms) + 20.0 * float(a_diff_fm))
        n = int(math.ceil(r_max / float(dr_fm)))
        rs: list[float] = []
        fs: list[float] = []
        g2: list[float] = []
        h1: list[float] = []
        I2 = 0.0
        I2_43 = 0.0
        for i in range(n):
            r = (float(i) + 0.5) * float(dr_fm)
            f = 1.0 / (1.0 + math.exp((float(r) - float(c)) / float(a_diff_fm)))
            rs.append(float(r))
            fs.append(float(f))
            r2 = float(r) * float(r)
            g2_i = r2 * float(f)
            g2.append(float(g2_i))
            h1.append(float(r) * float(f))
            I2 += float(g2_i)
            I2_43 += float(r2) * (float(f) ** (4.0 / 3.0))
        I2 *= float(dr_fm)
        I2_43 *= float(dr_fm)
        if not (math.isfinite(I2) and I2 > 0 and math.isfinite(I2_43) and I2_43 > 0):
            raise RuntimeError(f"finite-size integrals failed for A={A}")

        # A0(r)=∫_0^r f(r') r'^2 dr'  and  B0(r)=∫_r^∞ f(r') r' dr'  (no 4π).
        A0: list[float] = []
        acc = 0.0
        for v in g2:
            acc += float(v) * float(dr_fm)
            A0.append(float(acc))
        B0 = [0.0] * n
        acc = 0.0
        for i in range(n - 1, -1, -1):
            acc += float(h1[i]) * float(dr_fm)
            B0[i] = float(acc)

        J = 0.0
        for r, f, a0, b0 in zip(rs, fs, A0, B0, strict=True):
            J += (float(r) * float(f) * float(a0) + (float(r) ** 2) * float(f) * float(b0))
        J *= float(dr_fm)

        e_dir_unit_over_e2 = 0.5 * float(J) / (float(I2) ** 2)  # [fm^-1]
        i43_unit = float(fourpi_m13) * float(I2_43) / (float(I2) ** (4.0 / 3.0))  # [fm^-1]
        rms_check = rms_from_c(float(c))

        out = {
            "r_rms_fm": float(r_rms),
            "c_fm": float(c),
            "rms_check_fm": float(rms_check) if math.isfinite(rms_check) else float("nan"),
            "e_dir_unit_over_e2_fm_1": float(e_dir_unit_over_e2),
            "i43_unit_fm_1": float(i43_unit),
        }
        finite_cache[int(A)] = out
        return out

    # Predict B (total) for the expanded AME2020 set using the frozen radius model + Coulomb finite-size correction.
    a_by_zn_all: dict[tuple[int, int], int] = {}
    b_obs_all: dict[tuple[int, int], float] = {}
    b_pred_all: dict[tuple[int, int], float] = {}
    n_skipped = 0

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue

        a13 = float(A) ** (1.0 / 3.0)
        r_charge = float(r0) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho = float(A) / float(V_sphere)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        cpack = finite_size_coeffs_for_A(int(A))
        e_dir_unit = float(cpack["e_dir_unit_over_e2_fm_1"])
        i43_unit = float(cpack["i43_unit_fm_1"])

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            e_coul_uniform = float(base_pack.get("Coul", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not (math.isfinite(base_e) and math.isfinite(e_coul_uniform)):
                continue

            # Replace uniform-sphere Coulomb direct with 2pF direct, and add 2pF Slater exchange (LDA).
            if int(Z) <= 1:
                e_dir_fs = 0.0
                e_x_fs = 0.0
            else:
                e_dir_fs = float(e2_mev_fm) * float(Z * (Z - 1)) * float(e_dir_unit) / float(A)
                e_x_fs = float(coef_slater) * float(e2_mev_fm) * (float(Z) ** (4.0 / 3.0)) * float(i43_unit) / float(A)

            e_coul_fs = (float(e_dir_fs) - float(e_coul_uniform)) + float(e_x_fs)
            e_surf = float(c_surf) / (6.0 * float(R_sharp)) * float(surface_factor)
            e_total = float(base_e) + float(e_coul_fs) + float(c3_inf) * (float(rho) ** 2) + float(e_surf)
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn_all[(int(Z), int(N))] = int(A)
        b_obs_all[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred_all[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not a_by_zn_all:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after radius-model prediction")

    # Candidate domain boundaries (same as Step 7.13.15.22).
    scan_a_mins = sorted({int(domain_min_a), 40, 60, 80, 100})
    scan_a_mins = [a for a in scan_a_mins if a >= int(domain_min_a)]

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    OBS_MAGIC_SET = {int(x) for x in OBS_MAGIC}
    TRAIN_MAGIC = {50, 82}
    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    shell_variants = [
        {"name": "model_magic", "magic": list(MODEL_MAGIC), "note": "S_shell uses model magic list (legacy in 7.13.15.*)."},
        {"name": "obs_magic", "magic": list(OBS_MAGIC), "note": "S_shell uses observed magic list (domain-independent mapping)."},
    ]

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        return any(abs(int(x) - int(m0)) <= int(tol) for m0 in OBS_MAGIC)

    def shell_S_factory(magic_list: list[int]):
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            return float(p * (p - g) / float(g))

        return shell_S

    def shell_S_radius_factory(magic_list: list[int]):
        """
        Radius-friendly normalization of the bounded occupancy function:
          S = p(p-g)/g^2  within shell [Mk, Mk1] (0..g), so S in [-1/4, 0] independent of g.
        """
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            denom = float(g) * float(g)
            if not (math.isfinite(denom) and denom > 0):
                return 0.0
            return float(p * (p - g) / float(denom))

        return shell_S

    radii_shell_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_shell(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit a single shell/structure DoF in the radius mapping using IAEA charge radii only.

          r_charge = r_base + r_shell * (S(N) + S(Z))

        where r_base uses the frozen (r0,rI) from Step 7.13.15.23 and
        S(x)=p(p-g)/g^2 is computed on the provided magic list.
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {"status": "skipped", "reason": "radii_by_zn is empty", "r_shell_fm": 0.0, "n_fit": 0}
            radii_shell_fit_cache[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))

        num = 0.0
        den = 0.0
        rows_fit: list[tuple[float, float, float, float]] = []  # (r_obs, r_base, sigma, s_sum)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            s_sum = float(shell_S_r(int(N)) + shell_S_r(int(Z)))
            if not math.isfinite(s_sum):
                counts["skipped"] += 1
                continue
            if abs(float(s_sum)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            num += float(w) * float(s_sum) * (float(r_obs) - float(base))
            den += float(w) * float(s_sum) * float(s_sum)
            rows_fit.append((float(r_obs), float(base), float(sig), float(s_sum)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        r_shell = float(num / den) if (math.isfinite(den) and den > 0.0 and math.isfinite(num)) else 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, s_sum in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_shell.append((float(base) + float(r_shell) * float(s_sum) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_shell*(S(N)+S(Z))",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_shell_fm": float(r_shell),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
        }
        radii_shell_fit_cache[key] = out
        return out

    # Helpers for separations and gaps.
    def build_sep_n(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    def summarize_gaps(
        g_obs: dict[tuple[int, int, int], float],
        g_unc: dict[tuple[int, int, int], float],
        g_base: dict[tuple[int, int, int], float],
        g_cor: dict[tuple[int, int, int], float],
    ) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []
        rows_other: list[tuple[float, float, float]] = []
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            by_magic.setdefault(magic, []).append((resid_u, resid_b, resid_c))
            if magic in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        by_magic_rows: dict[str, dict[str, object]] = {}
        for m, rows in sorted(by_magic.items()):
            by_magic_rows[str(int(m))] = {
                "n": int(len(rows)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows)),
            }

        return {
            "train_magic": {
                "n": int(len(rows_train)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_train)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_train)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_train)),
            },
            "other_magic": {
                "n": int(len(rows_other)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_other)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_other)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_other)),
            },
            "by_magic": by_magic_rows,
        }

    # Run the same frozen protocol as Step 7.13.15.22 on the expanded set.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def run_config(*, a_min: int, shell_magic: list[int]) -> dict[str, object]:
        # Domain slice
        a_by_zn = {zn: A for zn, A in a_by_zn_all.items() if int(A) >= int(a_min)}
        b_obs = {zn: b_obs_all[zn] for zn in a_by_zn.keys()}
        b_pred = {zn: b_pred_all[zn] for zn in a_by_zn.keys()}
        if not a_by_zn:
            raise RuntimeError(f"empty domain slice at A_min={a_min}")

        # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
        an_list: list[float] = []
        ap_list: list[float] = []
        for (Z, N), A in a_by_zn.items():
            if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
                continue
            if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
                dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
                if math.isfinite(dn):
                    an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
            if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
                dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
                if math.isfinite(dp):
                    ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
        a_n = _median(an_list)
        a_p = _median(ap_list)
        if not (math.isfinite(a_n) and math.isfinite(a_p)):
            raise RuntimeError(f"pairing freeze failed (no OES samples) at A_min={a_min}")

        # Pairing baseline binding energies.
        b_base: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
            term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
            b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

        # Shell correction basis terms.
        shell_S = shell_S_factory(shell_magic)
        cN: dict[tuple[int, int], float] = {}
        cZ: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            hw = hw_mev(int(A))
            cN[(Z, N)] = float(hw) * float(shell_S(int(N)))
            cZ[(Z, N)] = float(hw) * float(shell_S(int(Z)))

        # Observables (obs).
        sn_obs = build_sep_n(a_by_zn, b_obs, dN=1)
        sp_obs = build_sep_p(a_by_zn, b_obs, dZ=1)
        gap_sn_obs = build_gap_n(sn_obs, step=1)
        gap_sp_obs = build_gap_p(sp_obs, step=1)

        # Predictions: uncorrected (B_pred), pairing-only (B_base).
        sn_pred_unc = build_sep_n(a_by_zn, b_pred, dN=1)
        sp_pred_unc = build_sep_p(a_by_zn, b_pred, dZ=1)
        sn_pred_base = build_sep_n(a_by_zn, b_base, dN=1)
        sp_pred_base = build_sep_p(a_by_zn, b_base, dZ=1)

        gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
        gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
        gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
        gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

        # Unit-basis maps for kN/kZ fits, around the pairing baseline.
        bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
        bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}
        gap_sn_pred_N1 = build_gap_n(build_sep_n(a_by_zn, bN1, dN=1), step=1)
        gap_sp_pred_Z1 = build_gap_p(build_sep_p(a_by_zn, bZ1, dZ=1), step=1)

        # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
        fit_n: list[tuple[float, float]] = []
        for (Z, N0, step), g_obs in gap_sn_obs.items():
            if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sn_pred_base.get((Z, N0, 1))
            g_1 = gap_sn_pred_N1.get((Z, N0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_n.append((y, x))
        if not fit_n:
            raise RuntimeError(f"no fit data for kN at A_min={a_min}")
        kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

        # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
        fit_z: list[tuple[float, float]] = []
        for (N, Z0, step), g_obs in gap_sp_obs.items():
            if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sp_pred_base.get((N, Z0, 1))
            g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_z.append((y, x))
        if not fit_z:
            raise RuntimeError(f"no fit data for kZ at A_min={a_min}")
        kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))
        ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

        # Corrected binding energies (pairing + refrozen shell).
        b_cor: dict[tuple[int, int], float] = {}
        for zn, b0 in b_base.items():
            b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

        # Corrected gap predictions.
        gap_sn_pred_cor = build_gap_n(build_sep_n(a_by_zn, b_cor, dN=1), step=1)
        gap_sp_pred_cor = build_gap_p(build_sep_p(a_by_zn, b_cor, dZ=1), step=1)

        diag_gap_sn = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor)
        diag_gap_sp = summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor)

        # Strict decision: train guardrail + other strict improvement (Sn and Sp).
        train_guard_mev = 0.5
        ok_train = (
            float(diag_gap_sn["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sn["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
            and float(diag_gap_sp["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sp["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
        )
        ok_other = (
            float(diag_gap_sn["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sn["other_magic"]["rms_resid_pairing_only_MeV"])
            and float(diag_gap_sp["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sp["other_magic"]["rms_resid_pairing_only_MeV"])
        )
        pass_strict = bool(ok_train and ok_other)

        return {
            "status": "ok",
            "domain_min_A": int(a_min),
            "n_in_domain": int(len(a_by_zn)),
            "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "n_samples_a_n": int(len(an_list)), "n_samples_a_p": int(len(ap_list))},
            "fit": {"kN": float(kN), "kZ": float(kZ), "kZ_over_kN": float(ratio_kZ_over_kN), "n_fit_pairs_kN": int(len(fit_n)), "n_fit_pairs_kZ": int(len(fit_z))},
            "gap_Sn": diag_gap_sn,
            "gap_Sp": diag_gap_sp,
            "decision": {"train_guard_mev": float(train_guard_mev), "pass_strict": bool(pass_strict)},
        }

    rows: list[dict[str, object]] = []
    for sv in shell_variants:
        shell_name = str(sv["name"])
        shell_magic = list(sv["magic"])
        for a_min in scan_a_mins:
            try:
                pack = run_config(a_min=int(a_min), shell_magic=shell_magic)
                pack["shell_variant"] = {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))}
                rows.append(pack)
            except Exception as e:
                rows.append(
                    {
                        "status": "skipped",
                        "shell_variant": {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))},
                        "domain_min_A": int(a_min),
                        "reason": str(e),
                    }
                )

    # CSV (flat table).
    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_finite_size.csv"
    header = [
        "shell_variant",
        "domain_min_A",
        "status",
        "n_in_domain",
        "a_n_MeV",
        "a_p_MeV",
        "kN",
        "kZ",
        "kZ_over_kN",
        "gap_Sn_train_n",
        "gap_Sn_train_rms_pairing_only_MeV",
        "gap_Sn_train_rms_pairing_shell_MeV",
        "gap_Sn_other_n",
        "gap_Sn_other_rms_pairing_only_MeV",
        "gap_Sn_other_rms_pairing_shell_MeV",
        "gap_Sp_train_n",
        "gap_Sp_train_rms_pairing_only_MeV",
        "gap_Sp_train_rms_pairing_shell_MeV",
        "gap_Sp_other_n",
        "gap_Sp_other_rms_pairing_only_MeV",
        "gap_Sp_other_rms_pairing_shell_MeV",
        "pass_strict",
        "reason",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            status = str(r.get("status", ""))
            sv = r.get("shell_variant") if isinstance(r.get("shell_variant"), dict) else {}
            name = str(sv.get("name", ""))
            domain_a = int(r.get("domain_min_A", -1))
            reason = str(r.get("reason", "")) if status != "ok" else ""
            n_in = int(r.get("n_in_domain", 0)) if status == "ok" else 0
            pairing = r.get("pairing") if isinstance(r.get("pairing"), dict) else {}
            fit = r.get("fit") if isinstance(r.get("fit"), dict) else {}
            gap_sn = r.get("gap_Sn") if isinstance(r.get("gap_Sn"), dict) else {}
            gap_sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
            sn_tr = gap_sn.get("train_magic") if isinstance(gap_sn.get("train_magic"), dict) else {}
            sn_ot = gap_sn.get("other_magic") if isinstance(gap_sn.get("other_magic"), dict) else {}
            sp_tr = gap_sp.get("train_magic") if isinstance(gap_sp.get("train_magic"), dict) else {}
            sp_ot = gap_sp.get("other_magic") if isinstance(gap_sp.get("other_magic"), dict) else {}
            decision = r.get("decision") if isinstance(r.get("decision"), dict) else {}
            w.writerow(
                [
                    name,
                    domain_a,
                    status,
                    n_in,
                    f"{float(pairing.get('a_n_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(pairing.get('a_p_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kN', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ_over_kN', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    str(bool(decision.get("pass_strict", False))) if status == "ok" else "",
                    reason,
                ]
            )

    # Plot: delta RMS (shell - pairing) vs A_min for train/other and Sn/Sp.
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    fig, axes = plt.subplots(2, 2, figsize=(13, 7), constrained_layout=True)
    panels = [
        ("gap_Sn", "other_magic", axes[0][0], "ΔRMS other: gap Sn (shell - pairing)"),
        ("gap_Sp", "other_magic", axes[0][1], "ΔRMS other: gap Sp (shell - pairing)"),
        ("gap_Sn", "train_magic", axes[1][0], "ΔRMS train: gap Sn (shell - pairing)"),
        ("gap_Sp", "train_magic", axes[1][1], "ΔRMS train: gap Sp (shell - pairing)"),
    ]

    for sv in shell_variants:
        name = str(sv["name"])
        ok_rows = [r for r in rows if r.get("status") == "ok" and isinstance(r.get("shell_variant"), dict) and r["shell_variant"].get("name") == name]
        ok_rows = sorted(ok_rows, key=lambda x: int(x.get("domain_min_A", 0)))
        xs = [int(r.get("domain_min_A", 0)) for r in ok_rows]
        for kind, subset, ax, title in panels:
            ys: list[float] = []
            for r in ok_rows:
                g = r.get(kind) if isinstance(r.get(kind), dict) else {}
                sub = g.get(subset) if isinstance(g.get(subset), dict) else {}
                y = float(sub.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(sub.get("rms_resid_pairing_only_MeV", float("nan")))
                ys.append(float(y))
            ax.plot(xs, ys, marker="o", linestyle="-", label=name)
            ax.set_title(title)
            ax.set_xlabel("domain A_min")
            ax.set_ylabel("ΔRMS (MeV)")
            ax.axhline(0.0, color="k", linewidth=1.0, alpha=0.25)
            ax.grid(True, alpha=0.3)

    for ax in axes.flatten():
        ax.legend(fontsize=8)

    fig.suptitle("Phase 7 / Step 7.13.15.25: expanded-set shell-gap decision with Coulomb finite-size (2pF+Slater)", fontsize=12)

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_finite_size.png"
    fig.savefig(out_png, dpi=160)
    plt.close(fig)

    # Decision summary.
    ok_rows = [r for r in rows if r.get("status") == "ok"]
    n_pass = sum(1 for r in ok_rows if bool((r.get("decision") or {}).get("pass_strict", False)))

    best_sp_other = None
    for r in ok_rows:
        sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
        other = sp.get("other_magic") if isinstance(sp.get("other_magic"), dict) else {}
        if int(other.get("n", 0)) <= 0:
            continue
        delta = float(other.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(other.get("rms_resid_pairing_only_MeV", float("nan")))
        if not math.isfinite(delta):
            continue
        if best_sp_other is None or delta < best_sp_other["delta"]:
            best_sp_other = {
                "shell_variant": r.get("shell_variant"),
                "domain_min_A": int(r.get("domain_min_A", -1)),
                "delta": float(delta),
                "pair": float(other.get("rms_resid_pairing_only_MeV", float("nan"))),
                "shell": float(other.get("rms_resid_pairing_shell_MeV", float("nan"))),
                "n": int(other.get("n", 0)),
            }

    conclusion = (
        f"strict_pass={n_pass}/{len(ok_rows)} over shell variants × A_min cuts. "
        "This step replaces the uniform-sphere Coulomb direct term with a finite-size 2pF profile (fixed diffuseness) "
        "and adds Slater exchange on the same non-uniform density, without fitting new DoF. "
        "If strict_pass==0, proton-side other-magic gaps still require additional independently frozen structure DoF."
    )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_coulomb_finite_size_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.25",
                "scan": {"domain_min_A_base": int(domain_min_a), "domain_min_A_candidates": scan_a_mins, "shell_variants": shell_variants},
                "radius_model": {
                    "form": "r_charge = r0*A^(1/3) (frozen from 7.13.15.21 metrics)",
                    "r0_fm": float(r0),
                    "fit_min_A": int(radius_fit_min_a),
                    "n_fit": int(n_fit),
                    "fit_rms_fm": float(fit_rms),
                    "frozen_from_metrics": str(metrics_71521_path),
                },
                "coulomb_finite_size": {
                    "profile": "2pF (fixed a; c from r_rms via bisection)",
                    "a_fm": float(a_diff_fm),
                    "dr_fm": float(dr_fm),
                    "r_max_rule": "max(20, 3*r_rms + 20*a)",
                    "exchange": "Slater (LDA) on 2pF density",
                    "coef_slater": float(coef_slater),
                    "e2_MeV_fm": float(e2_mev_fm),
                },
                "diag": {
                    "n_ame_total": int(len(ame_map)),
                    "n_in_domain_base": int(len(a_by_zn_all)),
                    "n_skipped_base": int(n_skipped),
                    "n_cached_A": int(len(finite_cache)),
                    "best_gap_Sp_other_delta": best_sp_other,
                    "conclusion": conclusion,
                },
                "results": rows,
                "inputs": {
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                    "metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_21": {"path": str(metrics_71521_path), "sha256": _sha256(metrics_71521_path)},
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_26(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.26 (initial): Combine an independently frozen isospin-dependent charge-radius
    model (Step 7.13.15.23; radii-only) with the deterministic finite-size Coulomb correction
    (Step 7.13.15.25; 2pF+Slater), and re-run the expanded-set strict shell-gap decision scan.

    Outputs (fixed names):
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_coulomb_finite_size.png
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_coulomb_finite_size.csv
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_coulomb_finite_size_metrics.json
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if radius_fit_min_a < 1:
        raise SystemExit("[fail] radius_fit_min_a must be >= 1")

    # Frozen HF configuration (pn mix, etc).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)
    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    # Frozen surface-term fit (C3_inf, C_surf) from Step 7.13.15.7.
    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m7157 = _load_json(metrics_7157_path)
    fit_by_eq = m7157.get("fit_by_eq")
    if not isinstance(fit_by_eq, dict) or not fit_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: fit_by_eq missing/empty: {metrics_7157_path}")
    eq_labels = sorted(int(k) for k in fit_by_eq.keys() if str(k).isdigit())
    if not eq_labels:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: eq labels missing: {metrics_7157_path}")

    # Common potential inputs (eq18/eq19 sets).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    root = Path(__file__).resolve().parents[2]
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    # Use the independently frozen isospin radius model from Step 7.13.15.23, without refitting.
    metrics_71523_path = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_metrics.json"
    if not metrics_71523_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.23 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.23\n"
            f"Expected: {metrics_71523_path}"
        )
    m71523 = _load_json(metrics_71523_path)
    radius_model_23 = m71523.get("radius_model") if isinstance(m71523.get("radius_model"), dict) else {}
    radius_model_form = str(radius_model_23.get("form", "r_charge = (r0 + rI*I)*A^(1/3), I=(N-Z)/A"))
    r0 = float(radius_model_23.get("r0_fm", float("nan")))
    rI = float(radius_model_23.get("rI_fm", float("nan")))
    fit_min_a = int(radius_model_23.get("fit_min_A", radius_fit_min_a))
    n_fit = int(radius_model_23.get("n_fit", 0))
    fit_rms = float(radius_model_23.get("fit_rms_fm", float("nan")))
    mean_I_fit = float(radius_model_23.get("mean_I_fit", float("nan")))
    if not (math.isfinite(r0) and math.isfinite(rI)):
        raise SystemExit(f"[fail] invalid 7.13.15.23 radius_model (r0/rI missing): {metrics_71523_path}")

    sigma_model_delta2r_fm = math.sqrt(6.0) * float(fit_rms) if (math.isfinite(float(fit_rms)) and float(fit_rms) > 0.0) else float("nan")

    def r_charge_pred(*, Z: int, N: int) -> float | None:
        A = int(Z) + int(N)
        if A < 2 or int(Z) < 1 or int(N) < 0:
            return None
        I = float(int(N) - int(Z)) / float(A)
        a13 = float(A) ** (1.0 / 3.0)
        r_over_a13 = float(r0) + float(rI) * float(I)
        r_charge = float(r_over_a13) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0.0):
            return None
        return float(r_charge)

    def delta2r_pred_n(*, Z: int, N0: int, d: int = 2) -> float | None:
        r0p = r_charge_pred(Z=int(Z), N=int(N0))
        rLp = r_charge_pred(Z=int(Z), N=int(N0) - int(d))
        rRp = r_charge_pred(Z=int(Z), N=int(N0) + int(d))
        if r0p is None or rLp is None or rRp is None:
            return None
        return float(rRp) - 2.0 * float(r0p) + float(rLp)

    def delta2r_pred_z(*, Z0: int, N: int, d: int = 2) -> float | None:
        r0p = r_charge_pred(Z=int(Z0), N=int(N))
        rLp = r_charge_pred(Z=int(Z0) - int(d), N=int(N))
        rRp = r_charge_pred(Z=int(Z0) + int(d), N=int(N))
        if r0p is None or rLp is None or rRp is None:
            return None
        return float(rRp) - 2.0 * float(r0p) + float(rLp)

    def shell_S_radius_factory(magic_list: list[int]):
        """
        Radius-friendly normalization of the bounded occupancy function:
          S = p(p-g)/g^2  within shell [Mk, Mk1] (0..g), so S in [-1/4, 0] independent of g.
        """
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            denom = float(g) * float(g)
            if not (math.isfinite(denom) and denom > 0):
                return 0.0
            return float(p * (p - g) / float(denom))

        return shell_S

    radii_shell_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_shell(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit a single shell/structure DoF in the radius mapping using IAEA charge radii only.

          r_charge = r_base + r_shell * (S(N) + S(Z))

        where r_base uses the frozen (r0,rI) from Step 7.13.15.23 and
        S(x)=p(p-g)/g^2 is computed on the provided magic list.
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {"status": "skipped", "reason": "radii_by_zn is empty", "r_shell_fm": 0.0, "n_fit": 0}
            radii_shell_fit_cache[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))

        num = 0.0
        den = 0.0
        rows_fit: list[tuple[float, float, float, float]] = []  # (r_obs, r_base, sigma, s_sum)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            s_sum = float(shell_S_r(int(N)) + shell_S_r(int(Z)))
            if not math.isfinite(s_sum):
                counts["skipped"] += 1
                continue
            if abs(float(s_sum)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            num += float(w) * float(s_sum) * (float(r_obs) - float(base))
            den += float(w) * float(s_sum) * float(s_sum)
            rows_fit.append((float(r_obs), float(base), float(sig), float(s_sum)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        r_shell = float(num / den) if (math.isfinite(den) and den > 0.0 and math.isfinite(num)) else 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, s_sum in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_shell.append((float(base) + float(r_shell) * float(s_sum) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_shell*(S(N)+S(Z))",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_shell_fm": float(r_shell),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
        }
        radii_shell_fit_cache[key] = out
        return out

    radii_shell_fit_cache_nz: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_shell_nz(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit two shell/structure DoFs in the radius mapping using IAEA charge radii only.

          r_charge = r_base + r_shell_N*S(N) + r_shell_Z*S(Z)

        where r_base uses the frozen (r0,rI) from Step 7.13.15.23 and
        S(x)=p(p-g)/g^2 is computed on the provided magic list.
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache_nz.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {
                "status": "skipped",
                "reason": "radii_by_zn is empty",
                "r_shell_N_fm": 0.0,
                "r_shell_Z_fm": 0.0,
                "n_fit": 0,
            }
            radii_shell_fit_cache_nz[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))

        s11 = 0.0
        s12 = 0.0
        s22 = 0.0
        t1 = 0.0
        t2 = 0.0
        rows_fit: list[tuple[float, float, float, float, float]] = []  # (r_obs, r_base, sigma, sN, sZ)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            sN = float(shell_S_r(int(N)))
            sZ = float(shell_S_r(int(Z)))
            if not (math.isfinite(sN) and math.isfinite(sZ)):
                counts["skipped"] += 1
                continue
            if abs(float(sN)) + abs(float(sZ)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            y = float(r_obs) - float(base)
            s11 += float(w) * float(sN) * float(sN)
            s12 += float(w) * float(sN) * float(sZ)
            s22 += float(w) * float(sZ) * float(sZ)
            t1 += float(w) * float(sN) * float(y)
            t2 += float(w) * float(sZ) * float(y)
            rows_fit.append((float(r_obs), float(base), float(sig), float(sN), float(sZ)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        det = float(s11) * float(s22) - float(s12) * float(s12)
        if math.isfinite(det) and abs(float(det)) > 0.0 and all(math.isfinite(v) for v in (s11, s12, s22, t1, t2)):
            r_shell_n = (float(t1) * float(s22) - float(t2) * float(s12)) / float(det)
            r_shell_z = (float(s11) * float(t2) - float(s12) * float(t1)) / float(det)
        else:
            r_shell_n = 0.0
            r_shell_z = 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, sN, sZ in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_shell.append((float(base) + float(r_shell_n) * float(sN) + float(r_shell_z) * float(sZ) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_shell_N*S(N) + r_shell_Z*S(Z)",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_shell_N_fm": float(r_shell_n),
            "r_shell_Z_fm": float(r_shell_z),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
            "normal_eq": {
                "S11": float(s11),
                "S12": float(s12),
                "S22": float(s22),
                "T1": float(t1),
                "T2": float(t2),
                "det": float(det),
            },
        }
        radii_shell_fit_cache_nz[key] = out
        return out

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N) -> (A, B/A, sigma, symbol)
    ame_map: dict[tuple[int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N)] = {
            "A": int(A),
            "symbol": str(r.get("symbol", "")),
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
        }
    if not ame_map:
        raise SystemExit("[fail] AME2020 map is empty after parsing (unexpected)")

    # Deterministic finite-size Coulomb model:
    # - direct: 2pF profile (fixed diffuseness a), c determined from r_rms via bisection
    # - exchange: Slater (LDA) on the same non-uniform density
    e2_mev_fm = 1.43996448
    coef_slater = -(3.0 / 4.0) * ((3.0 / math.pi) ** (1.0 / 3.0))
    fourpi_m13 = (4.0 * math.pi) ** (-1.0 / 3.0)
    a_diff_fm = 0.523
    dr_fm = 0.02
    cache_round_fm = 1e-3

    finite_cache: dict[int, dict[str, float]] = {}

    def finite_size_coeffs_for_rms(*, r_rms_fm: float) -> dict[str, float]:
        key = int(round(float(r_rms_fm) / float(cache_round_fm)))
        if key in finite_cache:
            return finite_cache[int(key)]
        target_r_rms = float(key) * float(cache_round_fm)
        if not (math.isfinite(target_r_rms) and target_r_rms > 0):
            raise RuntimeError("invalid r_rms")

        c_guess2 = (5.0 / 3.0) * (target_r_rms**2) - (7.0 / 3.0) * ((math.pi * float(a_diff_fm)) ** 2)
        c_guess = math.sqrt(c_guess2) if c_guess2 > 0 else max(0.1, float(target_r_rms) * 0.5)

        def rms_from_c(c_fm: float) -> float:
            if not (math.isfinite(c_fm) and c_fm > 0):
                return float("nan")
            r_max = max(20.0, 3.0 * float(target_r_rms) + 20.0 * float(a_diff_fm))
            n = int(math.ceil(r_max / float(dr_fm)))
            I2 = 0.0
            I4 = 0.0
            for i in range(n):
                r = (float(i) + 0.5) * float(dr_fm)
                f = 1.0 / (1.0 + math.exp((float(r) - float(c_fm)) / float(a_diff_fm)))
                r2 = float(r) * float(r)
                I2 += r2 * float(f)
                I4 += (r2 * r2) * float(f)
            I2 *= float(dr_fm)
            I4 *= float(dr_fm)
            if not (math.isfinite(I2) and I2 > 0 and math.isfinite(I4) and I4 > 0):
                return float("nan")
            return math.sqrt(float(I4) / float(I2))

        # Bracket and bisection (few iterations; cached per-quantized r_rms).
        lo = max(0.05, 0.25 * float(c_guess))
        hi = max(lo * 1.1, 3.0 * float(c_guess) + 10.0 * float(a_diff_fm))
        for _ in range(6):
            r_lo = rms_from_c(lo)
            r_hi = rms_from_c(hi)
            if not (math.isfinite(r_lo) and math.isfinite(r_hi)):
                hi *= 1.5
                continue
            if r_lo <= target_r_rms <= r_hi:
                break
            if target_r_rms < r_lo:
                lo *= 0.7
            else:
                hi *= 1.5

        c = float(c_guess)
        for _ in range(18):
            mid = 0.5 * (float(lo) + float(hi))
            r_mid = rms_from_c(mid)
            if not math.isfinite(r_mid):
                break
            c = float(mid)
            if r_mid < target_r_rms:
                lo = float(mid)
            else:
                hi = float(mid)

        # Coefficients for the final c.
        r_max = max(20.0, 3.0 * float(target_r_rms) + 20.0 * float(a_diff_fm))
        n = int(math.ceil(r_max / float(dr_fm)))
        rs: list[float] = []
        fs: list[float] = []
        g2: list[float] = []
        h1: list[float] = []
        I2 = 0.0
        I2_43 = 0.0
        for i in range(n):
            r = (float(i) + 0.5) * float(dr_fm)
            f = 1.0 / (1.0 + math.exp((float(r) - float(c)) / float(a_diff_fm)))
            rs.append(float(r))
            fs.append(float(f))
            r2 = float(r) * float(r)
            g2_i = r2 * float(f)
            g2.append(float(g2_i))
            h1.append(float(r) * float(f))
            I2 += float(g2_i)
            I2_43 += float(r2) * (float(f) ** (4.0 / 3.0))
        I2 *= float(dr_fm)
        I2_43 *= float(dr_fm)
        if not (math.isfinite(I2) and I2 > 0 and math.isfinite(I2_43) and I2_43 > 0):
            raise RuntimeError("finite-size integrals failed")

        # A0(r)=∫_0^r f(r') r'^2 dr'  and  B0(r)=∫_r^∞ f(r') r' dr'  (no 4π).
        A0: list[float] = []
        acc = 0.0
        for v in g2:
            acc += float(v) * float(dr_fm)
            A0.append(float(acc))
        B0 = [0.0] * n
        acc = 0.0
        for i in range(n - 1, -1, -1):
            acc += float(h1[i]) * float(dr_fm)
            B0[i] = float(acc)

        J = 0.0
        for r, f, a0, b0 in zip(rs, fs, A0, B0, strict=True):
            J += (float(r) * float(f) * float(a0) + (float(r) ** 2) * float(f) * float(b0))
        J *= float(dr_fm)

        e_dir_unit_over_e2 = 0.5 * float(J) / (float(I2) ** 2)  # [fm^-1]
        i43_unit = float(fourpi_m13) * float(I2_43) / (float(I2) ** (4.0 / 3.0))  # [fm^-1]
        rms_check = rms_from_c(float(c))

        out = {
            "r_rms_fm": float(target_r_rms),
            "c_fm": float(c),
            "rms_check_fm": float(rms_check) if math.isfinite(rms_check) else float("nan"),
            "e_dir_unit_over_e2_fm_1": float(e_dir_unit_over_e2),
            "i43_unit_fm_1": float(i43_unit),
        }
        finite_cache[int(key)] = out
        return out

    # Predict B (total) for the expanded AME2020 set using the frozen isospin radius model + Coulomb finite-size correction.
    a_by_zn_all: dict[tuple[int, int], int] = {}
    b_obs_all: dict[tuple[int, int], float] = {}
    b_pred_all: dict[tuple[int, int], float] = {}
    n_skipped = 0
    n_beta2_direct = 0
    n_beta2_imputed = 0
    n_beta2_missing = 0

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue
        I = float(int(N) - int(Z)) / float(A)

        a13 = float(A) ** (1.0 / 3.0)
        r_over_a13 = float(r0) + float(rI) * float(I)
        r_charge = float(r_over_a13) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho = float(A) / float(V_sphere)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        beta2_val, beta2_mode = _beta2_for_zn(
            Z=int(Z), N=int(N), beta2_by_zn=beta2_by_zn, include_beta2=include_beta2, imputation=str(beta2_imputation)
        )
        shape_factor = _coulomb_shape_factor_from_beta2(beta2=float(beta2_val), include_beta2=include_beta2)
        surface_factor = _surface_area_factor_from_beta2(
            beta2=float(beta2_val), include_beta2=bool(include_beta2 and beta2_apply_surface)
        )

        if include_beta2:
            if beta2_mode == "direct":
                n_beta2_direct += 1
            elif beta2_mode == "imputed":
                n_beta2_imputed += 1
            elif beta2_mode == "missing":
                n_beta2_missing += 1

        cpack = finite_size_coeffs_for_rms(r_rms_fm=float(r_charge))
        e_dir_unit = float(cpack["e_dir_unit_over_e2_fm_1"]) * float(shape_factor)
        i43_unit = float(cpack["i43_unit_fm_1"]) * float(shape_factor)

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            e_coul_uniform = float(base_pack.get("Coul", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not (math.isfinite(base_e) and math.isfinite(e_coul_uniform)):
                continue

            # Replace uniform-sphere Coulomb direct with 2pF direct, and add 2pF Slater exchange (LDA).
            if int(Z) <= 1:
                e_dir_fs = 0.0
                e_x_fs = 0.0
            else:
                e_dir_fs = float(e2_mev_fm) * float(Z * (Z - 1)) * float(e_dir_unit) / float(A)
                e_x_fs = float(coef_slater) * float(e2_mev_fm) * (float(Z) ** (4.0 / 3.0)) * float(i43_unit) / float(A)

            e_coul_fs = (float(e_dir_fs) - float(e_coul_uniform)) + float(e_x_fs)
            e_surf = float(c_surf) / (6.0 * float(R_sharp)) * float(surface_factor)
            e_total = float(base_e) + float(e_coul_fs) + float(c3_inf) * (float(rho) ** 2) + float(e_surf)
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn_all[(int(Z), int(N))] = int(A)
        b_obs_all[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred_all[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not a_by_zn_all:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after radius-model prediction")

    # Candidate domain boundaries (same as Step 7.13.15.22).
    scan_a_mins = sorted({int(domain_min_a), 40, 60, 80, 100})
    scan_a_mins = [a for a in scan_a_mins if a >= int(domain_min_a)]

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    OBS_MAGIC_SET = {int(x) for x in OBS_MAGIC}
    TRAIN_MAGIC = {50, 82}
    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    shell_variants = [
        {"name": "model_magic", "magic": list(MODEL_MAGIC), "note": "S_shell uses model magic list (legacy in 7.13.15.*)."},
        {"name": "obs_magic", "magic": list(OBS_MAGIC), "note": "S_shell uses observed magic list (domain-independent mapping)."},
    ]

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        return any(abs(int(x) - int(m0)) <= int(tol) for m0 in OBS_MAGIC)

    def shell_S_factory(magic_list: list[int]):
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            return float(p * (p - g) / float(g))

        return shell_S

    def shell_S_radius_factory(magic_list: list[int]):
        """
        Radius-friendly normalization of the bounded occupancy function:
          S = p(p-g)/g^2  within shell [Mk, Mk1] (0..g), so S in [-1/4, 0] independent of g.
        """
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            denom = float(g) * float(g)
            if not (math.isfinite(denom) and denom > 0):
                return 0.0
            return float(p * (p - g) / float(denom))

        return shell_S

    radii_shell_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_shell(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit a single shell/structure DoF in the radius mapping using IAEA charge radii only.

          r_charge = r_base + r_shell * (S(N) + S(Z))

        where r_base uses the frozen (r0,rI) from Step 7.13.15.23 and
        S(x)=p(p-g)/g^2 is computed on the provided magic list.
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {"status": "skipped", "reason": "radii_by_zn is empty", "r_shell_fm": 0.0, "n_fit": 0}
            radii_shell_fit_cache[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))

        num = 0.0
        den = 0.0
        rows_fit: list[tuple[float, float, float, float]] = []  # (r_obs, r_base, sigma, s_sum)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            s_sum = float(shell_S_r(int(N)) + shell_S_r(int(Z)))
            if not math.isfinite(s_sum):
                counts["skipped"] += 1
                continue
            if abs(float(s_sum)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            num += float(w) * float(s_sum) * (float(r_obs) - float(base))
            den += float(w) * float(s_sum) * float(s_sum)
            rows_fit.append((float(r_obs), float(base), float(sig), float(s_sum)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        r_shell = float(num / den) if (math.isfinite(den) and den > 0.0 and math.isfinite(num)) else 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, s_sum in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_shell.append((float(base) + float(r_shell) * float(s_sum) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_shell*(S(N)+S(Z))",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_shell_fm": float(r_shell),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
        }
        radii_shell_fit_cache[key] = out
        return out

    # Helpers for separations and gaps.
    def build_sep_n(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    def summarize_gaps(
        g_obs: dict[tuple[int, int, int], float],
        g_unc: dict[tuple[int, int, int], float],
        g_base: dict[tuple[int, int, int], float],
        g_cor: dict[tuple[int, int, int], float],
    ) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []
        rows_other: list[tuple[float, float, float]] = []
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            by_magic.setdefault(magic, []).append((resid_u, resid_b, resid_c))
            if magic in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        by_magic_rows: dict[str, dict[str, object]] = {}
        for m, rows in sorted(by_magic.items()):
            by_magic_rows[str(int(m))] = {
                "n": int(len(rows)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows)),
            }

        return {
            "train_magic": {
                "n": int(len(rows_train)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_train)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_train)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_train)),
            },
            "other_magic": {
                "n": int(len(rows_other)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_other)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_other)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_other)),
            },
            "by_magic": by_magic_rows,
        }

    # Run the same frozen protocol as Step 7.13.15.22 on the expanded set.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def run_config(*, a_min: int, shell_magic: list[int]) -> dict[str, object]:
        # Domain slice
        a_by_zn = {zn: A for zn, A in a_by_zn_all.items() if int(A) >= int(a_min)}
        b_obs = {zn: b_obs_all[zn] for zn in a_by_zn.keys()}
        b_pred = {zn: b_pred_all[zn] for zn in a_by_zn.keys()}
        if not a_by_zn:
            raise RuntimeError(f"empty domain slice at A_min={a_min}")

        # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
        an_list: list[float] = []
        ap_list: list[float] = []
        for (Z, N), A in a_by_zn.items():
            if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
                continue
            if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
                dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
                if math.isfinite(dn):
                    an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
            if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
                dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
                if math.isfinite(dp):
                    ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
        a_n = _median(an_list)
        a_p = _median(ap_list)
        if not (math.isfinite(a_n) and math.isfinite(a_p)):
            raise RuntimeError(f"pairing freeze failed (no OES samples) at A_min={a_min}")

        # Pairing baseline binding energies.
        b_base: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
            term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
            b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

        # Shell correction basis terms.
        shell_S = shell_S_factory(shell_magic)
        cN: dict[tuple[int, int], float] = {}
        cZ: dict[tuple[int, int], float] = {}
        for (Z, N), A in a_by_zn.items():
            hw = hw_mev(int(A))
            cN[(Z, N)] = float(hw) * float(shell_S(int(N)))
            cZ[(Z, N)] = float(hw) * float(shell_S(int(Z)))

        # Observables (obs).
        sn_obs = build_sep_n(a_by_zn, b_obs, dN=1)
        sp_obs = build_sep_p(a_by_zn, b_obs, dZ=1)
        gap_sn_obs = build_gap_n(sn_obs, step=1)
        gap_sp_obs = build_gap_p(sp_obs, step=1)

        # Predictions: uncorrected (B_pred), pairing-only (B_base).
        sn_pred_unc = build_sep_n(a_by_zn, b_pred, dN=1)
        sp_pred_unc = build_sep_p(a_by_zn, b_pred, dZ=1)
        sn_pred_base = build_sep_n(a_by_zn, b_base, dN=1)
        sp_pred_base = build_sep_p(a_by_zn, b_base, dZ=1)

        gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
        gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
        gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
        gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

        # Unit-basis maps for kN/kZ fits, around the pairing baseline.
        bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN[zn]) for zn, b0 in b_base.items()}
        bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ[zn]) for zn, b0 in b_base.items()}
        gap_sn_pred_N1 = build_gap_n(build_sep_n(a_by_zn, bN1, dN=1), step=1)
        gap_sp_pred_Z1 = build_gap_p(build_sep_p(a_by_zn, bZ1, dZ=1), step=1)

        # Fit kN from neutron gaps at observed magic N in {50,82} (1D LS).
        fit_n: list[tuple[float, float]] = []
        for (Z, N0, step), g_obs in gap_sn_obs.items():
            if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sn_pred_base.get((Z, N0, 1))
            g_1 = gap_sn_pred_N1.get((Z, N0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_n.append((y, x))
        if not fit_n:
            raise RuntimeError(f"no fit data for kN at A_min={a_min}")
        kN = float(sum(y * x for y, x in fit_n) / sum(x * x for _y, x in fit_n))

        # Fit kZ from proton gaps at observed magic Z in {50,82} (1D LS).
        fit_z: list[tuple[float, float]] = []
        for (N, Z0, step), g_obs in gap_sp_obs.items():
            if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
                continue
            g_base = gap_sp_pred_base.get((N, Z0, 1))
            g_1 = gap_sp_pred_Z1.get((N, Z0, 1))
            if g_base is None or g_1 is None:
                continue
            x = float(g_1 - g_base)
            if not math.isfinite(x) or abs(x) < 1e-12:
                continue
            y = float(g_obs - g_base)
            fit_z.append((y, x))
        if not fit_z:
            raise RuntimeError(f"no fit data for kZ at A_min={a_min}")
        kZ = float(sum(y * x for y, x in fit_z) / sum(x * x for _y, x in fit_z))
        ratio_kZ_over_kN = float(kZ / kN) if abs(kN) > 1e-12 else float("nan")

        # Corrected binding energies (pairing + refrozen shell).
        b_cor: dict[tuple[int, int], float] = {}
        for zn, b0 in b_base.items():
            b_cor[zn] = float(b0) + float(kN) * float(cN[zn]) + float(kZ) * float(cZ[zn])

        # Corrected gap predictions.
        gap_sn_pred_cor = build_gap_n(build_sep_n(a_by_zn, b_cor, dN=1), step=1)
        gap_sp_pred_cor = build_gap_p(build_sep_p(a_by_zn, b_cor, dZ=1), step=1)

        diag_gap_sn = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor)
        diag_gap_sp = summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor)

        # Strict decision: train guardrail + other strict improvement (Sn and Sp).
        train_guard_mev = 0.5
        ok_train = (
            float(diag_gap_sn["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sn["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
            and float(diag_gap_sp["train_magic"]["rms_resid_pairing_shell_MeV"])
            <= float(diag_gap_sp["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
        )
        ok_other = (
            float(diag_gap_sn["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sn["other_magic"]["rms_resid_pairing_only_MeV"])
            and float(diag_gap_sp["other_magic"]["rms_resid_pairing_shell_MeV"]) < float(diag_gap_sp["other_magic"]["rms_resid_pairing_only_MeV"])
        )
        pass_strict = bool(ok_train and ok_other)

        return {
            "status": "ok",
            "domain_min_A": int(a_min),
            "n_in_domain": int(len(a_by_zn)),
            "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "n_samples_a_n": int(len(an_list)), "n_samples_a_p": int(len(ap_list))},
            "fit": {"kN": float(kN), "kZ": float(kZ), "kZ_over_kN": float(ratio_kZ_over_kN), "n_fit_pairs_kN": int(len(fit_n)), "n_fit_pairs_kZ": int(len(fit_z))},
            "gap_Sn": diag_gap_sn,
            "gap_Sp": diag_gap_sp,
            "decision": {"train_guard_mev": float(train_guard_mev), "pass_strict": bool(pass_strict)},
        }

    rows: list[dict[str, object]] = []
    for sv in shell_variants:
        shell_name = str(sv["name"])
        shell_magic = list(sv["magic"])
        for a_min in scan_a_mins:
            try:
                pack = run_config(a_min=int(a_min), shell_magic=shell_magic)
                pack["shell_variant"] = {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))}
                rows.append(pack)
            except Exception as e:
                rows.append(
                    {
                        "status": "skipped",
                        "shell_variant": {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))},
                        "domain_min_A": int(a_min),
                        "reason": str(e),
                    }
                )

    # CSV (flat table).
    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_coulomb_finite_size.csv"
    header = [
        "shell_variant",
        "domain_min_A",
        "status",
        "n_in_domain",
        "a_n_MeV",
        "a_p_MeV",
        "kN",
        "kZ",
        "kZ_over_kN",
        "gap_Sn_train_n",
        "gap_Sn_train_rms_pairing_only_MeV",
        "gap_Sn_train_rms_pairing_shell_MeV",
        "gap_Sn_other_n",
        "gap_Sn_other_rms_pairing_only_MeV",
        "gap_Sn_other_rms_pairing_shell_MeV",
        "gap_Sp_train_n",
        "gap_Sp_train_rms_pairing_only_MeV",
        "gap_Sp_train_rms_pairing_shell_MeV",
        "gap_Sp_other_n",
        "gap_Sp_other_rms_pairing_only_MeV",
        "gap_Sp_other_rms_pairing_shell_MeV",
        "pass_strict",
        "reason",
    ]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            status = str(r.get("status", ""))
            sv = r.get("shell_variant") if isinstance(r.get("shell_variant"), dict) else {}
            name = str(sv.get("name", ""))
            domain_a = int(r.get("domain_min_A", -1))
            reason = str(r.get("reason", "")) if status != "ok" else ""
            n_in = int(r.get("n_in_domain", 0)) if status == "ok" else 0
            pairing = r.get("pairing") if isinstance(r.get("pairing"), dict) else {}
            fit = r.get("fit") if isinstance(r.get("fit"), dict) else {}
            gap_sn = r.get("gap_Sn") if isinstance(r.get("gap_Sn"), dict) else {}
            gap_sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
            sn_tr = gap_sn.get("train_magic") if isinstance(gap_sn.get("train_magic"), dict) else {}
            sn_ot = gap_sn.get("other_magic") if isinstance(gap_sn.get("other_magic"), dict) else {}
            sp_tr = gap_sp.get("train_magic") if isinstance(gap_sp.get("train_magic"), dict) else {}
            sp_ot = gap_sp.get("other_magic") if isinstance(gap_sp.get("other_magic"), dict) else {}
            decision = r.get("decision") if isinstance(r.get("decision"), dict) else {}
            w.writerow(
                [
                    name,
                    domain_a,
                    status,
                    n_in,
                    f"{float(pairing.get('a_n_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(pairing.get('a_p_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kN', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(fit.get('kZ_over_kN', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sn_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sn_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_tr.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(sp_ot.get("n", 0)) if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(sp_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    bool(decision.get("pass_strict", False)) if status == "ok" else "",
                    reason,
                ]
            )

    # Plot: delta RMS (shell - pairing) vs A_min for train/other and Sn/Sp.
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    fig, axes = plt.subplots(2, 2, figsize=(13, 7), constrained_layout=True)
    panels = [
        ("gap_Sn", "other_magic", axes[0][0], "ΔRMS other: gap Sn (shell - pairing)"),
        ("gap_Sp", "other_magic", axes[0][1], "ΔRMS other: gap Sp (shell - pairing)"),
        ("gap_Sn", "train_magic", axes[1][0], "ΔRMS train: gap Sn (shell - pairing)"),
        ("gap_Sp", "train_magic", axes[1][1], "ΔRMS train: gap Sp (shell - pairing)"),
    ]

    for sv in shell_variants:
        name = str(sv["name"])
        ok_rows = [r for r in rows if r.get("status") == "ok" and isinstance(r.get("shell_variant"), dict) and r["shell_variant"].get("name") == name]
        ok_rows = sorted(ok_rows, key=lambda x: int(x.get("domain_min_A", 0)))
        xs = [int(r.get("domain_min_A", 0)) for r in ok_rows]
        for kind, subset, ax, title in panels:
            ys: list[float] = []
            for r in ok_rows:
                g = r.get(kind) if isinstance(r.get(kind), dict) else {}
                sub = g.get(subset) if isinstance(g.get(subset), dict) else {}
                y = float(sub.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(sub.get("rms_resid_pairing_only_MeV", float("nan")))
                ys.append(float(y))
            ax.plot(xs, ys, marker="o", linestyle="-", label=name)
            ax.set_title(title)
            ax.set_xlabel("domain A_min")
            ax.set_ylabel("ΔRMS (MeV)")
            ax.axhline(0.0, color="k", linewidth=1.0, alpha=0.25)
            ax.grid(True, alpha=0.3)

    for ax in axes.flatten():
        ax.legend(fontsize=8)

    fig.suptitle(
        "Phase 7 / Step 7.13.15.26: expanded-set shell-gap decision with isospin radii + Coulomb finite-size (2pF+Slater)",
        fontsize=12,
    )

    out_png = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_coulomb_finite_size.png"
    fig.savefig(out_png, dpi=160)
    plt.close(fig)

    # Decision summary.
    ok_rows = [r for r in rows if r.get("status") == "ok"]
    n_pass = sum(1 for r in ok_rows if bool((r.get("decision") or {}).get("pass_strict", False)))

    best_sp_other = None
    for r in ok_rows:
        sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
        other = sp.get("other_magic") if isinstance(sp.get("other_magic"), dict) else {}
        if int(other.get("n", 0)) <= 0:
            continue
        delta = float(other.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(other.get("rms_resid_pairing_only_MeV", float("nan")))
        if not math.isfinite(delta):
            continue
        if best_sp_other is None or delta < best_sp_other["delta"]:
            best_sp_other = {
                "shell_variant": r.get("shell_variant"),
                "domain_min_A": int(r.get("domain_min_A", -1)),
                "delta": float(delta),
                "pair": float(other.get("rms_resid_pairing_only_MeV", float("nan"))),
                "shell": float(other.get("rms_resid_pairing_shell_MeV", float("nan"))),
                "n": int(other.get("n", 0)),
            }

    conclusion = (
        f"strict_pass={n_pass}/{len(ok_rows)} over shell variants × A_min cuts. "
        "This step combines the independently frozen isospin-dependent charge-radius model (Step 7.13.15.23; radii-only) "
        "with a deterministic finite-size Coulomb correction (2pF direct + Slater exchange, no new fit DoF). "
        "If strict_pass==0, proton-side other-magic gaps still require additional independently frozen structure DoF."
    )

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_coulomb_finite_size_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.15.26",
                "scan": {"domain_min_A_base": int(domain_min_a), "domain_min_A_candidates": scan_a_mins, "shell_variants": shell_variants},
                "radius_model": {
                    "form": radius_model_form,
                    "r0_fm": float(r0),
                    "rI_fm": float(rI),
                    "fit_min_A": int(fit_min_a),
                    "n_fit": int(n_fit),
                    "fit_rms_fm": float(fit_rms),
                    "mean_I_fit": float(mean_I_fit) if math.isfinite(mean_I_fit) else float("nan"),
                    "frozen_from_metrics": str(metrics_71523_path),
                },
                "coulomb_finite_size": {
                    "profile": "2pF (fixed a; c from r_rms via bisection)",
                    "a_fm": float(a_diff_fm),
                    "dr_fm": float(dr_fm),
                    "r_max_rule": "max(20, 3*r_rms + 20*a)",
                    "exchange": "Slater (LDA) on 2pF density",
                    "coef_slater": float(coef_slater),
                    "e2_MeV_fm": float(e2_mev_fm),
                    "cache_round_fm": float(cache_round_fm),
                },
                "diag": {
                    "n_ame_total": int(len(ame_map)),
                    "n_in_domain_base": int(len(a_by_zn_all)),
                    "n_skipped_base": int(n_skipped),
                    "n_cached_r_rms": int(len(finite_cache)),
                    "best_gap_Sp_other_delta": best_sp_other,
                    "conclusion": conclusion,
                },
                "results": rows,
                "inputs": {
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                    **(
                        {
                            "nndc_be2_adopted_entries_json": {"path": str(beta2_raw_path), "sha256": _sha256(beta2_raw_path)},
                            "nndc_be2_manifest": {"path": str(beta2_manifest_path), "sha256": _sha256(beta2_manifest_path)},
                            "nndc_be2_extracted_beta2": {"path": str(beta2_path), "sha256": _sha256(beta2_path)},
                        }
                        if include_beta2
                        else {}
                    ),
                    "metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_23": {"path": str(metrics_71523_path), "sha256": _sha256(metrics_71523_path)},
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_27(
    *,
    out_dir: Path,
    domain_min_a: int,
    radius_fit_min_a: int,
    step_id: str = "7.13.15.27",
    out_stub: str = "expanded_shell_i_dep",
    shell_s_power_g: float = 1.0,
    include_beta2: bool = False,
    beta2_imputation: str = "neighbors",
    beta2_apply_surface: bool = False,
    beta2_strict_coverage: bool = False,
    include_e2plus: bool = False,
    e2plus_strict_peaks: bool = False,
    e2plus_path_override: Path | None = None,
    e2plus_source_label: str = "NNDC B(E2) adopted entries (transitionEnergy as E(2+1) proxy)",
    e2plus_note: str = "Uses transitionEnergy as E(2+_1) proxy; cross-check is based on local peaks along isotopic/isotonic chains.",
    e2plus_fetch_hint: str = "python -B scripts/quantum/fetch_nuclear_deformation_be2_sources.py",
    include_spectro_multi: bool = False,
    spectro_multi_strict: bool = False,
    spectro_multi_path_override: Path | None = None,
    spectro_multi_source_label: str = "NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
    spectro_multi_note: str = "Uses NuDat 3.0 static chart JSON (ENSDF-derived) for low-lying spectroscopy; cross-check is based on local extrema along isotopic/isotonic chains.",
    spectro_multi_fetch_hint: str = "python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
    include_radii_kink: bool = False,
    radii_kink_strict: bool = False,
    radii_kink_sigma_min: float = 3.0,
    include_radii_kink_delta2r: bool = False,
    radii_kink_delta2r_strict: bool = False,
    radii_kink_delta2r_resid_sigma_max: float = 3.0,
    radii_kink_delta2r_radius_shell: bool = False,
    radii_kink_delta2r_radius_shell_nz: bool = False,
    radii_kink_delta2r_radius_shell_nz_beta2: bool = False,
    radii_kink_delta2r_radius_beta2: bool = False,
    radii_kink_delta2r_radius_odd_even: bool = False,
    radii_kink_delta2r_radius_magic_offset: bool = False,
    radii_kink_delta2r_radius_magic_offset_neighbors: bool = False,
    radii_kink_delta2r_radius_magic_offset_per_magic: bool = False,
    radii_kink_delta2r_even_even_only: bool = False,
    radii_kink_delta2r_center_magic_only: bool = False,
) -> None:
    """
    Step 7.13.15.27 (initial): Add a minimal shell/structure DoF candidate and re-run the
    expanded-set strict shell-gap decision scan.

    Candidate (minimal DoF; frozen on train):
      - isospin-dependent shell refreeze: kN(I)=kN0+kN1*I, kZ(I)=kZ0+kZ1*I, with I=(N-Z)/A
      - coefficients are frozen using train magic N/Z in {50,82} only.

    Baseline prediction uses the same independently frozen inputs as Step 7.13.15.26:
      - radii-only isospin radius model (7.13.15.23)
      - deterministic finite-size Coulomb (2pF+Slater, fixed a; c from r_rms)

    Outputs (fixed names):
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_shell_i_dep.png
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_shell_i_dep.csv
      - output/public/quantum/nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_shell_i_dep_metrics.json
    """
    if domain_min_a < 1:
        raise SystemExit("[fail] domain_min_a must be >= 1")
    if radius_fit_min_a < 1:
        raise SystemExit("[fail] radius_fit_min_a must be >= 1")
    if not (math.isfinite(float(shell_s_power_g)) and float(shell_s_power_g) > 0.0):
        raise SystemExit("[fail] shell_s_power_g must be finite and > 0")
    if bool(include_radii_kink or include_radii_kink_delta2r):
        if not (math.isfinite(float(radii_kink_sigma_min)) and float(radii_kink_sigma_min) > 0.0):
            raise SystemExit("[fail] radii_kink_sigma_min must be finite and > 0")
    if bool(include_radii_kink_delta2r):
        if not (math.isfinite(float(radii_kink_delta2r_resid_sigma_max)) and float(radii_kink_delta2r_resid_sigma_max) > 0.0):
            raise SystemExit("[fail] radii_kink_delta2r_resid_sigma_max must be finite and > 0")
    if bool(radii_kink_delta2r_radius_beta2 and (not include_beta2)):
        raise SystemExit("[fail] radii_kink_delta2r_radius_beta2 requires include_beta2=True")
    if bool(radii_kink_delta2r_radius_shell_nz_beta2 and (not include_beta2)):
        raise SystemExit("[fail] radii_kink_delta2r_radius_shell_nz_beta2 requires include_beta2=True")
    if (
        int(bool(radii_kink_delta2r_radius_shell))
        + int(bool(radii_kink_delta2r_radius_shell_nz))
        + int(bool(radii_kink_delta2r_radius_shell_nz_beta2))
        + int(bool(radii_kink_delta2r_radius_beta2))
        + int(bool(radii_kink_delta2r_radius_odd_even))
        + int(bool(radii_kink_delta2r_radius_magic_offset))
        + int(bool(radii_kink_delta2r_radius_magic_offset_neighbors))
        + int(bool(radii_kink_delta2r_radius_magic_offset_per_magic))
        > 1
    ):
        raise SystemExit(
            "[fail] radii_kink_delta2r radius variants are mutually exclusive "
            "("
            "radii_kink_delta2r_radius_shell / "
            "radii_kink_delta2r_radius_shell_nz / "
            "radii_kink_delta2r_radius_shell_nz_beta2 / "
            "radii_kink_delta2r_radius_beta2 / "
            "radii_kink_delta2r_radius_odd_even / "
            "radii_kink_delta2r_radius_magic_offset / "
            "radii_kink_delta2r_radius_magic_offset_neighbors / "
            "radii_kink_delta2r_radius_magic_offset_per_magic"
            ")"
        )

    radii_shell_fit_cache_nz: dict[tuple[int, ...], dict[str, object]] = {}
    radii_shell_fit_cache_nz_beta2: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_shell_nz(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit two shell/structure DoFs in the radius mapping using IAEA charge radii only.

          r_charge = r_base + r_shell_N*S(N) + r_shell_Z*S(Z)

        where r_base uses the frozen (r0,rI) from Step 7.13.15.23 and
        S(x)=p(p-g)/g^2 is computed on the provided magic list.
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache_nz.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {
                "status": "skipped",
                "reason": "radii_by_zn is empty",
                "r_shell_N_fm": 0.0,
                "r_shell_Z_fm": 0.0,
                "n_fit": 0,
            }
            radii_shell_fit_cache_nz[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))

        s11 = 0.0
        s12 = 0.0
        s22 = 0.0
        t1 = 0.0
        t2 = 0.0
        rows_fit: list[tuple[float, float, float, float, float]] = []  # (r_obs, r_base, sigma, sN, sZ)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            sN = float(shell_S_r(int(N)))
            sZ = float(shell_S_r(int(Z)))
            if not (math.isfinite(sN) and math.isfinite(sZ)):
                counts["skipped"] += 1
                continue
            if abs(float(sN)) + abs(float(sZ)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            y = float(r_obs) - float(base)
            s11 += float(w) * float(sN) * float(sN)
            s12 += float(w) * float(sN) * float(sZ)
            s22 += float(w) * float(sZ) * float(sZ)
            t1 += float(w) * float(sN) * float(y)
            t2 += float(w) * float(sZ) * float(y)
            rows_fit.append((float(r_obs), float(base), float(sig), float(sN), float(sZ)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        det = float(s11) * float(s22) - float(s12) * float(s12)
        if math.isfinite(det) and abs(float(det)) > 0.0 and all(math.isfinite(v) for v in (s11, s12, s22, t1, t2)):
            r_shell_n = (float(t1) * float(s22) - float(t2) * float(s12)) / float(det)
            r_shell_z = (float(s11) * float(t2) - float(s12) * float(t1)) / float(det)
        else:
            r_shell_n = 0.0
            r_shell_z = 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, sN, sZ in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_shell.append((float(base) + float(r_shell_n) * float(sN) + float(r_shell_z) * float(sZ) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_shell_N*S(N) + r_shell_Z*S(Z)",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_shell_N_fm": float(r_shell_n),
            "r_shell_Z_fm": float(r_shell_z),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
            "normal_eq": {
                "S11": float(s11),
                "S12": float(s12),
                "S22": float(s22),
                "T1": float(t1),
                "T2": float(t2),
                "det": float(det),
            },
        }
        radii_shell_fit_cache_nz[key] = out
        return out

    def fit_radii_shell_nz_beta2(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit two shell/structure DoFs in the radius mapping using IAEA charge radii only,
        while applying a deformation-aware beta2 factor multiplicatively:

          r_charge = (r_base + r_shell_N*S(N) + r_shell_Z*S(Z)) * sqrt(1 + (5/(4π))*beta2^2)

        This keeps the fit linear in (r_shell_N, r_shell_Z) (since beta2 is treated as
        fixed input per nucleus).
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache_nz_beta2.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {
                "status": "skipped",
                "reason": "radii_by_zn is empty",
                "r_shell_N_fm": 0.0,
                "r_shell_Z_fm": 0.0,
                "n_fit": 0,
            }
            radii_shell_fit_cache_nz_beta2[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))
        k_beta2 = 5.0 / (4.0 * math.pi)

        s11 = 0.0
        s12 = 0.0
        s22 = 0.0
        t1 = 0.0
        t2 = 0.0
        rows_fit: list[tuple[float, float, float, float, float, float]] = []  # (r_obs, base, sig, sN, sZ, factor)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        beta2_counts = {"direct": 0, "imputed": 0, "missing": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            b2, b2_mode = _beta2_for_zn(
                Z=int(Z), N=int(N), beta2_by_zn=beta2_by_zn, include_beta2=include_beta2, imputation=str(beta2_imputation)
            )
            if str(b2_mode) in beta2_counts:
                beta2_counts[str(b2_mode)] += 1
            factor = math.sqrt(1.0 + float(k_beta2) * float(b2) * float(b2))
            if not (math.isfinite(factor) and factor > 0.0):
                counts["skipped"] += 1
                continue
            sN = float(shell_S_r(int(N)))
            sZ = float(shell_S_r(int(Z)))
            if not (math.isfinite(sN) and math.isfinite(sZ)):
                counts["skipped"] += 1
                continue
            xN = float(factor) * float(sN)
            xZ = float(factor) * float(sZ)
            if abs(float(xN)) + abs(float(xZ)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            y = float(r_obs) - float(base) * float(factor)
            s11 += float(w) * float(xN) * float(xN)
            s12 += float(w) * float(xN) * float(xZ)
            s22 += float(w) * float(xZ) * float(xZ)
            t1 += float(w) * float(xN) * float(y)
            t2 += float(w) * float(xZ) * float(y)
            rows_fit.append((float(r_obs), float(base), float(sig), float(sN), float(sZ), float(factor)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        det = float(s11) * float(s22) - float(s12) * float(s12)
        if math.isfinite(det) and abs(float(det)) > 0.0 and all(math.isfinite(v) for v in (s11, s12, s22, t1, t2)):
            r_shell_n = (float(t1) * float(s22) - float(t2) * float(s12)) / float(det)
            r_shell_z = (float(s11) * float(t2) - float(s12) * float(t1)) / float(det)
        else:
            r_shell_n = 0.0
            r_shell_z = 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, sN, sZ, factor in rows_fit:
            z_base.append((float(base) * float(factor) - float(r_obs)) / float(sig))
            z_shell.append(((float(base) + float(r_shell_n) * float(sN) + float(r_shell_z) * float(sZ)) * float(factor) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = (r_base + r_shell_N*S(N) + r_shell_Z*S(Z)) * sqrt(1 + (5/(4π))*beta2^2)",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "beta2_source": "NNDC B(E2) adopted entries (deformationParameter β2; extracted_beta2.json)",
            "beta2_imputation": str(beta2_imputation),
            "k_beta2": float(k_beta2),
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "beta2_counts": beta2_counts,
            "r_shell_N_fm": float(r_shell_n),
            "r_shell_Z_fm": float(r_shell_z),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
            "normal_eq": {
                "S11": float(s11),
                "S12": float(s12),
                "S22": float(s22),
                "T1": float(t1),
                "T2": float(t2),
                "det": float(det),
            },
        }
        radii_shell_fit_cache_nz_beta2[key] = out
        return out

    root = Path(__file__).resolve().parents[2]
    beta2_path = root / "data" / "quantum" / "sources" / "nndc_be2_adopted_entries" / "extracted_beta2.json"
    beta2_manifest_path = beta2_path.parent / "manifest.json"
    beta2_raw_path = beta2_path.parent / "adopted-entries.json"
    e2plus_path = Path(e2plus_path_override) if e2plus_path_override is not None else (beta2_path.parent / "extracted_e2plus.json")
    beta2_by_zn: dict[tuple[int, int], float] = {}
    if include_beta2:
        if not beta2_path.exists():
            raise SystemExit(
                "[fail] missing NNDC B(E2) deformation beta2 dataset.\n"
                "Run:\n"
                "  python -B scripts/quantum/fetch_nuclear_deformation_be2_sources.py\n"
                f"Expected: {beta2_path}"
            )
        beta2_extracted = _load_json(beta2_path)
        beta2_rows = beta2_extracted.get("rows")
        if not isinstance(beta2_rows, list) or not beta2_rows:
            raise SystemExit(f"[fail] invalid NNDC beta2 extracted dataset: rows missing/empty: {beta2_path}")
        for r in beta2_rows:
            if not isinstance(r, dict):
                continue
            Z = int(r.get("Z", -1))
            N = int(r.get("N", -1))
            b = float(r.get("beta2", float("nan")))
            if Z < 1 or N < 0 or not math.isfinite(b):
                continue
            beta2_by_zn[(int(Z), int(N))] = float(b)
        if not beta2_by_zn:
            raise SystemExit(f"[fail] NNDC beta2 map is empty after parsing: {beta2_path}")

    e2plus_by_zn: dict[tuple[int, int], float] = {}
    if include_e2plus:
        if not e2plus_path.exists():
            raise SystemExit(
                "[fail] missing spectroscopy E(2+1) dataset.\n"
                "Run:\n"
                f"  {e2plus_fetch_hint}\n"
                f"Expected: {e2plus_path}"
            )
        try:
            e2plus_by_zn = _load_nndc_e2plus_keV_by_zn(e2plus_path)
        except Exception as e:
            raise SystemExit(f"[fail] failed to parse NNDC E(2+1) dataset: {e}: {e2plus_path}") from e
        if not e2plus_by_zn:
            raise SystemExit(f"[fail] NNDC E(2+1) map is empty after parsing: {e2plus_path}")

    spectro_multi_path = Path(spectro_multi_path_override) if spectro_multi_path_override is not None else None
    spectro_multi_maps: dict[str, dict[tuple[int, int], float]] | None = None
    if include_spectro_multi:
        if spectro_multi_path is None:
            raise SystemExit("[fail] include_spectro_multi requires spectro_multi_path_override")
        if not spectro_multi_path.exists():
            raise SystemExit(
                "[fail] missing NuDat3 spectroscopy multi-metric dataset.\n"
                "Run:\n"
                f"  {spectro_multi_fetch_hint}\n"
                f"Expected: {spectro_multi_path}"
            )
        try:
            spectro_multi_maps = _load_nudat3_spectroscopy_maps(spectro_multi_path)
        except Exception as e:
            raise SystemExit(f"[fail] failed to parse NuDat3 spectroscopy dataset: {e}: {spectro_multi_path}") from e
        if not any(bool(v) for v in spectro_multi_maps.values()):
            raise SystemExit(f"[fail] NuDat3 spectroscopy maps are empty after parsing: {spectro_multi_path}")

    # Frozen HF configuration (pn mix, etc).
    metrics_hf_path = out_dir / "nuclear_a_dependence_hf_three_body_radii_frozen_metrics.json"
    if not metrics_hf_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15\n"
            f"Expected: {metrics_hf_path}"
        )
    hf = _load_json(metrics_hf_path)
    model = hf.get("model") if isinstance(hf.get("model"), dict) else {}
    pair_channels = model.get("pair_channels") if isinstance(model.get("pair_channels"), dict) else {}
    pn = pair_channels.get("pn") if isinstance(pair_channels.get("pn"), dict) else {}
    pn_triplet_weight = float(pn.get("triplet_weight", 0.5))

    # Frozen surface-term fit (C3_inf, C_surf) from Step 7.13.15.7.
    metrics_7157_path = out_dir / "nuclear_a_dependence_hf_three_body_surface_term_metrics.json"
    if not metrics_7157_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.7 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.7\n"
            f"Expected: {metrics_7157_path}"
        )
    m7157 = _load_json(metrics_7157_path)
    fit_by_eq = m7157.get("fit_by_eq")
    if not isinstance(fit_by_eq, dict) or not fit_by_eq:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: fit_by_eq missing/empty: {metrics_7157_path}")
    eq_labels = sorted(int(k) for k in fit_by_eq.keys() if str(k).isdigit())
    if not eq_labels:
        raise SystemExit(f"[fail] invalid 7.13.15.7 metrics: eq labels missing: {metrics_7157_path}")

    # Common potential inputs (eq18/eq19 sets).
    common = _load_common_inputs(out_dir=out_dir)
    pot_sets = common["pot_sets"]
    consts = common["constants"]
    hbarc = float(consts["hbarc_MeV_fm"])
    m_nucleon_c2 = float(consts["m_nucleon_c2_MeV"])

    root = Path(__file__).resolve().parents[2]
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")

    radii_by_zn: dict[tuple[int, int], tuple[float, float, str]] = {}
    radii_kink_counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
    kink_sigma_min = float(radii_kink_sigma_min)
    if include_radii_kink or include_radii_kink_delta2r:
        with radii_path.open("r", encoding="utf-8", newline="") as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    Z = int(str(row.get("z", "")).strip())
                    N = int(str(row.get("n", "")).strip())
                except Exception:
                    radii_kink_counts["skipped"] += 1
                    continue
                if Z < 1 or N < 0:
                    radii_kink_counts["skipped"] += 1
                    continue

                def fnum(key: str) -> float | None:
                    s = str(row.get(key, "")).strip()
                    if not s:
                        return None
                    try:
                        x = float(s)
                    except Exception:
                        return None
                    return float(x) if math.isfinite(x) else None

                r_val = fnum("radius_val")
                r_unc = fnum("radius_unc")
                used = "adopted"
                if r_val is None or r_unc is None:
                    r_val = fnum("radius_preliminary_val")
                    r_unc = fnum("radius_preliminary_unc")
                    used = "preliminary"

                if r_val is None or r_unc is None or not (float(r_val) > 0.0 and float(r_unc) >= 0.0):
                    radii_kink_counts["skipped"] += 1
                    continue

                radii_by_zn[(int(Z), int(N))] = (float(r_val), float(r_unc), str(used))
                radii_kink_counts[str(used)] += 1

    def kink_info_n(*, Z: int, N0: int, d: int = 2) -> tuple[float, float, float] | None:
        if not (include_radii_kink or include_radii_kink_delta2r):
            return None
        if bool(include_radii_kink_delta2r and radii_kink_delta2r_even_even_only):
            if (int(Z) % 2 != 0) or (int(N0) % 2 != 0):
                return None
        c0 = radii_by_zn.get((int(Z), int(N0)))
        cL = radii_by_zn.get((int(Z), int(N0) - int(d)))
        cR = radii_by_zn.get((int(Z), int(N0) + int(d)))
        if c0 is None or cL is None or cR is None:
            return None
        r0, s0, _ = c0
        rL, sL, _ = cL
        rR, sR, _ = cR
        if not all(math.isfinite(float(x)) for x in (r0, rL, rR, s0, sL, sR)):
            return None
        if float(s0) <= 0.0 or float(sL) <= 0.0 or float(sR) <= 0.0:
            return None
        d2 = float(rR) - 2.0 * float(r0) + float(rL)
        sig = math.sqrt(float(sR) ** 2 + 4.0 * float(s0) ** 2 + float(sL) ** 2)
        if not (math.isfinite(d2) and math.isfinite(sig) and sig > 0.0):
            return None
        return (abs(float(d2)) / float(sig), float(d2), float(sig))

    def kink_info_z(*, Z0: int, N: int, d: int = 2) -> tuple[float, float, float] | None:
        if not (include_radii_kink or include_radii_kink_delta2r):
            return None
        if bool(include_radii_kink_delta2r and radii_kink_delta2r_even_even_only):
            if (int(Z0) % 2 != 0) or (int(N) % 2 != 0):
                return None
        c0 = radii_by_zn.get((int(Z0), int(N)))
        cL = radii_by_zn.get((int(Z0) - int(d), int(N)))
        cR = radii_by_zn.get((int(Z0) + int(d), int(N)))
        if c0 is None or cL is None or cR is None:
            return None
        r0, s0, _ = c0
        rL, sL, _ = cL
        rR, sR, _ = cR
        if not all(math.isfinite(float(x)) for x in (r0, rL, rR, s0, sL, sR)):
            return None
        if float(s0) <= 0.0 or float(sL) <= 0.0 or float(sR) <= 0.0:
            return None
        d2 = float(rR) - 2.0 * float(r0) + float(rL)
        sig = math.sqrt(float(sR) ** 2 + 4.0 * float(s0) ** 2 + float(sL) ** 2)
        if not (math.isfinite(d2) and math.isfinite(sig) and sig > 0.0):
            return None
        return (abs(float(d2)) / float(sig), float(d2), float(sig))

    # Use the independently frozen isospin radius model from Step 7.13.15.23, without refitting.
    metrics_71523_path = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_metrics.json"
    if not metrics_71523_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.23 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.23\n"
            f"Expected: {metrics_71523_path}"
        )
    m71523 = _load_json(metrics_71523_path)
    radius_model_23 = m71523.get("radius_model") if isinstance(m71523.get("radius_model"), dict) else {}
    radius_model_form = str(radius_model_23.get("form", "r_charge = (r0 + rI*I)*A^(1/3), I=(N-Z)/A"))
    r0 = float(radius_model_23.get("r0_fm", float("nan")))
    rI = float(radius_model_23.get("rI_fm", float("nan")))
    fit_min_a = int(radius_model_23.get("fit_min_A", radius_fit_min_a))
    n_fit = int(radius_model_23.get("n_fit", 0))
    fit_rms = float(radius_model_23.get("fit_rms_fm", float("nan")))
    mean_I_fit = float(radius_model_23.get("mean_I_fit", float("nan")))
    if not (math.isfinite(r0) and math.isfinite(rI)):
        raise SystemExit(f"[fail] invalid 7.13.15.23 radius_model (r0/rI missing): {metrics_71523_path}")

    sigma_model_delta2r_fm = math.sqrt(6.0) * float(fit_rms) if (math.isfinite(float(fit_rms)) and float(fit_rms) > 0.0) else float("nan")

    def r_charge_pred(*, Z: int, N: int) -> float | None:
        A = int(Z) + int(N)
        if A < 2 or int(Z) < 1 or int(N) < 0:
            return None
        I = float(int(N) - int(Z)) / float(A)
        a13 = float(A) ** (1.0 / 3.0)
        r_over_a13 = float(r0) + float(rI) * float(I)
        r_charge = float(r_over_a13) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0.0):
            return None
        return float(r_charge)

    def delta2r_pred_n(*, Z: int, N0: int, d: int = 2) -> float | None:
        r0p = r_charge_pred(Z=int(Z), N=int(N0))
        rLp = r_charge_pred(Z=int(Z), N=int(N0) - int(d))
        rRp = r_charge_pred(Z=int(Z), N=int(N0) + int(d))
        if r0p is None or rLp is None or rRp is None:
            return None
        return float(rRp) - 2.0 * float(r0p) + float(rLp)

    def delta2r_pred_z(*, Z0: int, N: int, d: int = 2) -> float | None:
        r0p = r_charge_pred(Z=int(Z0), N=int(N))
        rLp = r_charge_pred(Z=int(Z0) - int(d), N=int(N))
        rRp = r_charge_pred(Z=int(Z0) + int(d), N=int(N))
        if r0p is None or rLp is None or rRp is None:
            return None
        return float(rRp) - 2.0 * float(r0p) + float(rLp)

    def shell_S_radius_factory(magic_list: list[int]):
        """
        Radius-friendly normalization of the bounded occupancy function:
          S = p(p-g)/g^2  within shell [Mk, Mk1] (0..g), so S in [-1/4, 0] independent of g.
        """
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            denom = float(g) * float(g)
            if not (math.isfinite(denom) and denom > 0):
                return 0.0
            return float(p * (p - g) / float(denom))

        return shell_S

    radii_shell_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_shell(*, shell_magic: list[int]) -> dict[str, object]:
        """
        Fit a single shell/structure DoF in the radius mapping using IAEA charge radii only.

          r_charge = r_base + r_shell * (S(N) + S(Z))

        where r_base uses the frozen (r0,rI) from Step 7.13.15.23 and
        S(x)=p(p-g)/g^2 is computed on the provided magic list.
        """
        key = tuple(int(x) for x in list(shell_magic))
        cached = radii_shell_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {"status": "skipped", "reason": "radii_by_zn is empty", "r_shell_fm": 0.0, "n_fit": 0}
            radii_shell_fit_cache[key] = out
            return out

        shell_S_r = shell_S_radius_factory(list(shell_magic))

        num = 0.0
        den = 0.0
        rows_fit: list[tuple[float, float, float, float]] = []  # (r_obs, r_base, sigma, s_sum)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue
            s_sum = float(shell_S_r(int(N)) + shell_S_r(int(Z)))
            if not math.isfinite(s_sum):
                counts["skipped"] += 1
                continue
            if abs(float(s_sum)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            num += float(w) * float(s_sum) * (float(r_obs) - float(base))
            den += float(w) * float(s_sum) * float(s_sum)
            rows_fit.append((float(r_obs), float(base), float(sig), float(s_sum)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        r_shell = float(num / den) if (math.isfinite(den) and den > 0.0 and math.isfinite(num)) else 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_shell: list[float] = []
        for r_obs, base, sig, s_sum in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_shell.append((float(base) + float(r_shell) * float(s_sum) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_shell*(S(N)+S(Z))",
            "S_shell": "p(p-g)/g^2 within magic shell (0..g); S=0 at shell edges",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_shell_fm": float(r_shell),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_shell": float(rms_sigma(z_shell)),
        }
        radii_shell_fit_cache[key] = out
        return out

    radii_odd_even_fit_cache: dict[int, dict[str, object]] = {}

    def fit_radii_odd_even() -> dict[str, object]:
        """
        Fit a minimal odd-even offset (two DoFs) in the charge-radius mapping using IAEA radii only.

          r_charge = r_base + r_oe_N*I(N odd) + r_oe_Z*I(Z odd)

        Notes:
        - r_base is the independently frozen isospin radius model (7.13.15.23).
        - This is a "structural systematics" knob (odd-even) motivated by the roadmap; it is evaluated
          under the same fixed Δ²r strict thresholds (no p-hacking).
        """
        key = int(fit_min_a)
        cached = radii_odd_even_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        if not radii_by_zn:
            out = {"status": "skipped", "reason": "radii_by_zn is empty", "r_oe_N_fm": 0.0, "r_oe_Z_fm": 0.0, "n_fit": 0}
            radii_odd_even_fit_cache[key] = out
            return out

        s11 = 0.0
        s12 = 0.0
        s22 = 0.0
        t1 = 0.0
        t2 = 0.0
        rows_fit: list[tuple[float, float, float, float, float]] = []  # (r_obs, r_base, sigma, eN, eZ)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue

            eN = 1.0 if (int(N) % 2 != 0) else 0.0
            eZ = 1.0 if (int(Z) % 2 != 0) else 0.0
            w = 1.0 / (sig * sig)
            y = float(r_obs) - float(base)
            s11 += float(w) * float(eN) * float(eN)
            s12 += float(w) * float(eN) * float(eZ)
            s22 += float(w) * float(eZ) * float(eZ)
            t1 += float(w) * float(eN) * float(y)
            t2 += float(w) * float(eZ) * float(y)
            rows_fit.append((float(r_obs), float(base), float(sig), float(eN), float(eZ)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        det = float(s11) * float(s22) - float(s12) * float(s12)
        if math.isfinite(det) and abs(float(det)) > 0.0 and all(math.isfinite(v) for v in (s11, s12, s22, t1, t2)):
            r_oe_n = (float(t1) * float(s22) - float(t2) * float(s12)) / float(det)
            r_oe_z = (float(s11) * float(t2) - float(s12) * float(t1)) / float(det)
        else:
            r_oe_n = 0.0
            r_oe_z = 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_oe: list[float] = []
        for r_obs, base, sig, eN, eZ in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_oe.append((float(base) + float(r_oe_n) * float(eN) + float(r_oe_z) * float(eZ) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_oe_N*I(N odd) + r_oe_Z*I(Z odd)",
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_oe_N_fm": float(r_oe_n),
            "r_oe_Z_fm": float(r_oe_z),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_odd_even": float(rms_sigma(z_oe)),
            "normal_eq": {
                "S11": float(s11),
                "S12": float(s12),
                "S22": float(s22),
                "T1": float(t1),
                "T2": float(t2),
                "det": float(det),
            },
        }
        radii_odd_even_fit_cache[key] = out
        return out

    radii_magic_offset_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_magic_offset(*, magic: list[int]) -> dict[str, object]:
        """
        Fit a minimal "magic offset" (two DoFs) in the charge-radius mapping using IAEA radii only.

          r_charge = r_base + r_magic_N*I(N in magic) + r_magic_Z*I(Z in magic)

        Notes:
        - r_base is the independently frozen isospin radius model (7.13.15.23).
        - This adds a discrete offset at shell closures, allowing Δ²r spikes at magic numbers (step=2).
        """
        key = tuple([int(fit_min_a)] + [int(x) for x in list(magic)])
        cached = radii_magic_offset_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        magic_set = {int(x) for x in list(magic) if int(x) > 0}
        if not magic_set:
            out = {
                "status": "skipped",
                "reason": "magic_set is empty",
                "magic": [],
                "r_magic_N_fm": 0.0,
                "r_magic_Z_fm": 0.0,
                "n_fit": 0,
            }
            radii_magic_offset_fit_cache[key] = out
            return out

        if not radii_by_zn:
            out = {
                "status": "skipped",
                "reason": "radii_by_zn is empty",
                "magic": sorted(magic_set),
                "r_magic_N_fm": 0.0,
                "r_magic_Z_fm": 0.0,
                "n_fit": 0,
            }
            radii_magic_offset_fit_cache[key] = out
            return out

        s11 = 0.0
        s12 = 0.0
        s22 = 0.0
        t1 = 0.0
        t2 = 0.0
        rows_fit: list[tuple[float, float, float, float, float]] = []  # (r_obs, r_base, sigma, eN, eZ)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue

            eN = 1.0 if int(N) in magic_set else 0.0
            eZ = 1.0 if int(Z) in magic_set else 0.0
            w = 1.0 / (sig * sig)
            y = float(r_obs) - float(base)
            s11 += float(w) * float(eN) * float(eN)
            s12 += float(w) * float(eN) * float(eZ)
            s22 += float(w) * float(eZ) * float(eZ)
            t1 += float(w) * float(eN) * float(y)
            t2 += float(w) * float(eZ) * float(y)
            rows_fit.append((float(r_obs), float(base), float(sig), float(eN), float(eZ)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        det = float(s11) * float(s22) - float(s12) * float(s12)
        if math.isfinite(det) and abs(float(det)) > 0.0 and all(math.isfinite(v) for v in (s11, s12, s22, t1, t2)):
            r_magic_n = (float(t1) * float(s22) - float(t2) * float(s12)) / float(det)
            r_magic_z = (float(s11) * float(t2) - float(s12) * float(t1)) / float(det)
        else:
            r_magic_n = 0.0
            r_magic_z = 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_magic: list[float] = []
        for r_obs, base, sig, eN, eZ in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_magic.append((float(base) + float(r_magic_n) * float(eN) + float(r_magic_z) * float(eZ) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_magic_N*I(N in magic) + r_magic_Z*I(Z in magic)",
            "magic": sorted(magic_set),
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_magic_N_fm": float(r_magic_n),
            "r_magic_Z_fm": float(r_magic_z),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_magic_offset": float(rms_sigma(z_magic)),
            "normal_eq": {
                "S11": float(s11),
                "S12": float(s12),
                "S22": float(s22),
                "T1": float(t1),
                "T2": float(t2),
                "det": float(det),
            },
        }
        radii_magic_offset_fit_cache[key] = out
        return out

    radii_magic_offset_neighbors_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_magic_offset_neighbors(*, magic: list[int], neighbor_weight: float = 0.5, neighbor_step: int = 2) -> dict[str, object]:
        """
        Fit a minimal "magic offset" (two DoFs) in the charge-radius mapping using IAEA radii only,
        but spread the indicator weight to the Δ² stencil neighbors (±neighbor_step).

          w_magic(x) = 1               if x in magic
                      neighbor_weight  if x±neighbor_step in magic
                      0               otherwise

          r_charge = r_base + r_magic_N*w_magic(N) + r_magic_Z*w_magic(Z)

        Notes:
        - Keeps the model linear in (r_magic_N, r_magic_Z) so weighted LS is closed-form.
        - Intended to reduce Δ²r overshoot when a pure center-only offset is used.
        """
        if not (math.isfinite(float(neighbor_weight)) and 0.0 <= float(neighbor_weight) <= 1.0):
            raise ValueError("neighbor_weight must be finite and within [0,1]")
        if int(neighbor_step) <= 0:
            raise ValueError("neighbor_step must be >= 1")
        key = tuple([int(fit_min_a), int(round(float(neighbor_weight) * 1000)), int(neighbor_step)] + [int(x) for x in list(magic)])
        cached = radii_magic_offset_neighbors_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        magic_set = {int(x) for x in list(magic) if int(x) > 0}
        if not magic_set:
            out = {
                "status": "skipped",
                "reason": "magic_set is empty",
                "magic": [],
                "neighbor_weight": float(neighbor_weight),
                "neighbor_step": int(neighbor_step),
                "r_magic_N_fm": 0.0,
                "r_magic_Z_fm": 0.0,
                "n_fit": 0,
            }
            radii_magic_offset_neighbors_fit_cache[key] = out
            return out

        if not radii_by_zn:
            out = {
                "status": "skipped",
                "reason": "radii_by_zn is empty",
                "magic": sorted(magic_set),
                "neighbor_weight": float(neighbor_weight),
                "neighbor_step": int(neighbor_step),
                "r_magic_N_fm": 0.0,
                "r_magic_Z_fm": 0.0,
                "n_fit": 0,
            }
            radii_magic_offset_neighbors_fit_cache[key] = out
            return out

        def w_magic(x: int) -> float:
            if int(x) in magic_set:
                return 1.0
            if (int(x) - int(neighbor_step)) in magic_set or (int(x) + int(neighbor_step)) in magic_set:
                return float(neighbor_weight)
            return 0.0

        s11 = 0.0
        s12 = 0.0
        s22 = 0.0
        t1 = 0.0
        t2 = 0.0
        rows_fit: list[tuple[float, float, float, float, float]] = []  # (r_obs, r_base, sigma, wN, wZ)
        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue

            wN = float(w_magic(int(N)))
            wZ = float(w_magic(int(Z)))
            if not (math.isfinite(wN) and math.isfinite(wZ)):
                counts["skipped"] += 1
                continue
            if abs(float(wN)) + abs(float(wZ)) < 1e-15:
                continue
            w = 1.0 / (sig * sig)
            y = float(r_obs) - float(base)
            s11 += float(w) * float(wN) * float(wN)
            s12 += float(w) * float(wN) * float(wZ)
            s22 += float(w) * float(wZ) * float(wZ)
            t1 += float(w) * float(wN) * float(y)
            t2 += float(w) * float(wZ) * float(y)
            rows_fit.append((float(r_obs), float(base), float(sig), float(wN), float(wZ)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        det = float(s11) * float(s22) - float(s12) * float(s12)
        if math.isfinite(det) and abs(float(det)) > 0.0 and all(math.isfinite(v) for v in (s11, s12, s22, t1, t2)):
            r_magic_n = (float(t1) * float(s22) - float(t2) * float(s12)) / float(det)
            r_magic_z = (float(s11) * float(t2) - float(s12) * float(t1)) / float(det)
        else:
            r_magic_n = 0.0
            r_magic_z = 0.0

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_magic: list[float] = []
        for r_obs, base, sig, wN, wZ in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            z_magic.append((float(base) + float(r_magic_n) * float(wN) + float(r_magic_z) * float(wZ) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + r_magic_N*w_magic(N) + r_magic_Z*w_magic(Z)",
            "w_magic": {
                "magic": sorted(magic_set),
                "neighbor_weight": float(neighbor_weight),
                "neighbor_step": int(neighbor_step),
            },
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "r_magic_N_fm": float(r_magic_n),
            "r_magic_Z_fm": float(r_magic_z),
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_magic_offset_neighbors": float(rms_sigma(z_magic)),
            "normal_eq": {
                "S11": float(s11),
                "S12": float(s12),
                "S22": float(s22),
                "T1": float(t1),
                "T2": float(t2),
                "det": float(det),
            },
        }
        radii_magic_offset_neighbors_fit_cache[key] = out
        return out

    radii_magic_offset_per_magic_fit_cache: dict[tuple[int, ...], dict[str, object]] = {}

    def fit_radii_magic_offset_per_magic(*, magic: list[int]) -> dict[str, object]:
        """
        Fit a per-magic-number offset in the charge-radius mapping using IAEA radii only.

          r_charge = r_base + Σ r_magic_N[m]*I(N==m) + Σ r_magic_Z[m]*I(Z==m)

        Notes:
        - r_base is the independently frozen isospin radius model (7.13.15.23).
        - Keeps the model linear and uses weighted LS (normal equations).
        - The parameter list is the provided magic list (filtered to positive unique ints), for both N and Z.
        """
        magic_list = sorted({int(x) for x in list(magic) if int(x) > 0})
        key = tuple([int(fit_min_a)] + [int(x) for x in magic_list])
        cached = radii_magic_offset_per_magic_fit_cache.get(key)
        if isinstance(cached, dict):
            return cached

        if not magic_list:
            out = {
                "status": "skipped",
                "reason": "magic_list is empty",
                "magic": [],
                "fit_min_A": int(fit_min_a),
                "n_fit": 0,
                "n_params_total": 0,
                "n_params_solved": 0,
                "coeffs": {"N": {}, "Z": {}},
            }
            radii_magic_offset_per_magic_fit_cache[key] = out
            return out

        if not radii_by_zn:
            out = {
                "status": "skipped",
                "reason": "radii_by_zn is empty",
                "magic": list(magic_list),
                "fit_min_A": int(fit_min_a),
                "n_fit": 0,
                "n_params_total": int(2 * len(magic_list)),
                "n_params_solved": 0,
                "coeffs": {"N": {int(m): 0.0 for m in magic_list}, "Z": {int(m): 0.0 for m in magic_list}},
            }
            radii_magic_offset_per_magic_fit_cache[key] = out
            return out

        idx_N = {int(m): i for i, m in enumerate(magic_list)}
        idx_Z = {int(m): int(len(magic_list)) + i for i, m in enumerate(magic_list)}
        n_params = int(2 * len(magic_list))

        counts = {"adopted": 0, "preliminary": 0, "skipped": 0}
        rows_fit: list[tuple[float, float, float, int, int]] = []  # (r_obs, r_base, sigma, Z, N)
        used_counts = [0] * n_params

        # Build normal equations (sparse updates; A has <=2 ones per row).
        M = [[0.0 for _ in range(n_params)] for _ in range(n_params)]
        bvec = [0.0 for _ in range(n_params)]

        for (Z, N), (r_obs, r_sig, used) in radii_by_zn.items():
            A = int(Z) + int(N)
            if A < int(fit_min_a):
                continue
            sig = float(r_sig)
            if not (math.isfinite(sig) and sig > 0.0):
                counts["skipped"] += 1
                continue
            base = r_charge_pred(Z=int(Z), N=int(N))
            if base is None:
                counts["skipped"] += 1
                continue

            active: list[int] = []
            if int(N) in idx_N:
                active.append(int(idx_N[int(N)]))
            if int(Z) in idx_Z:
                active.append(int(idx_Z[int(Z)]))
            if not active:
                continue

            w = 1.0 / (sig * sig)
            y = float(r_obs) - float(base)
            for i in active:
                used_counts[int(i)] += 1
                bvec[int(i)] += float(w) * float(y)
                for j in active:
                    M[int(i)][int(j)] += float(w)

            rows_fit.append((float(r_obs), float(base), float(sig), int(Z), int(N)))
            counts[str(used) if str(used) in counts else "adopted"] += 1

        if not rows_fit:
            out = {
                "status": "skipped",
                "reason": "no fit rows after filtering",
                "magic": list(magic_list),
                "fit_min_A": int(fit_min_a),
                "n_fit": 0,
                "counts": counts,
                "n_params_total": int(n_params),
                "n_params_solved": 0,
                "coeffs": {"N": {int(m): 0.0 for m in magic_list}, "Z": {int(m): 0.0 for m in magic_list}},
            }
            radii_magic_offset_per_magic_fit_cache[key] = out
            return out

        # Drop unconstrained parameters to avoid singular normal equations.
        active_params = [i for i in range(n_params) if int(used_counts[i]) > 0]
        n_active = int(len(active_params))
        if n_active == 0:
            out = {
                "status": "skipped",
                "reason": "no constrained magic parameters in fit domain",
                "magic": list(magic_list),
                "fit_min_A": int(fit_min_a),
                "n_fit": int(len(rows_fit)),
                "counts": counts,
                "n_params_total": int(n_params),
                "n_params_solved": 0,
                "coeffs": {"N": {int(m): 0.0 for m in magic_list}, "Z": {int(m): 0.0 for m in magic_list}},
            }
            radii_magic_offset_per_magic_fit_cache[key] = out
            return out

        MM = [[float(M[i][j]) for j in active_params] for i in active_params]
        bb = [float(bvec[i]) for i in active_params]

        def solve_gauss(a: list[list[float]], x: list[float]) -> list[float] | None:
            n = len(x)
            aug = [list(map(float, a[i])) + [float(x[i])] for i in range(n)]
            eps = 1e-18
            for i in range(n):
                pivot = max(range(i, n), key=lambda r: abs(float(aug[r][i])))
                if abs(float(aug[pivot][i])) < eps:
                    return None
                if pivot != i:
                    aug[i], aug[pivot] = aug[pivot], aug[i]
                piv = float(aug[i][i])
                inv = 1.0 / float(piv)
                for k in range(i, n + 1):
                    aug[i][k] = float(aug[i][k]) * float(inv)
                for r in range(n):
                    if r == i:
                        continue
                    factor = float(aug[r][i])
                    if abs(float(factor)) < 1e-30:
                        continue
                    for k in range(i, n + 1):
                        aug[r][k] = float(aug[r][k]) - float(factor) * float(aug[i][k])
            return [float(aug[i][n]) for i in range(n)]

        coeff_active = solve_gauss(MM, bb)
        if coeff_active is None:
            # Ridge fallback (tiny diagonal) to handle near-singular cases.
            diag_max = max((abs(float(MM[i][i])) for i in range(n_active)), default=0.0)
            lam = max(1e-12 * float(diag_max), 1e-12)
            for i in range(n_active):
                MM[i][i] = float(MM[i][i]) + float(lam)
            coeff_active = solve_gauss(MM, bb)
        if coeff_active is None:
            coeff_active = [0.0 for _ in range(n_active)]

        coeffs = [0.0] * n_params
        for idx, i_full in enumerate(active_params):
            coeffs[int(i_full)] = float(coeff_active[int(idx)])

        coeffs_N = {int(m): float(coeffs[int(idx_N[int(m)])]) for m in magic_list}
        coeffs_Z = {int(m): float(coeffs[int(idx_Z[int(m)])]) for m in magic_list}

        def rms_sigma(vals: list[float]) -> float:
            return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

        z_base: list[float] = []
        z_magic: list[float] = []
        for r_obs, base, sig, Z, N in rows_fit:
            z_base.append((float(base) - float(r_obs)) / float(sig))
            dm = float(coeffs_N.get(int(N), 0.0)) + float(coeffs_Z.get(int(Z), 0.0))
            z_magic.append((float(base) + float(dm) - float(r_obs)) / float(sig))

        out = {
            "status": "ok",
            "form": "r_charge = r_base + Σ r_magic_N[m]*I(N==m) + Σ r_magic_Z[m]*I(Z==m)",
            "magic": list(magic_list),
            "fit_min_A": int(fit_min_a),
            "n_fit": int(len(rows_fit)),
            "counts": counts,
            "n_params_total": int(n_params),
            "n_params_solved": int(n_active),
            "coeffs": {"N": coeffs_N, "Z": coeffs_Z},
            "rms_resid_sigma_base": float(rms_sigma(z_base)),
            "rms_resid_sigma_magic_offset_per_magic": float(rms_sigma(z_magic)),
        }
        radii_magic_offset_per_magic_fit_cache[key] = out
        return out

    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")

    # Map: (Z,N) -> (A, B/A, sigma, symbol)
    ame_map: dict[tuple[int, int], dict[str, object]] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        ba_sig_keV = float(r.get("binding_sigma_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ame_map[(Z, N)] = {
            "A": int(A),
            "symbol": str(r.get("symbol", "")),
            "B_over_A_obs_MeV": float(ba_keV) / 1000.0,
            "sigma_B_over_A_obs_MeV": (float(ba_sig_keV) / 1000.0) if math.isfinite(ba_sig_keV) else 0.0,
        }
    if not ame_map:
        raise SystemExit("[fail] AME2020 map is empty after parsing (unexpected)")

    # Deterministic finite-size Coulomb model:
    # - direct: 2pF profile (fixed diffuseness a), c determined from r_rms via bisection
    # - exchange: Slater (LDA) on the same non-uniform density
    e2_mev_fm = 1.43996448
    coef_slater = -(3.0 / 4.0) * ((3.0 / math.pi) ** (1.0 / 3.0))
    fourpi_m13 = (4.0 * math.pi) ** (-1.0 / 3.0)
    a_diff_fm = 0.523
    dr_fm = 0.02
    cache_round_fm = 1e-3

    finite_cache: dict[int, dict[str, float]] = {}

    def finite_size_coeffs_for_rms(*, r_rms_fm: float) -> dict[str, float]:
        key = int(round(float(r_rms_fm) / float(cache_round_fm)))
        if key in finite_cache:
            return finite_cache[int(key)]
        target_r_rms = float(key) * float(cache_round_fm)
        if not (math.isfinite(target_r_rms) and target_r_rms > 0):
            raise RuntimeError("invalid r_rms")

        c_guess2 = (5.0 / 3.0) * (target_r_rms**2) - (7.0 / 3.0) * ((math.pi * float(a_diff_fm)) ** 2)
        c_guess = math.sqrt(c_guess2) if c_guess2 > 0 else max(0.1, float(target_r_rms) * 0.5)

        def rms_from_c(c_fm: float) -> float:
            if not (math.isfinite(c_fm) and c_fm > 0):
                return float("nan")
            r_max = max(20.0, 3.0 * float(target_r_rms) + 20.0 * float(a_diff_fm))
            n = int(math.ceil(r_max / float(dr_fm)))
            I2 = 0.0
            I4 = 0.0
            for i in range(n):
                r = (float(i) + 0.5) * float(dr_fm)
                f = 1.0 / (1.0 + math.exp((float(r) - float(c_fm)) / float(a_diff_fm)))
                r2 = float(r) * float(r)
                I2 += r2 * float(f)
                I4 += (r2 * r2) * float(f)
            I2 *= float(dr_fm)
            I4 *= float(dr_fm)
            if not (math.isfinite(I2) and I2 > 0 and math.isfinite(I4) and I4 > 0):
                return float("nan")
            return math.sqrt(float(I4) / float(I2))

        # Bracket and bisection (few iterations; cached per-quantized r_rms).
        lo = max(0.05, 0.25 * float(c_guess))
        hi = max(lo * 1.1, 3.0 * float(c_guess) + 10.0 * float(a_diff_fm))
        for _ in range(6):
            r_lo = rms_from_c(lo)
            r_hi = rms_from_c(hi)
            if not (math.isfinite(r_lo) and math.isfinite(r_hi)):
                hi *= 1.5
                continue
            if r_lo <= target_r_rms <= r_hi:
                break
            if target_r_rms < r_lo:
                lo *= 0.7
            else:
                hi *= 1.5

        c = float(c_guess)
        for _ in range(18):
            mid = 0.5 * (float(lo) + float(hi))
            r_mid = rms_from_c(mid)
            if not math.isfinite(r_mid):
                break
            c = float(mid)
            if r_mid < target_r_rms:
                lo = float(mid)
            else:
                hi = float(mid)

        # Coefficients for the final c.
        r_max = max(20.0, 3.0 * float(target_r_rms) + 20.0 * float(a_diff_fm))
        n = int(math.ceil(r_max / float(dr_fm)))
        rs: list[float] = []
        fs: list[float] = []
        g2: list[float] = []
        h1: list[float] = []
        I2 = 0.0
        I2_43 = 0.0
        for i in range(n):
            r = (float(i) + 0.5) * float(dr_fm)
            f = 1.0 / (1.0 + math.exp((float(r) - float(c)) / float(a_diff_fm)))
            rs.append(float(r))
            fs.append(float(f))
            r2 = float(r) * float(r)
            g2_i = r2 * float(f)
            g2.append(float(g2_i))
            h1.append(float(r) * float(f))
            I2 += float(g2_i)
            I2_43 += float(r2) * (float(f) ** (4.0 / 3.0))
        I2 *= float(dr_fm)
        I2_43 *= float(dr_fm)
        if not (math.isfinite(I2) and I2 > 0 and math.isfinite(I2_43) and I2_43 > 0):
            raise RuntimeError("finite-size integrals failed")

        # A0(r)=∫_0^r f(r') r'^2 dr'  and  B0(r)=∫_r^∞ f(r') r' dr'  (no 4π).
        A0: list[float] = []
        acc = 0.0
        for v in g2:
            acc += float(v) * float(dr_fm)
            A0.append(float(acc))
        B0 = [0.0] * n
        acc = 0.0
        for i in range(n - 1, -1, -1):
            acc += float(h1[i]) * float(dr_fm)
            B0[i] = float(acc)

        J = 0.0
        for r, f, a0, b0 in zip(rs, fs, A0, B0, strict=True):
            J += (float(r) * float(f) * float(a0) + (float(r) ** 2) * float(f) * float(b0))
        J *= float(dr_fm)

        e_dir_unit_over_e2 = 0.5 * float(J) / (float(I2) ** 2)  # [fm^-1]
        i43_unit = float(fourpi_m13) * float(I2_43) / (float(I2) ** (4.0 / 3.0))  # [fm^-1]
        rms_check = rms_from_c(float(c))

        out = {
            "r_rms_fm": float(target_r_rms),
            "c_fm": float(c),
            "rms_check_fm": float(rms_check) if math.isfinite(rms_check) else float("nan"),
            "e_dir_unit_over_e2_fm_1": float(e_dir_unit_over_e2),
            "i43_unit_fm_1": float(i43_unit),
        }
        finite_cache[int(key)] = out
        return out

    # Predict B (total) for the expanded AME2020 set using the frozen isospin radius model + Coulomb finite-size correction.
    a_by_zn_all: dict[tuple[int, int], int] = {}
    b_obs_all: dict[tuple[int, int], float] = {}
    b_pred_all: dict[tuple[int, int], float] = {}
    n_skipped = 0
    n_beta2_direct = 0
    n_beta2_imputed = 0
    n_beta2_missing = 0

    for (Z, N), v in ame_map.items():
        A = int(v["A"])
        if A < int(domain_min_a):
            continue
        ba_obs = float(v["B_over_A_obs_MeV"])
        if not math.isfinite(ba_obs):
            continue
        I = float(int(N) - int(Z)) / float(A)

        a13 = float(A) ** (1.0 / 3.0)
        r_over_a13 = float(r0) + float(rI) * float(I)
        r_charge = float(r_over_a13) * float(a13)
        if not (math.isfinite(r_charge) and r_charge > 0):
            n_skipped += 1
            continue
        R_sharp = _sharp_radius_from_rms(float(r_charge))
        if not (math.isfinite(R_sharp) and R_sharp > 0):
            n_skipped += 1
            continue
        V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
        rho = float(A) / float(V_sphere)
        if not (math.isfinite(rho) and rho > 0):
            n_skipped += 1
            continue

        beta2_val, beta2_mode = _beta2_for_zn(
            Z=int(Z), N=int(N), beta2_by_zn=beta2_by_zn, include_beta2=include_beta2, imputation=str(beta2_imputation)
        )
        shape_factor = _coulomb_shape_factor_from_beta2(beta2=float(beta2_val), include_beta2=include_beta2)
        surface_factor = _surface_area_factor_from_beta2(
            beta2=float(beta2_val), include_beta2=bool(include_beta2 and beta2_apply_surface)
        )

        if include_beta2:
            if beta2_mode == "direct":
                n_beta2_direct += 1
            elif beta2_mode == "imputed":
                n_beta2_imputed += 1
            elif beta2_mode == "missing":
                n_beta2_missing += 1

        cpack = finite_size_coeffs_for_rms(r_rms_fm=float(r_charge))
        e_dir_unit = float(cpack["e_dir_unit_over_e2_fm_1"]) * float(shape_factor)
        i43_unit = float(cpack["i43_unit_fm_1"]) * float(shape_factor)

        preds: dict[int, float] = {}
        for eq in eq_labels:
            fk = fit_by_eq.get(str(eq))
            if not isinstance(fk, dict):
                continue
            c3_inf = float(fk.get("C3_inf", float("nan")))
            c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
            if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                continue
            base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                A=int(A),
                Z=int(Z),
                N=int(N),
                R_sharp_fm=float(R_sharp),
                pot_sets=pot_sets,
                eq=int(eq),
                pn_triplet_weight=float(pn_triplet_weight),
                hbarc_mev_fm=float(hbarc),
                m_nucleon_c2_mev=float(m_nucleon_c2),
            )
            base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            e_coul_uniform = float(base_pack.get("Coul", float("nan"))) if isinstance(base_pack, dict) else float("nan")
            if not (math.isfinite(base_e) and math.isfinite(e_coul_uniform)):
                continue

            # Replace uniform-sphere Coulomb direct with 2pF direct, and add 2pF Slater exchange (LDA).
            if int(Z) <= 1:
                e_dir_fs = 0.0
                e_x_fs = 0.0
            else:
                e_dir_fs = float(e2_mev_fm) * float(Z * (Z - 1)) * float(e_dir_unit) / float(A)
                e_x_fs = float(coef_slater) * float(e2_mev_fm) * (float(Z) ** (4.0 / 3.0)) * float(i43_unit) / float(A)

            e_coul_fs = (float(e_dir_fs) - float(e_coul_uniform)) + float(e_x_fs)
            e_total = float(base_e) + float(e_coul_fs) + float(c3_inf) * (float(rho) ** 2) + float(c_surf) / (6.0 * float(R_sharp))
            ba_pred = -float(e_total)
            if math.isfinite(ba_pred):
                preds[int(eq)] = float(ba_pred)

        if not preds:
            n_skipped += 1
            continue
        if 18 in preds and 19 in preds:
            ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
        else:
            ba_pred_mean = float(next(iter(preds.values())))

        a_by_zn_all[(int(Z), int(N))] = int(A)
        b_obs_all[(int(Z), int(N))] = float(A) * float(ba_obs)
        b_pred_all[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

    if not a_by_zn_all:
        raise SystemExit(f"[fail] no in-domain nuclei (A>={domain_min_a}) found after radius-model prediction")

    # Candidate domain boundaries (same as Step 7.13.15.22).
    scan_a_mins = sorted({int(domain_min_a), 40, 60, 80, 100})
    scan_a_mins = [a for a in scan_a_mins if a >= int(domain_min_a)]

    def rms(vals: list[float]) -> float:
        return math.sqrt(sum(v * v for v in vals) / len(vals)) if vals else float("nan")

    OBS_MAGIC = [0, 2, 8, 20, 28, 50, 82, 126, 184]
    TRAIN_MAGIC = {50, 82}
    MODEL_MAGIC = [0, 2, 8, 14, 20, 28, 50, 76, 82, 114, 164, 210]
    shell_variants = [
        {"name": "model_magic", "magic": list(MODEL_MAGIC), "note": "S_shell uses model magic list (legacy in 7.13.15.*)."},
        {"name": "obs_magic", "magic": list(OBS_MAGIC), "note": "S_shell uses observed magic list (domain-independent mapping)."},
    ]

    def _median(vals: list[float]) -> float:
        if not vals:
            return float("nan")
        s = sorted(vals)
        mid = len(s) // 2
        return float(s[mid]) if (len(s) % 2) else float(0.5 * (s[mid - 1] + s[mid]))

    def near_observed_magic(x: int, *, tol: int = 1) -> bool:
        return any(abs(int(x) - int(m0)) <= int(tol) for m0 in OBS_MAGIC)

    def shell_S_factory(magic_list: list[int]):
        magic = list(magic_list)

        def shell_S(x: int) -> float:
            if x <= 0:
                return 0.0
            Mk = None
            Mk1 = None
            for a, b in zip(magic[:-1], magic[1:], strict=True):
                if int(a) < int(x) <= int(b):
                    Mk = int(a)
                    Mk1 = int(b)
                    break
            if Mk is None or Mk1 is None:
                Mk = int(magic[-2])
                Mk1 = int(magic[-1])
                if x > Mk1:
                    Mk = int(magic[-1])
                    Mk1 = int(magic[-1] + 1)
            g = int(Mk1 - Mk)
            if g <= 0:
                return 0.0
            p = int(x - Mk)
            if p < 0:
                p = 0
            if p > g:
                p = g
            denom = float(g) ** float(shell_s_power_g)
            if not (math.isfinite(denom) and denom > 0):
                return 0.0
            return float(p * (p - g) / float(denom))

        return shell_S

    # Helpers for separations and gaps.
    def build_sep_n(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dN: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (Z, int(N) - int(dN))
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_sep_p(a_by_zn: dict[tuple[int, int], int], b_map: dict[tuple[int, int], float], *, dZ: int) -> dict[tuple[int, int], float]:
        out: dict[tuple[int, int], float] = {}
        for (Z, N) in a_by_zn.keys():
            child = (int(Z) - int(dZ), N)
            if child not in a_by_zn:
                continue
            out[(Z, N)] = float(b_map[(Z, N)] - b_map[child])
        return out

    def build_gap_n(sn_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for N0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sn_map.items()):
                if int(N) != int(N0):
                    continue
                nxt = (Z, int(N0) + int(step))
                if nxt not in sn_map:
                    continue
                out[(int(Z), int(N0), int(step))] = float(sn_map[(Z, int(N0))] - sn_map[nxt])
        return out

    def build_gap_p(sp_map: dict[tuple[int, int], float], *, step: int) -> dict[tuple[int, int, int], float]:
        out: dict[tuple[int, int, int], float] = {}
        for Z0 in OBS_MAGIC[1:]:
            for (Z, N), _val in list(sp_map.items()):
                if int(Z) != int(Z0):
                    continue
                nxt = (int(Z0) + int(step), N)
                if nxt not in sp_map:
                    continue
                out[(int(N), int(Z0), int(step))] = float(sp_map[(int(Z0), N)] - sp_map[nxt])
        return out

    def summarize_gaps(
        g_obs: dict[tuple[int, int, int], float],
        g_unc: dict[tuple[int, int, int], float],
        g_base: dict[tuple[int, int, int], float],
        g_cor: dict[tuple[int, int, int], float],
    ) -> dict[str, object]:
        rows_train: list[tuple[float, float, float]] = []
        rows_other: list[tuple[float, float, float]] = []
        by_magic: dict[int, list[tuple[float, float, float]]] = {}
        for key, obs in g_obs.items():
            gu = g_unc.get(key)
            gb = g_base.get(key)
            gc = g_cor.get(key)
            if gu is None or gb is None or gc is None:
                continue
            magic = int(key[1])
            resid_u = float(gu - obs)
            resid_b = float(gb - obs)
            resid_c = float(gc - obs)
            by_magic.setdefault(magic, []).append((resid_u, resid_b, resid_c))
            if magic in TRAIN_MAGIC:
                rows_train.append((resid_u, resid_b, resid_c))
            else:
                rows_other.append((resid_u, resid_b, resid_c))

        def _r(idx: int, rows: list[tuple[float, float, float]]) -> float:
            return rms([float(r[idx]) for r in rows])

        by_magic_rows: dict[str, dict[str, object]] = {}
        for m, rows in sorted(by_magic.items()):
            by_magic_rows[str(int(m))] = {
                "n": int(len(rows)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows)),
            }

        return {
            "train_magic": {
                "n": int(len(rows_train)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_train)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_train)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_train)),
            },
            "other_magic": {
                "n": int(len(rows_other)),
                "rms_resid_uncorrected_MeV": float(_r(0, rows_other)),
                "rms_resid_pairing_only_MeV": float(_r(1, rows_other)),
                "rms_resid_pairing_shell_MeV": float(_r(2, rows_other)),
            },
            "by_magic": by_magic_rows,
        }

    # Run the same frozen protocol as Step 7.13.15.22 on the expanded set.
    def hw_mev(A: int) -> float:
        return float(41.0 * (float(A) ** (-1.0 / 3.0))) if A > 0 else float("nan")

    def fit2d(yx0x1: list[tuple[float, float, float]]) -> tuple[float, float]:
        # Solve min ||y - k0*x0 - k1*x1||^2 via 2x2 normal equations.
        if len(yx0x1) < 2:
            return float("nan"), float("nan")
        s00 = 0.0
        s01 = 0.0
        s11 = 0.0
        t0 = 0.0
        t1 = 0.0
        for y, x0, x1 in yx0x1:
            s00 += float(x0) * float(x0)
            s01 += float(x0) * float(x1)
            s11 += float(x1) * float(x1)
            t0 += float(x0) * float(y)
            t1 += float(x1) * float(y)
        det = float(s00) * float(s11) - float(s01) * float(s01)
        if not (math.isfinite(det) and abs(det) > 1e-18 and math.isfinite(s00) and math.isfinite(s11)):
            # fallback: use x0 only
            if math.isfinite(s00) and s00 > 0:
                return float(t0 / s00), 0.0
            if math.isfinite(s11) and s11 > 0:
                return 0.0, float(t1 / s11)
            return float("nan"), float("nan")
        k0 = (float(t0) * float(s11) - float(t1) * float(s01)) / float(det)
        k1 = (float(t1) * float(s00) - float(t0) * float(s01)) / float(det)
        return float(k0), float(k1)

    def scan_rows(*, b_pred_all_map: dict[tuple[int, int], float]) -> list[dict[str, object]]:
        def run_config(*, a_min: int, shell_magic: list[int]) -> dict[str, object]:
            # Domain slice
            a_by_zn = {zn: A for zn, A in a_by_zn_all.items() if int(A) >= int(a_min)}
            b_obs = {zn: b_obs_all[zn] for zn in a_by_zn.keys()}
            b_pred = {zn: b_pred_all_map[zn] for zn in a_by_zn.keys()}
            if not a_by_zn:
                raise RuntimeError(f"empty domain slice at A_min={a_min}")

            # Freeze pairing (a_n, a_p) from OES (3-point) on B_obs.
            an_list: list[float] = []
            ap_list: list[float] = []
            for (Z, N), A in a_by_zn.items():
                if near_observed_magic(int(N), tol=1) or near_observed_magic(int(Z), tol=1):
                    continue
                if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
                    dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
                    if math.isfinite(dn):
                        an_list.append(abs(float(dn)) * math.sqrt(float(A)) / 2.0)
                if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
                    dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
                    if math.isfinite(dp):
                        ap_list.append(abs(float(dp)) * math.sqrt(float(A)) / 2.0)
            a_n = _median(an_list)
            a_p = _median(ap_list)
            if not (math.isfinite(a_n) and math.isfinite(a_p)):
                raise RuntimeError(f"pairing freeze failed (no OES samples) at A_min={a_min}")

            # Pairing baseline binding energies.
            b_base: dict[tuple[int, int], float] = {}
            for (Z, N), A in a_by_zn.items():
                term_n = float(a_n) * float(((-1) ** int(N))) / math.sqrt(float(A))
                term_p = float(a_p) * float(((-1) ** int(Z))) / math.sqrt(float(A))
                b_base[(Z, N)] = float(b_pred[(Z, N)]) + float(term_n) + float(term_p)

            # Shell correction basis terms.
            shell_S = shell_S_factory(shell_magic)
            cN0: dict[tuple[int, int], float] = {}
            cZ0: dict[tuple[int, int], float] = {}
            cN1: dict[tuple[int, int], float] = {}
            cZ1: dict[tuple[int, int], float] = {}
            for (Z, N), A in a_by_zn.items():
                hw = hw_mev(int(A))
                I = float(int(N) - int(Z)) / float(A)
                cN0[(Z, N)] = float(hw) * float(shell_S(int(N)))
                cZ0[(Z, N)] = float(hw) * float(shell_S(int(Z)))
                cN1[(Z, N)] = float(I) * float(hw) * float(shell_S(int(N)))
                cZ1[(Z, N)] = float(I) * float(hw) * float(shell_S(int(Z)))

            # Observables (obs).
            sn_obs = build_sep_n(a_by_zn, b_obs, dN=1)
            sp_obs = build_sep_p(a_by_zn, b_obs, dZ=1)
            gap_sn_obs = build_gap_n(sn_obs, step=1)
            gap_sp_obs = build_gap_p(sp_obs, step=1)

            # Predictions: uncorrected (B_pred), pairing-only (B_base).
            sn_pred_unc = build_sep_n(a_by_zn, b_pred, dN=1)
            sp_pred_unc = build_sep_p(a_by_zn, b_pred, dZ=1)
            sn_pred_base = build_sep_n(a_by_zn, b_base, dN=1)
            sp_pred_base = build_sep_p(a_by_zn, b_base, dZ=1)

            gap_sn_pred_unc = build_gap_n(sn_pred_unc, step=1)
            gap_sp_pred_unc = build_gap_p(sp_pred_unc, step=1)
            gap_sn_pred_base = build_gap_n(sn_pred_base, step=1)
            gap_sp_pred_base = build_gap_p(sp_pred_base, step=1)

            # Unit-basis maps for kN/kZ fits, around the pairing baseline.
            bN0: dict[tuple[int, int], float] = {zn: float(b0) + float(cN0[zn]) for zn, b0 in b_base.items()}
            bN1: dict[tuple[int, int], float] = {zn: float(b0) + float(cN1[zn]) for zn, b0 in b_base.items()}
            bZ0: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ0[zn]) for zn, b0 in b_base.items()}
            bZ1: dict[tuple[int, int], float] = {zn: float(b0) + float(cZ1[zn]) for zn, b0 in b_base.items()}

            gap_sn_pred_N0 = build_gap_n(build_sep_n(a_by_zn, bN0, dN=1), step=1)
            gap_sn_pred_N1 = build_gap_n(build_sep_n(a_by_zn, bN1, dN=1), step=1)
            gap_sp_pred_Z0 = build_gap_p(build_sep_p(a_by_zn, bZ0, dZ=1), step=1)
            gap_sp_pred_Z1 = build_gap_p(build_sep_p(a_by_zn, bZ1, dZ=1), step=1)

            # Fit kN(I)=kN0+kN1*I from neutron gaps at observed magic N in {50,82}.
            fit_n: list[tuple[float, float, float]] = []
            for (Z, N0, step), g_obs in gap_sn_obs.items():
                if int(step) != 1 or int(N0) not in TRAIN_MAGIC:
                    continue
                g_base = gap_sn_pred_base.get((Z, N0, 1))
                g0 = gap_sn_pred_N0.get((Z, N0, 1))
                g1 = gap_sn_pred_N1.get((Z, N0, 1))
                if g_base is None or g0 is None or g1 is None:
                    continue
                x0 = float(g0 - g_base)
                x1 = float(g1 - g_base)
                if not (math.isfinite(x0) and math.isfinite(x1)) or (abs(x0) < 1e-12 and abs(x1) < 1e-12):
                    continue
                y = float(g_obs - g_base)
                if not math.isfinite(y):
                    continue
                fit_n.append((y, x0, x1))
            if not fit_n:
                raise RuntimeError(f"no fit data for kN at A_min={a_min}")
            kN0, kN1 = fit2d(fit_n)
            if not (math.isfinite(kN0) and math.isfinite(kN1)):
                raise RuntimeError(f"failed kN(I) fit at A_min={a_min}")

            # Fit kZ(I)=kZ0+kZ1*I from proton gaps at observed magic Z in {50,82}.
            fit_z: list[tuple[float, float, float]] = []
            for (N, Z0, step), g_obs in gap_sp_obs.items():
                if int(step) != 1 or int(Z0) not in TRAIN_MAGIC:
                    continue
                g_base = gap_sp_pred_base.get((N, Z0, 1))
                g0 = gap_sp_pred_Z0.get((N, Z0, 1))
                g1 = gap_sp_pred_Z1.get((N, Z0, 1))
                if g_base is None or g0 is None or g1 is None:
                    continue
                x0 = float(g0 - g_base)
                x1 = float(g1 - g_base)
                if not (math.isfinite(x0) and math.isfinite(x1)) or (abs(x0) < 1e-12 and abs(x1) < 1e-12):
                    continue
                y = float(g_obs - g_base)
                if not math.isfinite(y):
                    continue
                fit_z.append((y, x0, x1))
            if not fit_z:
                raise RuntimeError(f"no fit data for kZ at A_min={a_min}")
            kZ0, kZ1 = fit2d(fit_z)
            if not (math.isfinite(kZ0) and math.isfinite(kZ1)):
                raise RuntimeError(f"failed kZ(I) fit at A_min={a_min}")
            ratio_kZ_over_kN = float(kZ0 / kN0) if abs(kN0) > 1e-12 else float("nan")

            # Corrected binding energies (pairing + refrozen shell with I dependence).
            b_cor: dict[tuple[int, int], float] = {}
            for zn, b0 in b_base.items():
                b_cor[zn] = float(b0) + float(kN0) * float(cN0[zn]) + float(kN1) * float(cN1[zn]) + float(kZ0) * float(cZ0[zn]) + float(kZ1) * float(cZ1[zn])

            # Corrected gap predictions.
            gap_sn_pred_cor = build_gap_n(build_sep_n(a_by_zn, b_cor, dN=1), step=1)
            gap_sp_pred_cor = build_gap_p(build_sep_p(a_by_zn, b_cor, dZ=1), step=1)

            diag_gap_sn = summarize_gaps(gap_sn_obs, gap_sn_pred_unc, gap_sn_pred_base, gap_sn_pred_cor)
            diag_gap_sp = summarize_gaps(gap_sp_obs, gap_sp_pred_unc, gap_sp_pred_base, gap_sp_pred_cor)

            spectro_pack: dict[str, object] | None = None
            pass_spectro = False
            if include_e2plus:
                def is_peak_n(*, Z: int, N0: int) -> bool:
                    e0 = e2plus_by_zn.get((int(Z), int(N0)))
                    eL = e2plus_by_zn.get((int(Z), int(N0) - 2))
                    eR = e2plus_by_zn.get((int(Z), int(N0) + 2))
                    return (
                        e0 is not None
                        and eL is not None
                        and eR is not None
                        and float(e0) > float(eL)
                        and float(e0) > float(eR)
                    )

                def is_peak_z(*, Z0: int, N: int) -> bool:
                    e0 = e2plus_by_zn.get((int(Z0), int(N)))
                    eL = e2plus_by_zn.get((int(Z0) - 2, int(N)))
                    eR = e2plus_by_zn.get((int(Z0) + 2, int(N)))
                    return (
                        e0 is not None
                        and eL is not None
                        and eR is not None
                        and float(e0) > float(eL)
                        and float(e0) > float(eR)
                    )

                def summarize_spectro_peaks_n() -> dict[str, object]:
                    n_avail = 0
                    n_peak = 0
                    rows: list[tuple[float, float, float]] = []
                    for (Z, N0, step), obs in gap_sn_obs.items():
                        if int(step) != 1:
                            continue
                        if e2plus_by_zn.get((int(Z), int(N0))) is not None:
                            n_avail += 1
                        if not is_peak_n(Z=int(Z), N0=int(N0)):
                            continue
                        n_peak += 1
                        gu = gap_sn_pred_unc.get((int(Z), int(N0), 1))
                        gb = gap_sn_pred_base.get((int(Z), int(N0), 1))
                        gc = gap_sn_pred_cor.get((int(Z), int(N0), 1))
                        if gu is None or gb is None or gc is None:
                            continue
                        rows.append((float(gu - obs), float(gb - obs), float(gc - obs)))
                    return {
                        "n_available": int(n_avail),
                        "n_peak": int(n_peak),
                        "rms_resid_uncorrected_MeV": float(rms([float(r[0]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_only_MeV": float(rms([float(r[1]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_shell_MeV": float(rms([float(r[2]) for r in rows])) if rows else float("nan"),
                    }

                def summarize_spectro_peaks_p() -> dict[str, object]:
                    n_avail = 0
                    n_peak = 0
                    rows: list[tuple[float, float, float]] = []
                    for (N, Z0, step), obs in gap_sp_obs.items():
                        if int(step) != 1:
                            continue
                        if e2plus_by_zn.get((int(Z0), int(N))) is not None:
                            n_avail += 1
                        if not is_peak_z(Z0=int(Z0), N=int(N)):
                            continue
                        n_peak += 1
                        gu = gap_sp_pred_unc.get((int(N), int(Z0), 1))
                        gb = gap_sp_pred_base.get((int(N), int(Z0), 1))
                        gc = gap_sp_pred_cor.get((int(N), int(Z0), 1))
                        if gu is None or gb is None or gc is None:
                            continue
                        rows.append((float(gu - obs), float(gb - obs), float(gc - obs)))
                    return {
                        "n_available": int(n_avail),
                        "n_peak": int(n_peak),
                        "rms_resid_uncorrected_MeV": float(rms([float(r[0]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_only_MeV": float(rms([float(r[1]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_shell_MeV": float(rms([float(r[2]) for r in rows])) if rows else float("nan"),
                    }

                spec_sn = summarize_spectro_peaks_n()
                spec_sp = summarize_spectro_peaks_p()
                pass_spectro = bool(
                    int(spec_sn.get("n_peak", 0)) > 0
                    and int(spec_sp.get("n_peak", 0)) > 0
                    and float(spec_sn.get("rms_resid_pairing_shell_MeV", float("nan")))
                    < float(spec_sn.get("rms_resid_pairing_only_MeV", float("nan")))
                    and float(spec_sp.get("rms_resid_pairing_shell_MeV", float("nan")))
                    < float(spec_sp.get("rms_resid_pairing_only_MeV", float("nan")))
                )
                spectro_pack = {
                    "source": str(e2plus_source_label),
                    "rule_peak": {
                        "gap_Sn": "E2+(Z,N0) > E2+(Z,N0±2) when neighbors exist (even-even only)",
                        "gap_Sp": "E2+(Z0,N) > E2+(Z0±2,N) when neighbors exist (even-even only)",
                    },
                    "gap_Sn_peak": spec_sn,
                    "gap_Sp_peak": spec_sp,
                }

            spectro_multi_pack: dict[str, object] | None = None
            pass_spectro_multi = False
            if include_spectro_multi:
                if spectro_multi_maps is None:
                    raise RuntimeError("include_spectro_multi=True but spectro_multi_maps is None (bug)")

                def is_extreme_n(*, metric_by_zn: dict[tuple[int, int], float], Z: int, N0: int, kind: str) -> bool:
                    v0 = metric_by_zn.get((int(Z), int(N0)))
                    vL = metric_by_zn.get((int(Z), int(N0) - 2))
                    vR = metric_by_zn.get((int(Z), int(N0) + 2))
                    if v0 is None or vL is None or vR is None:
                        return False
                    if str(kind) == "peak":
                        return float(v0) > float(vL) and float(v0) > float(vR)
                    if str(kind) == "valley":
                        return float(v0) < float(vL) and float(v0) < float(vR)
                    raise ValueError(f"unsupported kind: {kind}")

                def is_extreme_z(*, metric_by_zn: dict[tuple[int, int], float], Z0: int, N: int, kind: str) -> bool:
                    v0 = metric_by_zn.get((int(Z0), int(N)))
                    vL = metric_by_zn.get((int(Z0) - 2, int(N)))
                    vR = metric_by_zn.get((int(Z0) + 2, int(N)))
                    if v0 is None or vL is None or vR is None:
                        return False
                    if str(kind) == "peak":
                        return float(v0) > float(vL) and float(v0) > float(vR)
                    if str(kind) == "valley":
                        return float(v0) < float(vL) and float(v0) < float(vR)
                    raise ValueError(f"unsupported kind: {kind}")

                def summarize_metric(*, metric_key: str, metric_label: str, metric_by_zn: dict[tuple[int, int], float], kind: str) -> dict[str, object]:
                    if str(kind) not in {"peak", "valley"}:
                        raise ValueError(f"unsupported kind: {kind}")

                    def summarize_axis_n() -> dict[str, object]:
                        n_avail = 0
                        n_ext = 0
                        rows: list[tuple[float, float, float]] = []
                        for (Z, N0, step), obs in gap_sn_obs.items():
                            if int(step) != 1:
                                continue
                            if metric_by_zn.get((int(Z), int(N0))) is not None:
                                n_avail += 1
                            if not is_extreme_n(metric_by_zn=metric_by_zn, Z=int(Z), N0=int(N0), kind=str(kind)):
                                continue
                            n_ext += 1
                            gu = gap_sn_pred_unc.get((int(Z), int(N0), 1))
                            gb = gap_sn_pred_base.get((int(Z), int(N0), 1))
                            gc = gap_sn_pred_cor.get((int(Z), int(N0), 1))
                            if gu is None or gb is None or gc is None:
                                continue
                            rows.append((float(gu - obs), float(gb - obs), float(gc - obs)))
                        return {
                            "n_available": int(n_avail),
                            "n_extrema": int(n_ext),
                            "rms_resid_uncorrected_MeV": float(rms([float(r[0]) for r in rows])) if rows else float("nan"),
                            "rms_resid_pairing_only_MeV": float(rms([float(r[1]) for r in rows])) if rows else float("nan"),
                            "rms_resid_pairing_shell_MeV": float(rms([float(r[2]) for r in rows])) if rows else float("nan"),
                        }

                    def summarize_axis_z() -> dict[str, object]:
                        n_avail = 0
                        n_ext = 0
                        rows: list[tuple[float, float, float]] = []
                        for (N, Z0, step), obs in gap_sp_obs.items():
                            if int(step) != 1:
                                continue
                            if metric_by_zn.get((int(Z0), int(N))) is not None:
                                n_avail += 1
                            if not is_extreme_z(metric_by_zn=metric_by_zn, Z0=int(Z0), N=int(N), kind=str(kind)):
                                continue
                            n_ext += 1
                            gu = gap_sp_pred_unc.get((int(N), int(Z0), 1))
                            gb = gap_sp_pred_base.get((int(N), int(Z0), 1))
                            gc = gap_sp_pred_cor.get((int(N), int(Z0), 1))
                            if gu is None or gb is None or gc is None:
                                continue
                            rows.append((float(gu - obs), float(gb - obs), float(gc - obs)))
                        return {
                            "n_available": int(n_avail),
                            "n_extrema": int(n_ext),
                            "rms_resid_uncorrected_MeV": float(rms([float(r[0]) for r in rows])) if rows else float("nan"),
                            "rms_resid_pairing_only_MeV": float(rms([float(r[1]) for r in rows])) if rows else float("nan"),
                            "rms_resid_pairing_shell_MeV": float(rms([float(r[2]) for r in rows])) if rows else float("nan"),
                        }

                    spec_sn = summarize_axis_n()
                    spec_sp = summarize_axis_z()
                    pass_metric = bool(
                        int(spec_sn.get("n_extrema", 0)) > 0
                        and int(spec_sp.get("n_extrema", 0)) > 0
                        and float(spec_sn.get("rms_resid_pairing_shell_MeV", float("nan")))
                        < float(spec_sn.get("rms_resid_pairing_only_MeV", float("nan")))
                        and float(spec_sp.get("rms_resid_pairing_shell_MeV", float("nan")))
                        < float(spec_sp.get("rms_resid_pairing_only_MeV", float("nan")))
                    )

                    if str(kind) == "peak":
                        cmp_n = f"{metric_label}(Z,N0) > {metric_label}(Z,N0±2) when neighbors exist (even-even only)"
                        cmp_z = f"{metric_label}(Z0,N) > {metric_label}(Z0±2,N) when neighbors exist (even-even only)"
                    else:
                        cmp_n = f"{metric_label}(Z,N0) < {metric_label}(Z,N0±2) when neighbors exist (even-even only)"
                        cmp_z = f"{metric_label}(Z0,N) < {metric_label}(Z0±2,N) when neighbors exist (even-even only)"

                    return {
                        "metric_key": str(metric_key),
                        "metric": str(metric_label),
                        "kind": str(kind),
                        "rule_extrema": {"gap_Sn": cmp_n, "gap_Sp": cmp_z},
                        "gap_Sn_extrema": spec_sn,
                        "gap_Sp_extrema": spec_sp,
                        "pass": bool(pass_metric),
                    }

                m = spectro_multi_maps
                pack_e2 = summarize_metric(metric_key="e2plus_keV", metric_label="E2+", metric_by_zn=m.get("e2plus_keV", {}), kind="peak")
                pack_e4 = summarize_metric(metric_key="e4plus_keV", metric_label="E4+", metric_by_zn=m.get("e4plus_keV", {}), kind="peak")
                pack_e3 = summarize_metric(metric_key="e3minus_keV", metric_label="E3-", metric_by_zn=m.get("e3minus_keV", {}), kind="peak")
                pack_r42 = summarize_metric(metric_key="r42", metric_label="R4/2", metric_by_zn=m.get("r42", {}), kind="valley")

                pass_spectro_multi = bool(bool(pack_e2.get("pass")) and bool(pack_e4.get("pass")) and bool(pack_e3.get("pass")) and bool(pack_r42.get("pass")))
                spectro_multi_pack = {
                    "source": str(spectro_multi_source_label),
                    "metrics": {"e2plus": pack_e2, "e4plus": pack_e4, "e3minus": pack_e3, "r42": pack_r42},
                    "pass_multi": bool(pass_spectro_multi),
                }

            radii_kink_pack: dict[str, object] | None = None
            pass_radii_kink = False
            if include_radii_kink:

                def is_kink_n(*, Z: int, N0: int) -> bool:
                    info = kink_info_n(Z=int(Z), N0=int(N0), d=2)
                    return bool(info is not None and float(info[0]) >= float(kink_sigma_min))

                def is_kink_z(*, Z0: int, N: int) -> bool:
                    info = kink_info_z(Z0=int(Z0), N=int(N), d=2)
                    return bool(info is not None and float(info[0]) >= float(kink_sigma_min))

                def summarize_radii_kinks_n() -> dict[str, object]:
                    n_avail = 0
                    n_kink = 0
                    rows: list[tuple[float, float, float]] = []
                    for (Z, N0, step), obs in gap_sn_obs.items():
                        if int(step) != 1:
                            continue
                        if kink_info_n(Z=int(Z), N0=int(N0), d=2) is not None:
                            n_avail += 1
                        if not is_kink_n(Z=int(Z), N0=int(N0)):
                            continue
                        n_kink += 1
                        gu = gap_sn_pred_unc.get((int(Z), int(N0), 1))
                        gb = gap_sn_pred_base.get((int(Z), int(N0), 1))
                        gc = gap_sn_pred_cor.get((int(Z), int(N0), 1))
                        if gu is None or gb is None or gc is None:
                            continue
                        rows.append((float(gu - obs), float(gb - obs), float(gc - obs)))
                    return {
                        "n_available": int(n_avail),
                        "n_kink": int(n_kink),
                        "rms_resid_uncorrected_MeV": float(rms([float(r[0]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_only_MeV": float(rms([float(r[1]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_shell_MeV": float(rms([float(r[2]) for r in rows])) if rows else float("nan"),
                    }

                def summarize_radii_kinks_p() -> dict[str, object]:
                    n_avail = 0
                    n_kink = 0
                    rows: list[tuple[float, float, float]] = []
                    for (N, Z0, step), obs in gap_sp_obs.items():
                        if int(step) != 1:
                            continue
                        if kink_info_z(Z0=int(Z0), N=int(N), d=2) is not None:
                            n_avail += 1
                        if not is_kink_z(Z0=int(Z0), N=int(N)):
                            continue
                        n_kink += 1
                        gu = gap_sp_pred_unc.get((int(N), int(Z0), 1))
                        gb = gap_sp_pred_base.get((int(N), int(Z0), 1))
                        gc = gap_sp_pred_cor.get((int(N), int(Z0), 1))
                        if gu is None or gb is None or gc is None:
                            continue
                        rows.append((float(gu - obs), float(gb - obs), float(gc - obs)))
                    return {
                        "n_available": int(n_avail),
                        "n_kink": int(n_kink),
                        "rms_resid_uncorrected_MeV": float(rms([float(r[0]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_only_MeV": float(rms([float(r[1]) for r in rows])) if rows else float("nan"),
                        "rms_resid_pairing_shell_MeV": float(rms([float(r[2]) for r in rows])) if rows else float("nan"),
                    }

                kink_sn = summarize_radii_kinks_n()
                kink_sp = summarize_radii_kinks_p()
                pass_radii_kink = bool(
                    int(kink_sn.get("n_kink", 0)) > 0
                    and int(kink_sp.get("n_kink", 0)) > 0
                    and float(kink_sn.get("rms_resid_pairing_shell_MeV", float("nan")))
                    < float(kink_sn.get("rms_resid_pairing_only_MeV", float("nan")))
                    and float(kink_sp.get("rms_resid_pairing_shell_MeV", float("nan")))
                    < float(kink_sp.get("rms_resid_pairing_only_MeV", float("nan")))
                )
                radii_kink_pack = {
                    "source": "IAEA charge_radii.csv (charge rms radius)",
                    "rule_kink": {
                        "delta2": "Δ²r = r(x+2) - 2 r(x) + r(x-2)",
                        "sigma": "σ(Δ²r) = sqrt(σ(x+2)^2 + 4σ(x)^2 + σ(x-2)^2) (independent; no covariance)",
                        "threshold": f"|Δ²r|/σ >= {float(kink_sigma_min):g} (fixed)",
                        "gap_Sn": "x=N at fixed Z",
                        "gap_Sp": "x=Z at fixed N",
                    },
                    "gap_Sn_kink": kink_sn,
                    "gap_Sp_kink": kink_sp,
                }

            radii_kink_delta2r_pack: dict[str, object] | None = None
            pass_radii_kink_delta2r = False
            if include_radii_kink_delta2r:
                resid_sigma_max = float(radii_kink_delta2r_resid_sigma_max)
                delta2r_pred_n_fn = delta2r_pred_n
                delta2r_pred_z_fn = delta2r_pred_z
                radii_shell_pack: dict[str, object] | None = None
                radii_beta2_pack: dict[str, object] | None = None
                radii_odd_even_pack: dict[str, object] | None = None
                radii_magic_offset_pack: dict[str, object] | None = None
                radii_magic_offset_neighbors_pack: dict[str, object] | None = None
                radii_magic_offset_per_magic_pack: dict[str, object] | None = None
                if bool(radii_kink_delta2r_radius_shell_nz_beta2):
                    # Combined (still minimal) radius variant:
                    #   r_charge = (r_base + r_shell_N*S(N) + r_shell_Z*S(Z)) * sqrt(1 + (5/(4π))*beta2^2)
                    #
                    # Note: beta2 is treated as fixed input (imputed deterministically when missing),
                    # so the shell fit remains linear (weighted LS).
                    shell_S_r = shell_S_radius_factory(list(shell_magic))
                    radii_shell_pack = fit_radii_shell_nz_beta2(shell_magic=list(shell_magic))
                    r_shell_n = float(radii_shell_pack.get("r_shell_N_fm", 0.0))
                    r_shell_z = float(radii_shell_pack.get("r_shell_Z_fm", 0.0))
                    if not math.isfinite(r_shell_n):
                        r_shell_n = 0.0
                    if not math.isfinite(r_shell_z):
                        r_shell_z = 0.0
                    k_beta2 = 5.0 / (4.0 * math.pi)

                    def r_charge_pred_shell_nz_beta2(*, Z: int, N: int) -> float | None:
                        base = r_charge_pred(Z=int(Z), N=int(N))
                        if base is None:
                            return None
                        b2, _ = _beta2_for_zn(
                            Z=int(Z),
                            N=int(N),
                            beta2_by_zn=beta2_by_zn,
                            include_beta2=include_beta2,
                            imputation=str(beta2_imputation),
                        )
                        b2 = abs(float(b2))
                        factor = math.sqrt(1.0 + float(k_beta2) * float(b2) * float(b2))
                        sN = float(shell_S_r(int(N)))
                        sZ = float(shell_S_r(int(Z)))
                        if not (math.isfinite(factor) and factor > 0.0 and math.isfinite(sN) and math.isfinite(sZ)):
                            return None
                        out_r = (float(base) + float(r_shell_n) * float(sN) + float(r_shell_z) * float(sZ)) * float(factor)
                        if not (math.isfinite(out_r) and out_r > 0.0):
                            return None
                        return float(out_r)

                    def delta2r_pred_n_shell_nz_beta2(*, Z: int, N0: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_shell_nz_beta2(Z=int(Z), N=int(N0))
                        rLp = r_charge_pred_shell_nz_beta2(Z=int(Z), N=int(N0) - int(d))
                        rRp = r_charge_pred_shell_nz_beta2(Z=int(Z), N=int(N0) + int(d))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    def delta2r_pred_z_shell_nz_beta2(*, Z0: int, N: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_shell_nz_beta2(Z=int(Z0), N=int(N))
                        rLp = r_charge_pred_shell_nz_beta2(Z=int(Z0) - int(d), N=int(N))
                        rRp = r_charge_pred_shell_nz_beta2(Z=int(Z0) + int(d), N=int(N))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    delta2r_pred_n_fn = delta2r_pred_n_shell_nz_beta2
                    delta2r_pred_z_fn = delta2r_pred_z_shell_nz_beta2
                    radii_beta2_pack = {
                        "status": "ok",
                        "form": "r_charge = (...) * sqrt(1 + (5/(4π))*beta2^2)  (combined with shell_NZ)",
                        "beta2_source": "NNDC B(E2) adopted entries (deformationParameter β2; extracted_beta2.json)",
                        "extracted_beta2_path": str(beta2_path),
                        "beta2_imputation": str(beta2_imputation),
                        "k": float(k_beta2),
                        "combined_with_shell": True,
                    }
                if bool(radii_kink_delta2r_radius_beta2):
                    # Deformation-aware radius mapping (minimal: no free params; fixed from β2).
                    #
                    # r_charge = r_base * sqrt(1 + k * β2^2), with k=5/(4π) (lowest-order quadrupole correction).
                    # β2 is imputed deterministically from nearest neighbors when missing to cover odd-A nuclei:
                    #   (Z,N±1) and (Z±1,N), then (Z±1,N±1); otherwise 0.
                    k_beta2 = 5.0 / (4.0 * math.pi)

                    def beta2_for_radius(*, Z: int, N: int) -> float:
                        v = beta2_by_zn.get((int(Z), int(N)))
                        if v is not None and math.isfinite(float(v)):
                            return float(v)
                        vals: list[float] = []
                        for z0, n0 in [
                            (int(Z), int(N) - 1),
                            (int(Z), int(N) + 1),
                            (int(Z) - 1, int(N)),
                            (int(Z) + 1, int(N)),
                            (int(Z) - 1, int(N) - 1),
                            (int(Z) - 1, int(N) + 1),
                            (int(Z) + 1, int(N) - 1),
                            (int(Z) + 1, int(N) + 1),
                        ]:
                            v0 = beta2_by_zn.get((int(z0), int(n0)))
                            if v0 is None:
                                continue
                            if math.isfinite(float(v0)):
                                vals.append(float(v0))
                        return float(sum(vals) / len(vals)) if vals else 0.0

                    def r_charge_pred_beta2(*, Z: int, N: int) -> float | None:
                        base = r_charge_pred(Z=int(Z), N=int(N))
                        if base is None:
                            return None
                        b2 = abs(float(beta2_for_radius(Z=int(Z), N=int(N))))
                        factor = math.sqrt(1.0 + float(k_beta2) * float(b2) * float(b2))
                        out_r = float(base) * float(factor)
                        if not (math.isfinite(out_r) and out_r > 0.0):
                            return None
                        return float(out_r)

                    def delta2r_pred_n_beta2(*, Z: int, N0: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_beta2(Z=int(Z), N=int(N0))
                        rLp = r_charge_pred_beta2(Z=int(Z), N=int(N0) - int(d))
                        rRp = r_charge_pred_beta2(Z=int(Z), N=int(N0) + int(d))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    def delta2r_pred_z_beta2(*, Z0: int, N: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_beta2(Z=int(Z0), N=int(N))
                        rLp = r_charge_pred_beta2(Z=int(Z0) - int(d), N=int(N))
                        rRp = r_charge_pred_beta2(Z=int(Z0) + int(d), N=int(N))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    delta2r_pred_n_fn = delta2r_pred_n_beta2
                    delta2r_pred_z_fn = delta2r_pred_z_beta2
                    radii_beta2_pack = {
                        "status": "ok",
                        "form": "r_charge = r_base * sqrt(1 + (5/(4π))*beta2^2)",
                        "beta2_source": "NNDC B(E2) adopted entries (deformationParameter β2; extracted_beta2.json)",
                        "extracted_beta2_path": str(beta2_path),
                        "beta2_imputation": "direct if present; else use (Z,N±1),(Z±1,N), then (Z±1,N±1); else 0",
                        "k": float(k_beta2),
                    }
                if bool(radii_kink_delta2r_radius_odd_even):
                    radii_odd_even_pack = fit_radii_odd_even()
                    r_oe_n = float(radii_odd_even_pack.get("r_oe_N_fm", 0.0))
                    r_oe_z = float(radii_odd_even_pack.get("r_oe_Z_fm", 0.0))
                    if not math.isfinite(r_oe_n):
                        r_oe_n = 0.0
                    if not math.isfinite(r_oe_z):
                        r_oe_z = 0.0

                    def r_charge_pred_odd_even(*, Z: int, N: int) -> float | None:
                        base = r_charge_pred(Z=int(Z), N=int(N))
                        if base is None:
                            return None
                        eN = 1.0 if (int(N) % 2 != 0) else 0.0
                        eZ = 1.0 if (int(Z) % 2 != 0) else 0.0
                        out_r = float(base) + float(r_oe_n) * float(eN) + float(r_oe_z) * float(eZ)
                        if not (math.isfinite(out_r) and out_r > 0.0):
                            return None
                        return float(out_r)

                    def delta2r_pred_n_odd_even(*, Z: int, N0: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_odd_even(Z=int(Z), N=int(N0))
                        rLp = r_charge_pred_odd_even(Z=int(Z), N=int(N0) - int(d))
                        rRp = r_charge_pred_odd_even(Z=int(Z), N=int(N0) + int(d))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    def delta2r_pred_z_odd_even(*, Z0: int, N: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_odd_even(Z=int(Z0), N=int(N))
                        rLp = r_charge_pred_odd_even(Z=int(Z0) - int(d), N=int(N))
                        rRp = r_charge_pred_odd_even(Z=int(Z0) + int(d), N=int(N))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    delta2r_pred_n_fn = delta2r_pred_n_odd_even
                    delta2r_pred_z_fn = delta2r_pred_z_odd_even
                if bool(radii_kink_delta2r_radius_magic_offset):
                    radii_magic_offset_pack = fit_radii_magic_offset(magic=list(OBS_MAGIC))
                    magic_set = {int(x) for x in radii_magic_offset_pack.get("magic", []) if int(x) > 0}
                    r_magic_n = float(radii_magic_offset_pack.get("r_magic_N_fm", 0.0))
                    r_magic_z = float(radii_magic_offset_pack.get("r_magic_Z_fm", 0.0))
                    if not math.isfinite(r_magic_n):
                        r_magic_n = 0.0
                    if not math.isfinite(r_magic_z):
                        r_magic_z = 0.0

                    def r_charge_pred_magic_offset(*, Z: int, N: int) -> float | None:
                        base = r_charge_pred(Z=int(Z), N=int(N))
                        if base is None:
                            return None
                        eN = 1.0 if int(N) in magic_set else 0.0
                        eZ = 1.0 if int(Z) in magic_set else 0.0
                        out_r = float(base) + float(r_magic_n) * float(eN) + float(r_magic_z) * float(eZ)
                        if not (math.isfinite(out_r) and out_r > 0.0):
                            return None
                        return float(out_r)

                    def delta2r_pred_n_magic_offset(*, Z: int, N0: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_magic_offset(Z=int(Z), N=int(N0))
                        rLp = r_charge_pred_magic_offset(Z=int(Z), N=int(N0) - int(d))
                        rRp = r_charge_pred_magic_offset(Z=int(Z), N=int(N0) + int(d))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    def delta2r_pred_z_magic_offset(*, Z0: int, N: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_magic_offset(Z=int(Z0), N=int(N))
                        rLp = r_charge_pred_magic_offset(Z=int(Z0) - int(d), N=int(N))
                        rRp = r_charge_pred_magic_offset(Z=int(Z0) + int(d), N=int(N))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    delta2r_pred_n_fn = delta2r_pred_n_magic_offset
                    delta2r_pred_z_fn = delta2r_pred_z_magic_offset
                if bool(radii_kink_delta2r_radius_magic_offset_neighbors):
                    radii_magic_offset_neighbors_pack = fit_radii_magic_offset_neighbors(magic=list(OBS_MAGIC), neighbor_weight=0.5, neighbor_step=2)
                    w_magic_cfg = radii_magic_offset_neighbors_pack.get("w_magic") if isinstance(radii_magic_offset_neighbors_pack.get("w_magic"), dict) else {}
                    magic_set = {int(x) for x in w_magic_cfg.get("magic", []) if int(x) > 0}
                    neighbor_weight = float(w_magic_cfg.get("neighbor_weight", 0.5))
                    neighbor_step = int(w_magic_cfg.get("neighbor_step", 2))
                    r_magic_n = float(radii_magic_offset_neighbors_pack.get("r_magic_N_fm", 0.0))
                    r_magic_z = float(radii_magic_offset_neighbors_pack.get("r_magic_Z_fm", 0.0))
                    if not math.isfinite(r_magic_n):
                        r_magic_n = 0.0
                    if not math.isfinite(r_magic_z):
                        r_magic_z = 0.0
                    if not (math.isfinite(neighbor_weight) and 0.0 <= neighbor_weight <= 1.0):
                        neighbor_weight = 0.5
                    if neighbor_step <= 0:
                        neighbor_step = 2

                    def w_magic(x: int) -> float:
                        if int(x) in magic_set:
                            return 1.0
                        if (int(x) - int(neighbor_step)) in magic_set or (int(x) + int(neighbor_step)) in magic_set:
                            return float(neighbor_weight)
                        return 0.0

                    def r_charge_pred_magic_offset_neighbors(*, Z: int, N: int) -> float | None:
                        base = r_charge_pred(Z=int(Z), N=int(N))
                        if base is None:
                            return None
                        wN = float(w_magic(int(N)))
                        wZ = float(w_magic(int(Z)))
                        if not (math.isfinite(wN) and math.isfinite(wZ)):
                            return None
                        out_r = float(base) + float(r_magic_n) * float(wN) + float(r_magic_z) * float(wZ)
                        if not (math.isfinite(out_r) and out_r > 0.0):
                            return None
                        return float(out_r)

                    def delta2r_pred_n_magic_offset_neighbors(*, Z: int, N0: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_magic_offset_neighbors(Z=int(Z), N=int(N0))
                        rLp = r_charge_pred_magic_offset_neighbors(Z=int(Z), N=int(N0) - int(d))
                        rRp = r_charge_pred_magic_offset_neighbors(Z=int(Z), N=int(N0) + int(d))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    def delta2r_pred_z_magic_offset_neighbors(*, Z0: int, N: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_magic_offset_neighbors(Z=int(Z0), N=int(N))
                        rLp = r_charge_pred_magic_offset_neighbors(Z=int(Z0) - int(d), N=int(N))
                        rRp = r_charge_pred_magic_offset_neighbors(Z=int(Z0) + int(d), N=int(N))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    delta2r_pred_n_fn = delta2r_pred_n_magic_offset_neighbors
                    delta2r_pred_z_fn = delta2r_pred_z_magic_offset_neighbors
                if bool(radii_kink_delta2r_radius_magic_offset_per_magic):
                    radii_magic_offset_per_magic_pack = fit_radii_magic_offset_per_magic(magic=list(OBS_MAGIC))
                    coeffs = radii_magic_offset_per_magic_pack.get("coeffs") if isinstance(radii_magic_offset_per_magic_pack.get("coeffs"), dict) else {}
                    coeffs_N = coeffs.get("N") if isinstance(coeffs.get("N"), dict) else {}
                    coeffs_Z = coeffs.get("Z") if isinstance(coeffs.get("Z"), dict) else {}

                    def r_charge_pred_magic_offset_per_magic(*, Z: int, N: int) -> float | None:
                        base = r_charge_pred(Z=int(Z), N=int(N))
                        if base is None:
                            return None
                        dm = float(coeffs_N.get(int(N), 0.0)) + float(coeffs_Z.get(int(Z), 0.0))
                        out_r = float(base) + float(dm)
                        if not (math.isfinite(out_r) and out_r > 0.0):
                            return None
                        return float(out_r)

                    def delta2r_pred_n_magic_offset_per_magic(*, Z: int, N0: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_magic_offset_per_magic(Z=int(Z), N=int(N0))
                        rLp = r_charge_pred_magic_offset_per_magic(Z=int(Z), N=int(N0) - int(d))
                        rRp = r_charge_pred_magic_offset_per_magic(Z=int(Z), N=int(N0) + int(d))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    def delta2r_pred_z_magic_offset_per_magic(*, Z0: int, N: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_magic_offset_per_magic(Z=int(Z0), N=int(N))
                        rLp = r_charge_pred_magic_offset_per_magic(Z=int(Z0) - int(d), N=int(N))
                        rRp = r_charge_pred_magic_offset_per_magic(Z=int(Z0) + int(d), N=int(N))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    delta2r_pred_n_fn = delta2r_pred_n_magic_offset_per_magic
                    delta2r_pred_z_fn = delta2r_pred_z_magic_offset_per_magic
                if bool(radii_kink_delta2r_radius_shell or radii_kink_delta2r_radius_shell_nz):
                    shell_S_r = shell_S_radius_factory(list(shell_magic))

                    if bool(radii_kink_delta2r_radius_shell_nz):
                        radii_shell_pack = fit_radii_shell_nz(shell_magic=list(shell_magic))
                        r_shell_n = float(radii_shell_pack.get("r_shell_N_fm", 0.0))
                        r_shell_z = float(radii_shell_pack.get("r_shell_Z_fm", 0.0))
                        if not math.isfinite(r_shell_n):
                            r_shell_n = 0.0
                        if not math.isfinite(r_shell_z):
                            r_shell_z = 0.0

                        def r_charge_pred_shell(*, Z: int, N: int) -> float | None:
                            base = r_charge_pred(Z=int(Z), N=int(N))
                            if base is None:
                                return None
                            sN = float(shell_S_r(int(N)))
                            sZ = float(shell_S_r(int(Z)))
                            if not (math.isfinite(sN) and math.isfinite(sZ)):
                                return None
                            out_r = float(base) + float(r_shell_n) * float(sN) + float(r_shell_z) * float(sZ)
                            if not (math.isfinite(out_r) and out_r > 0.0):
                                return None
                            return float(out_r)
                    else:
                        radii_shell_pack = fit_radii_shell(shell_magic=list(shell_magic))
                        r_shell = float(radii_shell_pack.get("r_shell_fm", 0.0))
                        if not math.isfinite(r_shell):
                            r_shell = 0.0

                        def r_charge_pred_shell(*, Z: int, N: int) -> float | None:
                            base = r_charge_pred(Z=int(Z), N=int(N))
                            if base is None:
                                return None
                            s_sum = float(shell_S_r(int(N)) + shell_S_r(int(Z)))
                            if not math.isfinite(s_sum):
                                return None
                            out_r = float(base) + float(r_shell) * float(s_sum)
                            if not (math.isfinite(out_r) and out_r > 0.0):
                                return None
                            return float(out_r)

                    def delta2r_pred_n_shell(*, Z: int, N0: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_shell(Z=int(Z), N=int(N0))
                        rLp = r_charge_pred_shell(Z=int(Z), N=int(N0) - int(d))
                        rRp = r_charge_pred_shell(Z=int(Z), N=int(N0) + int(d))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    def delta2r_pred_z_shell(*, Z0: int, N: int, d: int = 2) -> float | None:
                        r0p = r_charge_pred_shell(Z=int(Z0), N=int(N))
                        rLp = r_charge_pred_shell(Z=int(Z0) - int(d), N=int(N))
                        rRp = r_charge_pred_shell(Z=int(Z0) + int(d), N=int(N))
                        if r0p is None or rLp is None or rRp is None:
                            return None
                        return float(rRp) - 2.0 * float(r0p) + float(rLp)

                    delta2r_pred_n_fn = delta2r_pred_n_shell
                    delta2r_pred_z_fn = delta2r_pred_z_shell

                def summarize_delta2r_n() -> dict[str, object]:
                    n_avail = 0
                    n_kink = 0
                    n_eval = 0
                    zscores: list[float] = []
                    worst: list[tuple[float, int, int, float, float, float, float]] = []
                    for (Z, N0) in radii_by_zn.keys():
                        info = kink_info_n(Z=int(Z), N0=int(N0), d=2)
                        if info is None:
                            continue
                        A0 = int(Z) + int(N0)
                        AL = int(Z) + int(N0) - 2
                        AR = int(Z) + int(N0) + 2
                        if min(AL, A0, AR) < int(a_min):
                            continue
                        n_avail += 1
                        sig_obs, d2_obs, sig_obs_fm = info
                        if float(sig_obs) < float(kink_sigma_min):
                            continue
                        if bool(radii_kink_delta2r_center_magic_only) and (int(N0) not in set(int(x) for x in OBS_MAGIC)):
                            continue
                        n_kink += 1
                        d2_pred = delta2r_pred_n_fn(Z=int(Z), N0=int(N0), d=2)
                        if d2_pred is None:
                            continue
                        sig = float(sig_obs_fm)
                        if not (math.isfinite(sig) and sig > 0.0):
                            continue
                        resid = float(d2_pred) - float(d2_obs)
                        z = float(resid) / float(sig)
                        zscores.append(float(z))
                        n_eval += 1
                        worst.append((abs(float(z)), int(Z), int(N0), float(d2_obs), float(d2_pred), float(resid), float(sig)))

                    worst_sorted = sorted(worst, key=lambda x: float(x[0]), reverse=True)[:10]
                    max_abs = max((float(w[0]) for w in worst_sorted), default=float("nan"))
                    pass_axis = bool(n_eval > 0 and math.isfinite(max_abs) and float(max_abs) <= float(resid_sigma_max))
                    return {
                        "n_available": int(n_avail),
                        "n_kink": int(n_kink),
                        "n_eval": int(n_eval),
                        "rms_resid_sigma": float(rms([float(z) for z in zscores])) if zscores else float("nan"),
                        "max_abs_resid_sigma": float(max_abs),
                        "worst_points": [
                            {
                                "Z": int(w[1]),
                                "N0": int(w[2]),
                                "abs_resid_sigma": float(w[0]),
                                "delta2r_obs_fm": float(w[3]),
                                "delta2r_pred_fm": float(w[4]),
                                "resid_fm": float(w[5]),
                                "sigma_obs_fm": float(w[6]),
                            }
                            for w in worst_sorted
                        ],
                        "pass": bool(pass_axis),
                    }

                def summarize_delta2r_p() -> dict[str, object]:
                    n_avail = 0
                    n_kink = 0
                    n_eval = 0
                    zscores: list[float] = []
                    worst: list[tuple[float, int, int, float, float, float, float]] = []
                    for (Z0, N) in radii_by_zn.keys():
                        info = kink_info_z(Z0=int(Z0), N=int(N), d=2)
                        if info is None:
                            continue
                        A0 = int(Z0) + int(N)
                        AL = int(Z0) - 2 + int(N)
                        AR = int(Z0) + 2 + int(N)
                        if min(AL, A0, AR) < int(a_min):
                            continue
                        n_avail += 1
                        sig_obs, d2_obs, sig_obs_fm = info
                        if float(sig_obs) < float(kink_sigma_min):
                            continue
                        if bool(radii_kink_delta2r_center_magic_only) and (int(Z0) not in set(int(x) for x in OBS_MAGIC)):
                            continue
                        n_kink += 1
                        d2_pred = delta2r_pred_z_fn(Z0=int(Z0), N=int(N), d=2)
                        if d2_pred is None:
                            continue
                        sig = float(sig_obs_fm)
                        if not (math.isfinite(sig) and sig > 0.0):
                            continue
                        resid = float(d2_pred) - float(d2_obs)
                        z = float(resid) / float(sig)
                        zscores.append(float(z))
                        n_eval += 1
                        worst.append((abs(float(z)), int(N), int(Z0), float(d2_obs), float(d2_pred), float(resid), float(sig)))

                    worst_sorted = sorted(worst, key=lambda x: float(x[0]), reverse=True)[:10]
                    max_abs = max((float(w[0]) for w in worst_sorted), default=float("nan"))
                    pass_axis = bool(n_eval > 0 and math.isfinite(max_abs) and float(max_abs) <= float(resid_sigma_max))
                    return {
                        "n_available": int(n_avail),
                        "n_kink": int(n_kink),
                        "n_eval": int(n_eval),
                        "rms_resid_sigma": float(rms([float(z) for z in zscores])) if zscores else float("nan"),
                        "max_abs_resid_sigma": float(max_abs),
                        "worst_points": [
                            {
                                "N": int(w[1]),
                                "Z0": int(w[2]),
                                "abs_resid_sigma": float(w[0]),
                                "delta2r_obs_fm": float(w[3]),
                                "delta2r_pred_fm": float(w[4]),
                                "resid_fm": float(w[5]),
                                "sigma_obs_fm": float(w[6]),
                            }
                            for w in worst_sorted
                        ],
                        "pass": bool(pass_axis),
                    }

                d2_sn = summarize_delta2r_n()
                d2_sp = summarize_delta2r_p()
                pass_radii_kink_delta2r = bool(bool(d2_sn.get("pass")) and bool(d2_sp.get("pass")))
                radii_kink_delta2r_pack = {
                    "source": "IAEA charge_radii.csv (charge rms radius)",
                    "rule_delta2r": {
                        "delta2": "Δ²r = r(x+2) - 2 r(x) + r(x-2)",
                        "sigma_obs": "σ_obs(Δ²r) = sqrt(σ(x+2)^2 + 4σ(x)^2 + σ(x-2)^2) (independent; no covariance)",
                        "kink_threshold": f"|Δ²r_obs|/σ_obs >= {float(kink_sigma_min):g} (fixed)",
                        "residual_threshold": f"|Δ²r_pred - Δ²r_obs|/σ_obs <= {float(resid_sigma_max):g} (fixed)",
                        "step": 2,
                        "even_even_only": bool(radii_kink_delta2r_even_even_only),
                        "center_magic_only": bool(radii_kink_delta2r_center_magic_only),
                        "axes": {"gap_Sn": "x=N at fixed Z", "gap_Sp": "x=Z at fixed N"},
                    },
                    "gap_Sn_delta2r": d2_sn,
                    "gap_Sp_delta2r": d2_sp,
                    "pass": bool(pass_radii_kink_delta2r),
                }
                if radii_shell_pack is not None:
                    radii_kink_delta2r_pack["radius_shell"] = radii_shell_pack
                if radii_beta2_pack is not None:
                    radii_kink_delta2r_pack["radius_beta2"] = radii_beta2_pack
                if radii_odd_even_pack is not None:
                    radii_kink_delta2r_pack["radius_odd_even"] = radii_odd_even_pack
                if radii_magic_offset_pack is not None:
                    radii_kink_delta2r_pack["radius_magic_offset"] = radii_magic_offset_pack
                if radii_magic_offset_neighbors_pack is not None:
                    radii_kink_delta2r_pack["radius_magic_offset_neighbors"] = radii_magic_offset_neighbors_pack
                if radii_magic_offset_per_magic_pack is not None:
                    radii_kink_delta2r_pack["radius_magic_offset_per_magic"] = radii_magic_offset_per_magic_pack

            # Strict decision: train guardrail + other strict improvement (Sn and Sp).
            train_guard_mev = 0.5
            ok_train = (
                float(diag_gap_sn["train_magic"]["rms_resid_pairing_shell_MeV"])
                <= float(diag_gap_sn["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
                and float(diag_gap_sp["train_magic"]["rms_resid_pairing_shell_MeV"])
                <= float(diag_gap_sp["train_magic"]["rms_resid_pairing_only_MeV"]) + float(train_guard_mev)
            )
            ok_other = (
                float(diag_gap_sn["other_magic"]["rms_resid_pairing_shell_MeV"])
                < float(diag_gap_sn["other_magic"]["rms_resid_pairing_only_MeV"])
                and float(diag_gap_sp["other_magic"]["rms_resid_pairing_shell_MeV"])
                < float(diag_gap_sp["other_magic"]["rms_resid_pairing_only_MeV"])
            )
            pass_strict_train_other = bool(ok_train and ok_other)
            pass_strict = bool(pass_strict_train_other)
            if bool(include_e2plus and e2plus_strict_peaks):
                pass_strict = bool(pass_strict and pass_spectro)
            if bool(include_spectro_multi and spectro_multi_strict):
                pass_strict = bool(pass_strict and pass_spectro_multi)
            if bool(include_radii_kink and radii_kink_strict):
                pass_strict = bool(pass_strict and pass_radii_kink)
            if bool(include_radii_kink_delta2r and radii_kink_delta2r_strict):
                pass_strict = bool(pass_strict and pass_radii_kink_delta2r)

            decision: dict[str, object] = {
                "train_guard_mev": float(train_guard_mev),
                "pass_strict_train_other": bool(pass_strict_train_other),
                "pass_strict": bool(pass_strict),
            }
            if include_e2plus:
                decision["pass_strict_spectro"] = bool(pass_spectro)
                decision["spectro_strict_applied"] = bool(e2plus_strict_peaks)
            if include_spectro_multi:
                decision["pass_strict_spectro_multi"] = bool(pass_spectro_multi)
                decision["spectro_multi_strict_applied"] = bool(spectro_multi_strict)
            if include_radii_kink:
                decision["pass_strict_radii_kink"] = bool(pass_radii_kink)
                decision["radii_kink_strict_applied"] = bool(radii_kink_strict)
            if include_radii_kink_delta2r:
                decision["pass_strict_radii_kink_delta2r"] = bool(pass_radii_kink_delta2r)
                decision["radii_kink_delta2r_strict_applied"] = bool(radii_kink_delta2r_strict)

            out_pack: dict[str, object] = {
                "status": "ok",
                "domain_min_A": int(a_min),
                "n_in_domain": int(len(a_by_zn)),
                "pairing": {"a_n_MeV": float(a_n), "a_p_MeV": float(a_p), "n_samples_a_n": int(len(an_list)), "n_samples_a_p": int(len(ap_list))},
                "fit": {
                    "kN0": float(kN0),
                    "kN1": float(kN1),
                    "kZ0": float(kZ0),
                    "kZ1": float(kZ1),
                    "kZ_over_kN": float(ratio_kZ_over_kN),
                    "n_fit_pairs_kN": int(len(fit_n)),
                    "n_fit_pairs_kZ": int(len(fit_z)),
                },
                "gap_Sn": diag_gap_sn,
                "gap_Sp": diag_gap_sp,
                "decision": decision,
            }
            if spectro_pack is not None:
                out_pack["spectro_e2plus"] = spectro_pack
            if spectro_multi_pack is not None:
                out_pack["spectro_nudat3_multi"] = spectro_multi_pack
            if radii_kink_pack is not None:
                out_pack["radii_kink"] = radii_kink_pack
            if radii_kink_delta2r_pack is not None:
                out_pack["radii_kink_delta2r"] = radii_kink_delta2r_pack
            return out_pack

        out: list[dict[str, object]] = []
        for sv in shell_variants:
            shell_name = str(sv["name"])
            shell_magic = list(sv["magic"])
            for a_min in scan_a_mins:
                try:
                    pack = run_config(a_min=int(a_min), shell_magic=shell_magic)
                    pack["shell_variant"] = {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))}
                    out.append(pack)
                except Exception as e:
                    out.append(
                        {
                            "status": "skipped",
                            "shell_variant": {"name": shell_name, "magic": list(shell_magic), "note": str(sv.get("note", ""))},
                            "domain_min_A": int(a_min),
                            "reason": str(e),
                        }
                    )
        return out

    rows = scan_rows(b_pred_all_map=b_pred_all)

    beta2_counts_direct_only: dict[str, int] | None = None
    b_pred_all_direct_only: dict[tuple[int, int], float] | None = None
    n_skipped_direct_only = 0
    if bool(include_beta2 and beta2_strict_coverage):
        beta2_counts_direct_only = {"direct": 0, "imputed": 0, "missing": 0}
        b_pred_all_direct_only = {}

        for (Z, N), v in ame_map.items():
            A = int(v["A"])
            if A < int(domain_min_a):
                continue
            ba_obs = float(v["B_over_A_obs_MeV"])
            if not math.isfinite(ba_obs):
                continue
            I = float(int(N) - int(Z)) / float(A)

            a13 = float(A) ** (1.0 / 3.0)
            r_over_a13 = float(r0) + float(rI) * float(I)
            r_charge = float(r_over_a13) * float(a13)
            if not (math.isfinite(r_charge) and r_charge > 0):
                n_skipped_direct_only += 1
                continue
            R_sharp = _sharp_radius_from_rms(float(r_charge))
            if not (math.isfinite(R_sharp) and R_sharp > 0):
                n_skipped_direct_only += 1
                continue
            V_sphere = (4.0 / 3.0) * math.pi * float(R_sharp) ** 3
            rho = float(A) / float(V_sphere)
            if not (math.isfinite(rho) and rho > 0):
                n_skipped_direct_only += 1
                continue

            beta2_val, beta2_mode = _beta2_for_zn(
                Z=int(Z), N=int(N), beta2_by_zn=beta2_by_zn, include_beta2=include_beta2, imputation="direct_only"
            )
            shape_factor = _coulomb_shape_factor_from_beta2(beta2=float(beta2_val), include_beta2=include_beta2)
            surface_factor = _surface_area_factor_from_beta2(
                beta2=float(beta2_val), include_beta2=bool(include_beta2 and beta2_apply_surface)
            )

            if beta2_mode == "direct":
                beta2_counts_direct_only["direct"] += 1
            elif beta2_mode == "imputed":
                beta2_counts_direct_only["imputed"] += 1
            elif beta2_mode == "missing":
                beta2_counts_direct_only["missing"] += 1

            cpack = finite_size_coeffs_for_rms(r_rms_fm=float(r_charge))
            e_dir_unit = float(cpack["e_dir_unit_over_e2_fm_1"]) * float(shape_factor)
            i43_unit = float(cpack["i43_unit_fm_1"]) * float(shape_factor)

            preds: dict[int, float] = {}
            for eq in eq_labels:
                fk = fit_by_eq.get(str(eq))
                if not isinstance(fk, dict):
                    continue
                c3_inf = float(fk.get("C3_inf", float("nan")))
                c_surf = float(fk.get("C_surf_MeV_fm", float("nan")))
                if not (math.isfinite(c3_inf) and math.isfinite(c_surf)):
                    continue
                base_pack = _hf_base_energy_uniform_sphere_mev_per_a(
                    A=int(A),
                    Z=int(Z),
                    N=int(N),
                    R_sharp_fm=float(R_sharp),
                    pot_sets=pot_sets,
                    eq=int(eq),
                    pn_triplet_weight=float(pn_triplet_weight),
                    hbarc_mev_fm=float(hbarc),
                    m_nucleon_c2_mev=float(m_nucleon_c2),
                )
                base_e = float(base_pack.get("E_base", float("nan"))) if isinstance(base_pack, dict) else float("nan")
                e_coul_uniform = float(base_pack.get("Coul", float("nan"))) if isinstance(base_pack, dict) else float("nan")
                if not (math.isfinite(base_e) and math.isfinite(e_coul_uniform)):
                    continue

                # Replace uniform-sphere Coulomb direct with 2pF direct, and add 2pF Slater exchange (LDA).
                if int(Z) <= 1:
                    e_dir_fs = 0.0
                    e_x_fs = 0.0
                else:
                    e_dir_fs = float(e2_mev_fm) * float(Z * (Z - 1)) * float(e_dir_unit) / float(A)
                    e_x_fs = float(coef_slater) * float(e2_mev_fm) * (float(Z) ** (4.0 / 3.0)) * float(i43_unit) / float(A)

                e_coul_fs = (float(e_dir_fs) - float(e_coul_uniform)) + float(e_x_fs)
                e_surf = float(c_surf) / (6.0 * float(R_sharp)) * float(surface_factor)
                e_total = float(base_e) + float(e_coul_fs) + float(c3_inf) * (float(rho) ** 2) + float(e_surf)
                ba_pred = -float(e_total)
                if math.isfinite(ba_pred):
                    preds[int(eq)] = float(ba_pred)

            if not preds:
                n_skipped_direct_only += 1
                continue
            if 18 in preds and 19 in preds:
                ba_pred_mean = float(0.5 * (float(preds[18]) + float(preds[19])))
            else:
                ba_pred_mean = float(next(iter(preds.values())))

            b_pred_all_direct_only[(int(Z), int(N))] = float(A) * float(ba_pred_mean)

        missing_keys = set(b_pred_all.keys()) - set(b_pred_all_direct_only.keys())
        if missing_keys:
            raise RuntimeError(f"direct-only beta2 pass is missing predictions for {len(missing_keys)} nuclei (unexpected)")

        rows_direct = scan_rows(b_pred_all_map=b_pred_all_direct_only)
        direct_pass: dict[tuple[str, int], bool] = {}
        for row_direct in rows_direct:
            if str(row_direct.get("status", "")) != "ok":
                continue
            sv0 = row_direct.get("shell_variant") if isinstance(row_direct.get("shell_variant"), dict) else {}
            key0 = (str(sv0.get("name", "")), int(row_direct.get("domain_min_A", -1)))
            dec0 = row_direct.get("decision") if isinstance(row_direct.get("decision"), dict) else {}
            direct_pass[key0] = bool(dec0.get("pass_strict", False))

        for r in rows:
            if str(r.get("status", "")) != "ok":
                continue
            sv = r.get("shell_variant") if isinstance(r.get("shell_variant"), dict) else {}
            key = (str(sv.get("name", "")), int(r.get("domain_min_A", -1)))
            dec = r.get("decision") if isinstance(r.get("decision"), dict) else {}
            p_primary = bool(dec.get("pass_strict", False))
            p_direct = bool(direct_pass.get(key, False))
            dec["pass_strict_primary"] = bool(p_primary)
            dec["pass_strict_direct_only"] = bool(p_direct)
            dec["pass_strict"] = bool(p_primary and p_direct)

    # CSV (flat table).
    out_csv = out_dir / f"nuclear_a_dependence_hf_three_body_shellgap_decision_{out_stub}.csv"
    header = [
        "shell_variant",
        "domain_min_A",
        "status",
        "n_in_domain",
        "a_n_MeV",
        "a_p_MeV",
        "kN0",
        "kN1",
        "kZ0",
        "kZ1",
        "kZ0_over_kN0",
        "gap_Sn_train_n",
        "gap_Sn_train_rms_pairing_only_MeV",
        "gap_Sn_train_rms_pairing_shell_MeV",
        "gap_Sn_other_n",
        "gap_Sn_other_rms_pairing_only_MeV",
        "gap_Sn_other_rms_pairing_shell_MeV",
        "gap_Sp_train_n",
        "gap_Sp_train_rms_pairing_only_MeV",
        "gap_Sp_train_rms_pairing_shell_MeV",
        "gap_Sp_other_n",
        "gap_Sp_other_rms_pairing_only_MeV",
        "gap_Sp_other_rms_pairing_shell_MeV",
        "pass_strict",
        "reason",
    ]
    extras: list[str] = []
    if include_e2plus:
        extras += [
            "spectro_e2plus_gap_Sn_n_available",
            "spectro_e2plus_gap_Sn_n_peak",
            "spectro_e2plus_gap_Sn_rms_pairing_only_MeV",
            "spectro_e2plus_gap_Sn_rms_pairing_shell_MeV",
            "spectro_e2plus_gap_Sp_n_available",
            "spectro_e2plus_gap_Sp_n_peak",
            "spectro_e2plus_gap_Sp_rms_pairing_only_MeV",
            "spectro_e2plus_gap_Sp_rms_pairing_shell_MeV",
            "pass_strict_spectro",
        ]
    if include_radii_kink:
        extras += [
            "radii_kink_gap_Sn_n_available",
            "radii_kink_gap_Sn_n_kink",
            "radii_kink_gap_Sn_rms_pairing_only_MeV",
            "radii_kink_gap_Sn_rms_pairing_shell_MeV",
            "radii_kink_gap_Sp_n_available",
            "radii_kink_gap_Sp_n_kink",
            "radii_kink_gap_Sp_rms_pairing_only_MeV",
            "radii_kink_gap_Sp_rms_pairing_shell_MeV",
            "pass_strict_radii_kink",
        ]
    if include_radii_kink_delta2r:
        extras += [
            "radii_kink_delta2r_gap_Sn_n_available",
            "radii_kink_delta2r_gap_Sn_n_kink",
            "radii_kink_delta2r_gap_Sn_n_eval",
            "radii_kink_delta2r_gap_Sn_rms_resid_sigma",
            "radii_kink_delta2r_gap_Sn_max_abs_resid_sigma",
            "radii_kink_delta2r_gap_Sp_n_available",
            "radii_kink_delta2r_gap_Sp_n_kink",
            "radii_kink_delta2r_gap_Sp_n_eval",
            "radii_kink_delta2r_gap_Sp_rms_resid_sigma",
            "radii_kink_delta2r_gap_Sp_max_abs_resid_sigma",
            "pass_strict_radii_kink_delta2r",
        ]
    if extras:
        header = header[:-2] + extras + header[-2:]
    if bool(include_beta2 and beta2_strict_coverage):
        header = header[:-2] + ["pass_strict_primary", "pass_strict_direct_only", "pass_strict", "reason"]
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            status = str(r.get("status", ""))
            sv = r.get("shell_variant") if isinstance(r.get("shell_variant"), dict) else {}
            name = str(sv.get("name", ""))
            domain_a = int(r.get("domain_min_A", -1))
            reason = str(r.get("reason", "")) if status != "ok" else ""
            n_in = int(r.get("n_in_domain", 0)) if status == "ok" else 0
            pairing = r.get("pairing") if isinstance(r.get("pairing"), dict) else {}
            fit = r.get("fit") if isinstance(r.get("fit"), dict) else {}
            gap_sn = r.get("gap_Sn") if isinstance(r.get("gap_Sn"), dict) else {}
            gap_sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
            sn_tr = gap_sn.get("train_magic") if isinstance(gap_sn.get("train_magic"), dict) else {}
            sn_ot = gap_sn.get("other_magic") if isinstance(gap_sn.get("other_magic"), dict) else {}
            sp_tr = gap_sp.get("train_magic") if isinstance(gap_sp.get("train_magic"), dict) else {}
            sp_ot = gap_sp.get("other_magic") if isinstance(gap_sp.get("other_magic"), dict) else {}
            decision = r.get("decision") if isinstance(r.get("decision"), dict) else {}
            row_out = [
                name,
                domain_a,
                status,
                n_in,
                f"{float(pairing.get('a_n_MeV', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(pairing.get('a_p_MeV', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(fit.get('kN0', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(fit.get('kN1', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(fit.get('kZ0', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(fit.get('kZ1', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(fit.get('kZ_over_kN', float('nan'))):.12g}" if status == "ok" else "",
                int(sn_tr.get("n", 0)) if status == "ok" else "",
                f"{float(sn_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(sn_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                int(sn_ot.get("n", 0)) if status == "ok" else "",
                f"{float(sn_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(sn_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                int(sp_tr.get("n", 0)) if status == "ok" else "",
                f"{float(sp_tr.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(sp_tr.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                int(sp_ot.get("n", 0)) if status == "ok" else "",
                f"{float(sp_ot.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                f"{float(sp_ot.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
            ]
            if include_e2plus:
                spectro = r.get("spectro_e2plus") if isinstance(r.get("spectro_e2plus"), dict) else {}
                spec_sn = spectro.get("gap_Sn_peak") if isinstance(spectro.get("gap_Sn_peak"), dict) else {}
                spec_sp = spectro.get("gap_Sp_peak") if isinstance(spectro.get("gap_Sp_peak"), dict) else {}
                row_out += [
                    int(spec_sn.get("n_available", 0)) if status == "ok" else "",
                    int(spec_sn.get("n_peak", 0)) if status == "ok" else "",
                    f"{float(spec_sn.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(spec_sn.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(spec_sp.get("n_available", 0)) if status == "ok" else "",
                    int(spec_sp.get("n_peak", 0)) if status == "ok" else "",
                    f"{float(spec_sp.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(spec_sp.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    str(bool(decision.get("pass_strict_spectro", False))) if status == "ok" else "",
                ]
            if include_radii_kink:
                kink = r.get("radii_kink") if isinstance(r.get("radii_kink"), dict) else {}
                kink_sn = kink.get("gap_Sn_kink") if isinstance(kink.get("gap_Sn_kink"), dict) else {}
                kink_sp = kink.get("gap_Sp_kink") if isinstance(kink.get("gap_Sp_kink"), dict) else {}
                row_out += [
                    int(kink_sn.get("n_available", 0)) if status == "ok" else "",
                    int(kink_sn.get("n_kink", 0)) if status == "ok" else "",
                    f"{float(kink_sn.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(kink_sn.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    int(kink_sp.get("n_available", 0)) if status == "ok" else "",
                    int(kink_sp.get("n_kink", 0)) if status == "ok" else "",
                    f"{float(kink_sp.get('rms_resid_pairing_only_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(kink_sp.get('rms_resid_pairing_shell_MeV', float('nan'))):.12g}" if status == "ok" else "",
                    str(bool(decision.get("pass_strict_radii_kink", False))) if status == "ok" else "",
                ]
            if include_radii_kink_delta2r:
                d2 = r.get("radii_kink_delta2r") if isinstance(r.get("radii_kink_delta2r"), dict) else {}
                d2_sn = d2.get("gap_Sn_delta2r") if isinstance(d2.get("gap_Sn_delta2r"), dict) else {}
                d2_sp = d2.get("gap_Sp_delta2r") if isinstance(d2.get("gap_Sp_delta2r"), dict) else {}
                row_out += [
                    int(d2_sn.get("n_available", 0)) if status == "ok" else "",
                    int(d2_sn.get("n_kink", 0)) if status == "ok" else "",
                    int(d2_sn.get("n_eval", 0)) if status == "ok" else "",
                    f"{float(d2_sn.get('rms_resid_sigma', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(d2_sn.get('max_abs_resid_sigma', float('nan'))):.12g}" if status == "ok" else "",
                    int(d2_sp.get("n_available", 0)) if status == "ok" else "",
                    int(d2_sp.get("n_kink", 0)) if status == "ok" else "",
                    int(d2_sp.get("n_eval", 0)) if status == "ok" else "",
                    f"{float(d2_sp.get('rms_resid_sigma', float('nan'))):.12g}" if status == "ok" else "",
                    f"{float(d2_sp.get('max_abs_resid_sigma', float('nan'))):.12g}" if status == "ok" else "",
                    str(bool(decision.get("pass_strict_radii_kink_delta2r", False))) if status == "ok" else "",
                ]
            if bool(include_beta2 and beta2_strict_coverage):
                row_out += [
                    str(bool(decision.get("pass_strict_primary", False))) if status == "ok" else "",
                    str(bool(decision.get("pass_strict_direct_only", False))) if status == "ok" else "",
                ]
            row_out += [
                str(bool(decision.get("pass_strict", False))) if status == "ok" else "",
                reason,
            ]
            w.writerow(row_out)

    # Plot: delta RMS (shell - pairing) vs A_min for train/other and Sn/Sp.
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    fig, axes = plt.subplots(2, 2, figsize=(13, 7), constrained_layout=True)
    panels = [
        ("gap_Sn", "other_magic", axes[0][0], "ΔRMS other: gap Sn (shell - pairing)"),
        ("gap_Sp", "other_magic", axes[0][1], "ΔRMS other: gap Sp (shell - pairing)"),
        ("gap_Sn", "train_magic", axes[1][0], "ΔRMS train: gap Sn (shell - pairing)"),
        ("gap_Sp", "train_magic", axes[1][1], "ΔRMS train: gap Sp (shell - pairing)"),
    ]

    for sv in shell_variants:
        name = str(sv["name"])
        ok_rows = [r for r in rows if r.get("status") == "ok" and isinstance(r.get("shell_variant"), dict) and r["shell_variant"].get("name") == name]
        ok_rows = sorted(ok_rows, key=lambda x: int(x.get("domain_min_A", 0)))
        xs = [int(r.get("domain_min_A", 0)) for r in ok_rows]
        for kind, subset, ax, title in panels:
            ys: list[float] = []
            for r in ok_rows:
                g = r.get(kind) if isinstance(r.get(kind), dict) else {}
                sub = g.get(subset) if isinstance(g.get(subset), dict) else {}
                y = float(sub.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(sub.get("rms_resid_pairing_only_MeV", float("nan")))
                ys.append(float(y))
            ax.plot(xs, ys, marker="o", linestyle="-", label=name)
            ax.set_title(title)
            ax.set_xlabel("domain A_min")
            ax.set_ylabel("ΔRMS (MeV)")
            ax.axhline(0.0, color="k", linewidth=1.0, alpha=0.25)
            ax.grid(True, alpha=0.3)

    for ax in axes.flatten():
        ax.legend(fontsize=8)

    if not include_beta2:
        title = f"Phase 7 / Step {step_id}: expanded-set shell-gap decision with isospin-dependent shell refreeze"
    else:
        title = f"Phase 7 / Step {step_id}: expanded-set shell-gap decision with β2-dependent Coulomb factor (NNDC B(E2)) + isospin-dependent shell refreeze"
    fig.suptitle(title, fontsize=12)

    out_png = out_dir / f"nuclear_a_dependence_hf_three_body_shellgap_decision_{out_stub}.png"
    fig.savefig(out_png, dpi=160)
    plt.close(fig)

    out_e2_png: Path | None = None
    out_spec_png: Path | None = None
    out_kink_png: Path | None = None
    out_kink_delta2r_png: Path | None = None
    out_kink_delta2r_csv: Path | None = None
    if include_e2plus:
        def is_peak_n(*, Z: int, N: int) -> bool:
            e0 = e2plus_by_zn.get((int(Z), int(N)))
            eL = e2plus_by_zn.get((int(Z), int(N) - 2))
            eR = e2plus_by_zn.get((int(Z), int(N) + 2))
            return (
                e0 is not None
                and eL is not None
                and eR is not None
                and float(e0) > float(eL)
                and float(e0) > float(eR)
            )

        def is_peak_z(*, Z: int, N: int) -> bool:
            e0 = e2plus_by_zn.get((int(Z), int(N)))
            eL = e2plus_by_zn.get((int(Z) - 2, int(N)))
            eR = e2plus_by_zn.get((int(Z) + 2, int(N)))
            return (
                e0 is not None
                and eL is not None
                and eR is not None
                and float(e0) > float(eL)
                and float(e0) > float(eR)
            )

        pts: list[tuple[int, int, float, bool, bool]] = []
        for (Z, N), A in a_by_zn_all.items():
            if int(A) < int(domain_min_a):
                continue
            e = e2plus_by_zn.get((int(Z), int(N)))
            if e is None:
                continue
            if int(Z) % 2 != 0 or int(N) % 2 != 0:
                continue
            pts.append((int(Z), int(N), float(e) / 1000.0, is_peak_n(Z=int(Z), N=int(N)), is_peak_z(Z=int(Z), N=int(N))))

        if pts:
            fig2, axes2 = plt.subplots(1, 2, figsize=(13, 4.2), constrained_layout=True)
            axN, axZ = axes2[0], axes2[1]

            Ns = [p[1] for p in pts]
            Zs = [p[0] for p in pts]
            Es = [p[2] for p in pts]
            peakN = [p for p in pts if p[3]]
            peakZ = [p for p in pts if p[4]]

            axN.scatter(Ns, Es, s=10, alpha=0.25, color="0.3", label="even-even (E2+ available)")
            if peakN:
                axN.scatter([p[1] for p in peakN], [p[2] for p in peakN], s=18, marker="x", color="tab:red", label="peak in N (±2)")
            for m in OBS_MAGIC[1:]:
                axN.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
            axN.set_title(f"E(2+_1) vs N ({e2plus_source_label}; even-even)")
            axN.set_xlabel("N")
            axN.set_ylabel("E(2+_1) (MeV)")
            axN.grid(True, alpha=0.25)
            axN.legend(fontsize=8)

            axZ.scatter(Zs, Es, s=10, alpha=0.25, color="0.3", label="even-even (E2+ available)")
            if peakZ:
                axZ.scatter([p[0] for p in peakZ], [p[2] for p in peakZ], s=18, marker="x", color="tab:blue", label="peak in Z (±2)")
            for m in OBS_MAGIC[1:]:
                axZ.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
            axZ.set_title(f"E(2+_1) vs Z ({e2plus_source_label}; even-even)")
            axZ.set_xlabel("Z")
            axZ.set_ylabel("E(2+_1) (MeV)")
            axZ.grid(True, alpha=0.25)
            axZ.legend(fontsize=8)

            fig2.suptitle(f"Phase 7 / Step {step_id}: spectroscopic shell-closure proxy (E(2+_1))", fontsize=12)
            out_e2_png = out_dir / f"nuclear_a_dependence_hf_three_body_e2plus_diagnostics_{out_stub}.png"
            fig2.savefig(out_e2_png, dpi=160)
            plt.close(fig2)

    if bool(include_spectro_multi and (spectro_multi_maps is not None)):
        def is_extreme_n(*, metric_by_zn: dict[tuple[int, int], float], Z: int, N: int, kind: str) -> bool:
            v0 = metric_by_zn.get((int(Z), int(N)))
            vL = metric_by_zn.get((int(Z), int(N) - 2))
            vR = metric_by_zn.get((int(Z), int(N) + 2))
            if v0 is None or vL is None or vR is None:
                return False
            if str(kind) == "peak":
                return float(v0) > float(vL) and float(v0) > float(vR)
            if str(kind) == "valley":
                return float(v0) < float(vL) and float(v0) < float(vR)
            raise ValueError(f"unsupported kind: {kind}")

        def is_extreme_z(*, metric_by_zn: dict[tuple[int, int], float], Z: int, N: int, kind: str) -> bool:
            v0 = metric_by_zn.get((int(Z), int(N)))
            vL = metric_by_zn.get((int(Z) - 2, int(N)))
            vR = metric_by_zn.get((int(Z) + 2, int(N)))
            if v0 is None or vL is None or vR is None:
                return False
            if str(kind) == "peak":
                return float(v0) > float(vL) and float(v0) > float(vR)
            if str(kind) == "valley":
                return float(v0) < float(vL) and float(v0) < float(vR)
            raise ValueError(f"unsupported kind: {kind}")

        plot_specs: list[tuple[str, str, dict[tuple[int, int], float], str, str, float]] = [
            ("E(2+_1)", "e2plus_keV", spectro_multi_maps.get("e2plus_keV", {}), "peak", "MeV", 1e-3),
            ("E(4+_1)", "e4plus_keV", spectro_multi_maps.get("e4plus_keV", {}), "peak", "MeV", 1e-3),
            ("E(3-_1)", "e3minus_keV", spectro_multi_maps.get("e3minus_keV", {}), "peak", "MeV", 1e-3),
            ("R4/2", "r42", spectro_multi_maps.get("r42", {}), "valley", "", 1.0),
        ]
        plot_specs = [p for p in plot_specs if p[2]]
        if plot_specs:
            fig3, axes3 = plt.subplots(len(plot_specs), 2, figsize=(13, 3.1 * len(plot_specs)), constrained_layout=True)
            axes_rows = [axes3] if len(plot_specs) == 1 else list(axes3)

            for i, (label, _k, metric_by_zn, kind, yunit, scale) in enumerate(plot_specs):
                axN, axZ = axes_rows[i][0], axes_rows[i][1]

                pts: list[tuple[int, int, float, bool, bool]] = []
                for (Z, N), A in a_by_zn_all.items():
                    if int(A) < int(domain_min_a):
                        continue
                    v = metric_by_zn.get((int(Z), int(N)))
                    if v is None:
                        continue
                    y = float(v) * float(scale)
                    if not math.isfinite(y):
                        continue
                    pts.append(
                        (
                            int(Z),
                            int(N),
                            float(y),
                            is_extreme_n(metric_by_zn=metric_by_zn, Z=int(Z), N=int(N), kind=str(kind)),
                            is_extreme_z(metric_by_zn=metric_by_zn, Z=int(Z), N=int(N), kind=str(kind)),
                        )
                    )

                Ns = [p[1] for p in pts]
                Zs = [p[0] for p in pts]
                Ys = [p[2] for p in pts]
                extN = [p for p in pts if p[3]]
                extZ = [p for p in pts if p[4]]

                markerN = "x" if str(kind) == "peak" else "o"
                markerZ = "x" if str(kind) == "peak" else "o"
                labelN = "peak in N (±2)" if str(kind) == "peak" else "valley in N (±2)"
                labelZ = "peak in Z (±2)" if str(kind) == "peak" else "valley in Z (±2)"

                axN.scatter(Ns, Ys, s=10, alpha=0.25, color="0.3", label=f"even-even ({label} available)")
                if extN:
                    axN.scatter(
                        [p[1] for p in extN],
                        [p[2] for p in extN],
                        s=18,
                        marker=markerN,
                        color="tab:red",
                        label=labelN,
                    )
                for m in OBS_MAGIC[1:]:
                    axN.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
                axN.set_title(f"{label} vs N ({spectro_multi_source_label}; even-even)")
                axN.set_xlabel("N")
                axN.set_ylabel(f"{label} ({yunit})" if yunit else f"{label}")
                axN.grid(True, alpha=0.25)
                axN.legend(fontsize=8)

                axZ.scatter(Zs, Ys, s=10, alpha=0.25, color="0.3", label=f"even-even ({label} available)")
                if extZ:
                    axZ.scatter(
                        [p[0] for p in extZ],
                        [p[2] for p in extZ],
                        s=18,
                        marker=markerZ,
                        color="tab:blue",
                        label=labelZ,
                    )
                for m in OBS_MAGIC[1:]:
                    axZ.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
                axZ.set_title(f"{label} vs Z ({spectro_multi_source_label}; even-even)")
                axZ.set_xlabel("Z")
                axZ.set_ylabel(f"{label} ({yunit})" if yunit else f"{label}")
                axZ.grid(True, alpha=0.25)
                axZ.legend(fontsize=8)

            fig3.suptitle(f"Phase 7 / Step {step_id}: spectroscopy multi-metric diagnostics (NuDat 3.0)", fontsize=12)
            out_spec_png = out_dir / f"nuclear_a_dependence_hf_three_body_spectroscopy_diagnostics_{out_stub}.png"
            fig3.savefig(out_spec_png, dpi=160)
            plt.close(fig3)

    if include_radii_kink:
        fig4, axes4 = plt.subplots(1, 2, figsize=(13, 4), constrained_layout=True)
        axN, axZ = axes4[0], axes4[1]

        ptsN: list[tuple[int, int, float, bool]] = []
        ptsZ: list[tuple[int, int, float, bool]] = []
        for (Z, N) in radii_by_zn.keys():
            infoN = kink_info_n(Z=int(Z), N0=int(N), d=2)
            if infoN is not None:
                sigN, _, _ = infoN
                ptsN.append((int(Z), int(N), float(sigN), float(sigN) >= float(kink_sigma_min)))
            infoZ = kink_info_z(Z0=int(Z), N=int(N), d=2)
            if infoZ is not None:
                sigZ, _, _ = infoZ
                ptsZ.append((int(Z), int(N), float(sigZ), float(sigZ) >= float(kink_sigma_min)))

        Ns = [p[1] for p in ptsN]
        sigNs = [p[2] for p in ptsN]
        Ns_hit = [p[1] for p in ptsN if p[3]]
        sigNs_hit = [p[2] for p in ptsN if p[3]]
        axN.scatter(Ns, sigNs, s=10, alpha=0.25, color="0.3", label="available (Δ²r in N)")
        if Ns_hit:
            axN.scatter(Ns_hit, sigNs_hit, s=20, marker="x", color="tab:red", label=f"kink: |Δ²r|/σ≥{float(kink_sigma_min):g}")
        for m in OBS_MAGIC[1:]:
            axN.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
        axN.set_title("Charge-radii kink significance vs N (IAEA radii; step=2)")
        axN.set_xlabel("N (center)")
        axN.set_ylabel("|Δ²r|/σ")
        axN.grid(True, alpha=0.25)
        axN.legend(fontsize=8)

        Zs = [p[0] for p in ptsZ]
        sigZs = [p[2] for p in ptsZ]
        Zs_hit = [p[0] for p in ptsZ if p[3]]
        sigZs_hit = [p[2] for p in ptsZ if p[3]]
        axZ.scatter(Zs, sigZs, s=10, alpha=0.25, color="0.3", label="available (Δ²r in Z)")
        if Zs_hit:
            axZ.scatter(Zs_hit, sigZs_hit, s=20, marker="x", color="tab:blue", label=f"kink: |Δ²r|/σ≥{float(kink_sigma_min):g}")
        for m in OBS_MAGIC[1:]:
            axZ.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
        axZ.set_title("Charge-radii kink significance vs Z (IAEA radii; step=2)")
        axZ.set_xlabel("Z (center)")
        axZ.set_ylabel("|Δ²r|/σ")
        axZ.grid(True, alpha=0.25)
        axZ.legend(fontsize=8)

        fig4.suptitle(f"Phase 7 / Step {step_id}: charge-radii kink diagnostics (IAEA radii)", fontsize=12)
        out_kink_png = out_dir / f"nuclear_a_dependence_hf_three_body_radii_kink_diagnostics_{out_stub}.png"
        fig4.savefig(out_kink_png, dpi=160)
        plt.close(fig4)

    if include_radii_kink_delta2r:
        resid_sigma_max = float(radii_kink_delta2r_resid_sigma_max)
        out_kink_delta2r_csv = out_dir / f"nuclear_a_dependence_hf_three_body_radii_kink_delta2r_{out_stub}.csv"
        rows_delta2r: list[dict[str, object]] = []

        ptsN: list[tuple[int, int, float, bool, bool]] = []
        ptsZ: list[tuple[int, int, float, bool, bool]] = []

        delta2r_pred_n_diag = delta2r_pred_n
        delta2r_pred_z_diag = delta2r_pred_z
        diag_shell_variant = ""
        diag_shell_nz = False
        diag_r_shell = float("nan")
        diag_r_shell_n = float("nan")
        diag_r_shell_z = float("nan")
        diag_magic_variant = ""
        diag_r_magic_n = float("nan")
        diag_r_magic_z = float("nan")
        diag_magic_neighbor_weight = float("nan")
        diag_magic_neighbor_step = int(-1)
        if bool(radii_kink_delta2r_radius_shell_nz_beta2):
            diag_shell_variant = "obs_magic"
            diag_shell_nz = True
            shell_S_r = shell_S_radius_factory(list(OBS_MAGIC))
            radii_shell_pack = fit_radii_shell_nz_beta2(shell_magic=list(OBS_MAGIC))
            diag_r_shell_n = float(radii_shell_pack.get("r_shell_N_fm", float("nan")))
            diag_r_shell_z = float(radii_shell_pack.get("r_shell_Z_fm", float("nan")))
            if not math.isfinite(diag_r_shell_n):
                diag_r_shell_n = 0.0
            if not math.isfinite(diag_r_shell_z):
                diag_r_shell_z = 0.0
            k_beta2 = 5.0 / (4.0 * math.pi)

            def r_charge_pred_shell_nz_beta2(*, Z: int, N: int) -> float | None:
                base = r_charge_pred(Z=int(Z), N=int(N))
                if base is None:
                    return None
                b2, _ = _beta2_for_zn(
                    Z=int(Z),
                    N=int(N),
                    beta2_by_zn=beta2_by_zn,
                    include_beta2=include_beta2,
                    imputation=str(beta2_imputation),
                )
                b2 = abs(float(b2))
                factor = math.sqrt(1.0 + float(k_beta2) * float(b2) * float(b2))
                sN = float(shell_S_r(int(N)))
                sZ = float(shell_S_r(int(Z)))
                if not (math.isfinite(factor) and factor > 0.0 and math.isfinite(sN) and math.isfinite(sZ)):
                    return None
                out_r = (float(base) + float(diag_r_shell_n) * float(sN) + float(diag_r_shell_z) * float(sZ)) * float(factor)
                if not (math.isfinite(out_r) and out_r > 0.0):
                    return None
                return float(out_r)

            def delta2r_pred_n_shell_nz_beta2(*, Z: int, N0: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_shell_nz_beta2(Z=int(Z), N=int(N0))
                rLp = r_charge_pred_shell_nz_beta2(Z=int(Z), N=int(N0) - int(d))
                rRp = r_charge_pred_shell_nz_beta2(Z=int(Z), N=int(N0) + int(d))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            def delta2r_pred_z_shell_nz_beta2(*, Z0: int, N: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_shell_nz_beta2(Z=int(Z0), N=int(N))
                rLp = r_charge_pred_shell_nz_beta2(Z=int(Z0) - int(d), N=int(N))
                rRp = r_charge_pred_shell_nz_beta2(Z=int(Z0) + int(d), N=int(N))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            delta2r_pred_n_diag = delta2r_pred_n_shell_nz_beta2
            delta2r_pred_z_diag = delta2r_pred_z_shell_nz_beta2
        if bool(radii_kink_delta2r_radius_shell or radii_kink_delta2r_radius_shell_nz):
            diag_shell_variant = "obs_magic"
            shell_S_r = shell_S_radius_factory(list(OBS_MAGIC))
            if bool(radii_kink_delta2r_radius_shell_nz):
                diag_shell_nz = True
                radii_shell_pack = fit_radii_shell_nz(shell_magic=list(OBS_MAGIC))
                diag_r_shell_n = float(radii_shell_pack.get("r_shell_N_fm", float("nan")))
                diag_r_shell_z = float(radii_shell_pack.get("r_shell_Z_fm", float("nan")))
                if not math.isfinite(diag_r_shell_n):
                    diag_r_shell_n = 0.0
                if not math.isfinite(diag_r_shell_z):
                    diag_r_shell_z = 0.0
            else:
                radii_shell_pack = fit_radii_shell(shell_magic=list(OBS_MAGIC))
                diag_r_shell = float(radii_shell_pack.get("r_shell_fm", float("nan")))
                if not math.isfinite(diag_r_shell):
                    diag_r_shell = 0.0

            def r_charge_pred_shell(*, Z: int, N: int) -> float | None:
                base = r_charge_pred(Z=int(Z), N=int(N))
                if base is None:
                    return None
                if diag_shell_nz:
                    sN = float(shell_S_r(int(N)))
                    sZ = float(shell_S_r(int(Z)))
                    if not (math.isfinite(sN) and math.isfinite(sZ)):
                        return None
                    out_r = float(base) + float(diag_r_shell_n) * float(sN) + float(diag_r_shell_z) * float(sZ)
                else:
                    s_sum = float(shell_S_r(int(N)) + shell_S_r(int(Z)))
                    if not math.isfinite(s_sum):
                        return None
                    out_r = float(base) + float(diag_r_shell) * float(s_sum)
                if not (math.isfinite(out_r) and out_r > 0.0):
                    return None
                return float(out_r)

            def delta2r_pred_n_shell(*, Z: int, N0: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_shell(Z=int(Z), N=int(N0))
                rLp = r_charge_pred_shell(Z=int(Z), N=int(N0) - int(d))
                rRp = r_charge_pred_shell(Z=int(Z), N=int(N0) + int(d))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            def delta2r_pred_z_shell(*, Z0: int, N: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_shell(Z=int(Z0), N=int(N))
                rLp = r_charge_pred_shell(Z=int(Z0) - int(d), N=int(N))
                rRp = r_charge_pred_shell(Z=int(Z0) + int(d), N=int(N))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            delta2r_pred_n_diag = delta2r_pred_n_shell
            delta2r_pred_z_diag = delta2r_pred_z_shell

        if bool(radii_kink_delta2r_radius_beta2):
            k_beta2 = 5.0 / (4.0 * math.pi)

            def beta2_for_radius(*, Z: int, N: int) -> float:
                v = beta2_by_zn.get((int(Z), int(N)))
                if v is not None and math.isfinite(float(v)):
                    return float(v)
                vals: list[float] = []
                for z0, n0 in [
                    (int(Z), int(N) - 1),
                    (int(Z), int(N) + 1),
                    (int(Z) - 1, int(N)),
                    (int(Z) + 1, int(N)),
                    (int(Z) - 1, int(N) - 1),
                    (int(Z) - 1, int(N) + 1),
                    (int(Z) + 1, int(N) - 1),
                    (int(Z) + 1, int(N) + 1),
                ]:
                    v0 = beta2_by_zn.get((int(z0), int(n0)))
                    if v0 is None:
                        continue
                    if math.isfinite(float(v0)):
                        vals.append(float(v0))
                return float(sum(vals) / len(vals)) if vals else 0.0

            def r_charge_pred_beta2(*, Z: int, N: int) -> float | None:
                base = r_charge_pred(Z=int(Z), N=int(N))
                if base is None:
                    return None
                b2 = abs(float(beta2_for_radius(Z=int(Z), N=int(N))))
                factor = math.sqrt(1.0 + float(k_beta2) * float(b2) * float(b2))
                out_r = float(base) * float(factor)
                if not (math.isfinite(out_r) and out_r > 0.0):
                    return None
                return float(out_r)

            def delta2r_pred_n_beta2(*, Z: int, N0: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_beta2(Z=int(Z), N=int(N0))
                rLp = r_charge_pred_beta2(Z=int(Z), N=int(N0) - int(d))
                rRp = r_charge_pred_beta2(Z=int(Z), N=int(N0) + int(d))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            def delta2r_pred_z_beta2(*, Z0: int, N: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_beta2(Z=int(Z0), N=int(N))
                rLp = r_charge_pred_beta2(Z=int(Z0) - int(d), N=int(N))
                rRp = r_charge_pred_beta2(Z=int(Z0) + int(d), N=int(N))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            delta2r_pred_n_diag = delta2r_pred_n_beta2
            delta2r_pred_z_diag = delta2r_pred_z_beta2

        if bool(radii_kink_delta2r_radius_odd_even):
            radii_oe_pack = fit_radii_odd_even()
            r_oe_n = float(radii_oe_pack.get("r_oe_N_fm", 0.0))
            r_oe_z = float(radii_oe_pack.get("r_oe_Z_fm", 0.0))
            if not math.isfinite(r_oe_n):
                r_oe_n = 0.0
            if not math.isfinite(r_oe_z):
                r_oe_z = 0.0

            def r_charge_pred_odd_even(*, Z: int, N: int) -> float | None:
                base = r_charge_pred(Z=int(Z), N=int(N))
                if base is None:
                    return None
                eN = 1.0 if (int(N) % 2 != 0) else 0.0
                eZ = 1.0 if (int(Z) % 2 != 0) else 0.0
                out_r = float(base) + float(r_oe_n) * float(eN) + float(r_oe_z) * float(eZ)
                if not (math.isfinite(out_r) and out_r > 0.0):
                    return None
                return float(out_r)

            def delta2r_pred_n_odd_even(*, Z: int, N0: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_odd_even(Z=int(Z), N=int(N0))
                rLp = r_charge_pred_odd_even(Z=int(Z), N=int(N0) - int(d))
                rRp = r_charge_pred_odd_even(Z=int(Z), N=int(N0) + int(d))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            def delta2r_pred_z_odd_even(*, Z0: int, N: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_odd_even(Z=int(Z0), N=int(N))
                rLp = r_charge_pred_odd_even(Z=int(Z0) - int(d), N=int(N))
                rRp = r_charge_pred_odd_even(Z=int(Z0) + int(d), N=int(N))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            delta2r_pred_n_diag = delta2r_pred_n_odd_even
            delta2r_pred_z_diag = delta2r_pred_z_odd_even

        if bool(radii_kink_delta2r_radius_magic_offset):
            diag_magic_variant = "obs_magic"
            radii_magic_pack = fit_radii_magic_offset(magic=list(OBS_MAGIC))
            magic_set = {int(x) for x in radii_magic_pack.get("magic", []) if int(x) > 0}
            diag_r_magic_n = float(radii_magic_pack.get("r_magic_N_fm", float("nan")))
            diag_r_magic_z = float(radii_magic_pack.get("r_magic_Z_fm", float("nan")))
            diag_magic_neighbor_weight = 0.0
            diag_magic_neighbor_step = 2
            if not math.isfinite(diag_r_magic_n):
                diag_r_magic_n = 0.0
            if not math.isfinite(diag_r_magic_z):
                diag_r_magic_z = 0.0

            def r_charge_pred_magic_offset(*, Z: int, N: int) -> float | None:
                base = r_charge_pred(Z=int(Z), N=int(N))
                if base is None:
                    return None
                eN = 1.0 if int(N) in magic_set else 0.0
                eZ = 1.0 if int(Z) in magic_set else 0.0
                out_r = float(base) + float(diag_r_magic_n) * float(eN) + float(diag_r_magic_z) * float(eZ)
                if not (math.isfinite(out_r) and out_r > 0.0):
                    return None
                return float(out_r)

            def delta2r_pred_n_magic_offset(*, Z: int, N0: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_magic_offset(Z=int(Z), N=int(N0))
                rLp = r_charge_pred_magic_offset(Z=int(Z), N=int(N0) - int(d))
                rRp = r_charge_pred_magic_offset(Z=int(Z), N=int(N0) + int(d))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            def delta2r_pred_z_magic_offset(*, Z0: int, N: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_magic_offset(Z=int(Z0), N=int(N))
                rLp = r_charge_pred_magic_offset(Z=int(Z0) - int(d), N=int(N))
                rRp = r_charge_pred_magic_offset(Z=int(Z0) + int(d), N=int(N))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            delta2r_pred_n_diag = delta2r_pred_n_magic_offset
            delta2r_pred_z_diag = delta2r_pred_z_magic_offset
        if bool(radii_kink_delta2r_radius_magic_offset_neighbors):
            diag_magic_variant = "obs_magic_neighbors0p5"
            radii_magic_pack = fit_radii_magic_offset_neighbors(magic=list(OBS_MAGIC), neighbor_weight=0.5, neighbor_step=2)
            w_magic_cfg = radii_magic_pack.get("w_magic") if isinstance(radii_magic_pack.get("w_magic"), dict) else {}
            magic_set = {int(x) for x in w_magic_cfg.get("magic", []) if int(x) > 0}
            diag_magic_neighbor_weight = float(w_magic_cfg.get("neighbor_weight", 0.5))
            diag_magic_neighbor_step = int(w_magic_cfg.get("neighbor_step", 2))
            diag_r_magic_n = float(radii_magic_pack.get("r_magic_N_fm", float("nan")))
            diag_r_magic_z = float(radii_magic_pack.get("r_magic_Z_fm", float("nan")))
            if not math.isfinite(diag_r_magic_n):
                diag_r_magic_n = 0.0
            if not math.isfinite(diag_r_magic_z):
                diag_r_magic_z = 0.0
            if not (math.isfinite(diag_magic_neighbor_weight) and 0.0 <= float(diag_magic_neighbor_weight) <= 1.0):
                diag_magic_neighbor_weight = 0.5
            if int(diag_magic_neighbor_step) <= 0:
                diag_magic_neighbor_step = 2

            def w_magic(x: int) -> float:
                if int(x) in magic_set:
                    return 1.0
                if (int(x) - int(diag_magic_neighbor_step)) in magic_set or (int(x) + int(diag_magic_neighbor_step)) in magic_set:
                    return float(diag_magic_neighbor_weight)
                return 0.0

            def r_charge_pred_magic_offset_neighbors(*, Z: int, N: int) -> float | None:
                base = r_charge_pred(Z=int(Z), N=int(N))
                if base is None:
                    return None
                wN = float(w_magic(int(N)))
                wZ = float(w_magic(int(Z)))
                out_r = float(base) + float(diag_r_magic_n) * float(wN) + float(diag_r_magic_z) * float(wZ)
                if not (math.isfinite(out_r) and out_r > 0.0):
                    return None
                return float(out_r)

            def delta2r_pred_n_magic_offset_neighbors(*, Z: int, N0: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_magic_offset_neighbors(Z=int(Z), N=int(N0))
                rLp = r_charge_pred_magic_offset_neighbors(Z=int(Z), N=int(N0) - int(d))
                rRp = r_charge_pred_magic_offset_neighbors(Z=int(Z), N=int(N0) + int(d))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            def delta2r_pred_z_magic_offset_neighbors(*, Z0: int, N: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_magic_offset_neighbors(Z=int(Z0), N=int(N))
                rLp = r_charge_pred_magic_offset_neighbors(Z=int(Z0) - int(d), N=int(N))
                rRp = r_charge_pred_magic_offset_neighbors(Z=int(Z0) + int(d), N=int(N))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            delta2r_pred_n_diag = delta2r_pred_n_magic_offset_neighbors
            delta2r_pred_z_diag = delta2r_pred_z_magic_offset_neighbors
        if bool(radii_kink_delta2r_radius_magic_offset_per_magic):
            diag_magic_variant = "obs_magic_per_magic"
            radii_magic_pack = fit_radii_magic_offset_per_magic(magic=list(OBS_MAGIC))
            coeffs = radii_magic_pack.get("coeffs") if isinstance(radii_magic_pack.get("coeffs"), dict) else {}
            coeffs_N = coeffs.get("N") if isinstance(coeffs.get("N"), dict) else {}
            coeffs_Z = coeffs.get("Z") if isinstance(coeffs.get("Z"), dict) else {}
            diag_r_magic_n = float("nan")
            diag_r_magic_z = float("nan")
            diag_magic_neighbor_weight = float("nan")
            diag_magic_neighbor_step = 2

            def r_charge_pred_magic_offset_per_magic(*, Z: int, N: int) -> float | None:
                base = r_charge_pred(Z=int(Z), N=int(N))
                if base is None:
                    return None
                dm = float(coeffs_N.get(int(N), 0.0)) + float(coeffs_Z.get(int(Z), 0.0))
                out_r = float(base) + float(dm)
                if not (math.isfinite(out_r) and out_r > 0.0):
                    return None
                return float(out_r)

            def delta2r_pred_n_magic_offset_per_magic(*, Z: int, N0: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_magic_offset_per_magic(Z=int(Z), N=int(N0))
                rLp = r_charge_pred_magic_offset_per_magic(Z=int(Z), N=int(N0) - int(d))
                rRp = r_charge_pred_magic_offset_per_magic(Z=int(Z), N=int(N0) + int(d))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            def delta2r_pred_z_magic_offset_per_magic(*, Z0: int, N: int, d: int = 2) -> float | None:
                r0p = r_charge_pred_magic_offset_per_magic(Z=int(Z0), N=int(N))
                rLp = r_charge_pred_magic_offset_per_magic(Z=int(Z0) - int(d), N=int(N))
                rRp = r_charge_pred_magic_offset_per_magic(Z=int(Z0) + int(d), N=int(N))
                if r0p is None or rLp is None or rRp is None:
                    return None
                return float(rRp) - 2.0 * float(r0p) + float(rLp)

            delta2r_pred_n_diag = delta2r_pred_n_magic_offset_per_magic
            delta2r_pred_z_diag = delta2r_pred_z_magic_offset_per_magic

        diag_shell_extra: dict[str, object] = {}
        if diag_shell_variant:
            if diag_shell_nz:
                diag_shell_extra = {
                    "radius_shell_variant": str(diag_shell_variant),
                    "r_shell_N_fm": float(diag_r_shell_n),
                    "r_shell_Z_fm": float(diag_r_shell_z),
                }
            else:
                diag_shell_extra = {"radius_shell_variant": str(diag_shell_variant), "r_shell_fm": float(diag_r_shell)}

        diag_magic_extra: dict[str, object] = {}
        if diag_magic_variant:
            diag_magic_extra = {
                "radius_magic_variant": str(diag_magic_variant),
                "r_magic_N_fm": float(diag_r_magic_n),
                "r_magic_Z_fm": float(diag_r_magic_z),
                "radius_magic_neighbor_weight": float(diag_magic_neighbor_weight) if math.isfinite(diag_magic_neighbor_weight) else float("nan"),
                "radius_magic_neighbor_step": int(diag_magic_neighbor_step),
            }

        diag_extra: dict[str, object] = {**diag_shell_extra, **diag_magic_extra}

        for (Z, N0) in radii_by_zn.keys():
            info = kink_info_n(Z=int(Z), N0=int(N0), d=2)
            if info is not None:
                A0 = int(Z) + int(N0)
                AL = int(Z) + int(N0) - 2
                AR = int(Z) + int(N0) + 2
                if min(AL, A0, AR) >= int(domain_min_a):
                    sig_obs, d2_obs, sig_obs_fm = info
                    d2_pred = delta2r_pred_n_diag(Z=int(Z), N0=int(N0), d=2)
                    if d2_pred is not None:
                        sig = float(sig_obs_fm)
                        if math.isfinite(sig) and sig > 0:
                            resid = float(d2_pred) - float(d2_obs)
                            z = float(resid) / float(sig)
                            absz = abs(float(z))
                            is_kink = bool(float(sig_obs) >= float(kink_sigma_min))
                            if bool(radii_kink_delta2r_center_magic_only):
                                is_kink = bool(is_kink and int(N0) in set(int(x) for x in OBS_MAGIC))
                            is_reject = bool(is_kink and absz > float(resid_sigma_max))
                            used0 = str(radii_by_zn[(int(Z), int(N0))][2])
                            usedL = str(radii_by_zn[(int(Z), int(N0) - 2)][2])
                            usedR = str(radii_by_zn[(int(Z), int(N0) + 2)][2])
                            rows_delta2r.append(
                                {
                                    "axis": "N",
                                    "Z": int(Z),
                                    "N0": int(N0),
                                    "delta2r_obs_fm": float(d2_obs),
                                    "sigma_obs_fm": float(sig_obs_fm),
                                    "delta2r_pred_fm": float(d2_pred),
                                    "resid_fm": float(resid),
                                    "resid_sigma": float(z),
                                    "abs_resid_sigma": float(absz),
                                    "obs_sig": float(sig_obs),
                                    "is_kink": bool(is_kink),
                                    **diag_extra,
                                    "used_center": used0,
                                    "used_left": usedL,
                                    "used_right": usedR,
                                }
                            )
                            ptsN.append((int(Z), int(N0), float(absz), bool(is_kink), bool(is_reject)))

            infoZ = kink_info_z(Z0=int(Z), N=int(N0), d=2)
            if infoZ is not None:
                A0 = int(Z) + int(N0)
                AL = int(Z) - 2 + int(N0)
                AR = int(Z) + 2 + int(N0)
                if min(AL, A0, AR) >= int(domain_min_a):
                    sig_obs, d2_obs, sig_obs_fm = infoZ
                    d2_pred = delta2r_pred_z_diag(Z0=int(Z), N=int(N0), d=2)
                    if d2_pred is not None:
                        sig = float(sig_obs_fm)
                        if math.isfinite(sig) and sig > 0:
                            resid = float(d2_pred) - float(d2_obs)
                            z = float(resid) / float(sig)
                            absz = abs(float(z))
                            is_kink = bool(float(sig_obs) >= float(kink_sigma_min))
                            if bool(radii_kink_delta2r_center_magic_only):
                                is_kink = bool(is_kink and int(Z) in set(int(x) for x in OBS_MAGIC))
                            is_reject = bool(is_kink and absz > float(resid_sigma_max))
                            used0 = str(radii_by_zn[(int(Z), int(N0))][2])
                            usedL = str(radii_by_zn[(int(Z) - 2, int(N0))][2])
                            usedR = str(radii_by_zn[(int(Z) + 2, int(N0))][2])
                            rows_delta2r.append(
                                {
                                    "axis": "Z",
                                    "Z0": int(Z),
                                    "N": int(N0),
                                    "delta2r_obs_fm": float(d2_obs),
                                    "sigma_obs_fm": float(sig_obs_fm),
                                    "delta2r_pred_fm": float(d2_pred),
                                    "resid_fm": float(resid),
                                    "resid_sigma": float(z),
                                    "abs_resid_sigma": float(absz),
                                    "obs_sig": float(sig_obs),
                                    "is_kink": bool(is_kink),
                                    **diag_extra,
                                    "used_center": used0,
                                    "used_left": usedL,
                                    "used_right": usedR,
                                }
                            )
                            ptsZ.append((int(Z), int(N0), float(absz), bool(is_kink), bool(is_reject)))

        with out_kink_delta2r_csv.open("w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            header_delta2r = [
                "axis",
                "Z",
                "N",
                "delta2r_obs_fm",
                "sigma_obs_fm",
                "delta2r_pred_fm",
                "resid_fm",
                "resid_sigma",
                "abs_resid_sigma",
                "obs_sig",
                "is_kink",
            ]
            if diag_shell_variant:
                if diag_shell_nz:
                    header_delta2r += ["radius_shell_variant", "r_shell_N_fm", "r_shell_Z_fm"]
                else:
                    header_delta2r += ["radius_shell_variant", "r_shell_fm"]
            if diag_magic_variant:
                header_delta2r += [
                    "radius_magic_variant",
                    "r_magic_N_fm",
                    "r_magic_Z_fm",
                    "radius_magic_neighbor_weight",
                    "radius_magic_neighbor_step",
                ]
            header_delta2r += ["used_center", "used_left", "used_right"]
            w.writerow(header_delta2r)
            for r in rows_delta2r:
                axis = str(r.get("axis", ""))
                Zc = int(r.get("Z", r.get("Z0", -1)))
                Nc = int(r.get("N", r.get("N0", -1)))
                row_out = [
                    axis,
                    Zc,
                    Nc,
                    f"{float(r.get('delta2r_obs_fm', float('nan'))):.12g}",
                    f"{float(r.get('sigma_obs_fm', float('nan'))):.12g}",
                    f"{float(r.get('delta2r_pred_fm', float('nan'))):.12g}",
                    f"{float(r.get('resid_fm', float('nan'))):.12g}",
                    f"{float(r.get('resid_sigma', float('nan'))):.12g}",
                    f"{float(r.get('abs_resid_sigma', float('nan'))):.12g}",
                    f"{float(r.get('obs_sig', float('nan'))):.12g}",
                    str(bool(r.get("is_kink", False))),
                ]
                if diag_shell_variant:
                    if diag_shell_nz:
                        row_out += [
                            str(r.get("radius_shell_variant", "")),
                            f"{float(r.get('r_shell_N_fm', float('nan'))):.12g}",
                            f"{float(r.get('r_shell_Z_fm', float('nan'))):.12g}",
                        ]
                    else:
                        row_out += [
                            str(r.get("radius_shell_variant", "")),
                            f"{float(r.get('r_shell_fm', float('nan'))):.12g}",
                        ]
                if diag_magic_variant:
                    row_out += [
                        str(r.get("radius_magic_variant", "")),
                        f"{float(r.get('r_magic_N_fm', float('nan'))):.12g}",
                        f"{float(r.get('r_magic_Z_fm', float('nan'))):.12g}",
                        f"{float(r.get('radius_magic_neighbor_weight', float('nan'))):.12g}",
                        int(r.get("radius_magic_neighbor_step", -1)),
                    ]
                row_out += [
                    str(r.get("used_center", "")),
                    str(r.get("used_left", "")),
                    str(r.get("used_right", "")),
                ]
                w.writerow(row_out)

        fig5, axes5 = plt.subplots(1, 2, figsize=(13, 4), constrained_layout=True)
        axN, axZ = axes5[0], axes5[1]

        Ns = [p[1] for p in ptsN]
        ysN = [p[2] for p in ptsN]
        kink_ok_N = [p for p in ptsN if p[3] and not p[4]]
        kink_rej_N = [p for p in ptsN if p[3] and p[4]]
        axN.scatter(Ns, ysN, s=10, alpha=0.25, color="0.3", label="available (Δ²r residual in N)")
        if kink_ok_N:
            axN.scatter([p[1] for p in kink_ok_N], [p[2] for p in kink_ok_N], s=22, marker="x", color="tab:green", label="kink: pass")
        if kink_rej_N:
            axN.scatter([p[1] for p in kink_rej_N], [p[2] for p in kink_rej_N], s=22, marker="x", color="tab:red", label="kink: reject")
        axN.axhline(float(resid_sigma_max), color="k", linewidth=1.0, alpha=0.35, linestyle="--")
        for m in OBS_MAGIC[1:]:
            axN.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
        axN.set_title("Charge-radii kink residual |Δ²r_pred-Δ²r_obs|/σ_obs vs N (IAEA; step=2)")
        axN.set_xlabel("N (center)")
        axN.set_ylabel("|residual| / σ_obs")
        axN.grid(True, alpha=0.25)
        axN.legend(fontsize=8)

        Zs = [p[0] for p in ptsZ]
        ysZ = [p[2] for p in ptsZ]
        kink_ok_Z = [p for p in ptsZ if p[3] and not p[4]]
        kink_rej_Z = [p for p in ptsZ if p[3] and p[4]]
        axZ.scatter(Zs, ysZ, s=10, alpha=0.25, color="0.3", label="available (Δ²r residual in Z)")
        if kink_ok_Z:
            axZ.scatter([p[0] for p in kink_ok_Z], [p[2] for p in kink_ok_Z], s=22, marker="x", color="tab:green", label="kink: pass")
        if kink_rej_Z:
            axZ.scatter([p[0] for p in kink_rej_Z], [p[2] for p in kink_rej_Z], s=22, marker="x", color="tab:blue", label="kink: reject")
        axZ.axhline(float(resid_sigma_max), color="k", linewidth=1.0, alpha=0.35, linestyle="--")
        for m in OBS_MAGIC[1:]:
            axZ.axvline(int(m), color="k", linewidth=1.0, alpha=0.12)
        axZ.set_title("Charge-radii kink residual |Δ²r_pred-Δ²r_obs|/σ_obs vs Z (IAEA; step=2)")
        axZ.set_xlabel("Z (center)")
        axZ.set_ylabel("|residual| / σ_obs")
        axZ.grid(True, alpha=0.25)
        axZ.legend(fontsize=8)

        fig5.suptitle(f"Phase 7 / Step {step_id}: charge-radii kink observable (Δ²r) residual diagnostics", fontsize=12)
        out_kink_delta2r_png = out_dir / f"nuclear_a_dependence_hf_three_body_radii_kink_delta2r_diagnostics_{out_stub}.png"
        fig5.savefig(out_kink_delta2r_png, dpi=160)
        plt.close(fig5)

    # Decision summary.
    ok_rows = [r for r in rows if r.get("status") == "ok"]
    n_pass = sum(1 for r in ok_rows if bool((r.get("decision") or {}).get("pass_strict", False)))

    best_sp_other = None
    for r in ok_rows:
        sp = r.get("gap_Sp") if isinstance(r.get("gap_Sp"), dict) else {}
        other = sp.get("other_magic") if isinstance(sp.get("other_magic"), dict) else {}
        if int(other.get("n", 0)) <= 0:
            continue
        delta = float(other.get("rms_resid_pairing_shell_MeV", float("nan"))) - float(other.get("rms_resid_pairing_only_MeV", float("nan")))
        if not math.isfinite(delta):
            continue
        if best_sp_other is None or delta < best_sp_other["delta"]:
            best_sp_other = {
                "shell_variant": r.get("shell_variant"),
                "domain_min_A": int(r.get("domain_min_A", -1)),
                "delta": float(delta),
                "pair": float(other.get("rms_resid_pairing_only_MeV", float("nan"))),
                "shell": float(other.get("rms_resid_pairing_shell_MeV", float("nan"))),
                "n": int(other.get("n", 0)),
            }

    if not include_beta2:
        conclusion = (
            f"strict_pass={n_pass}/{len(ok_rows)} over shell variants × A_min cuts. "
            "This step adds a minimal structure DoF candidate by allowing the shell refreeze coefficients to depend linearly on isospin asymmetry "
            "kN(I)=kN0+kN1*I and kZ(I)=kZ0+kZ1*I, with all coefficients frozen on train magic N/Z in {50,82} only. "
            "If strict_pass==0, additional independently frozen structure inputs are still required."
        )
    else:
        conclusion = (
            f"strict_pass={n_pass}/{len(ok_rows)} over shell variants × A_min cuts. "
            "This step adds an independently constrained deformation input β2 (NNDC B(E2) adopted entries) and applies a deterministic Coulomb shape factor f(β2) "
            "on top of the frozen radius model + finite-size Coulomb baseline, while keeping the shell refreeze coefficients isospin-dependent "
            "kN(I)=kN0+kN1*I and kZ(I)=kZ0+kZ1*I (frozen on train magic N/Z in {50,82} only). "
            "If strict_pass==0, additional independently frozen structure inputs (beyond β2) are still required."
        )

    if include_beta2:
        applied_bits = ["Coulomb shape factor f(beta2)"]
        if beta2_apply_surface:
            applied_bits.append("surface-area factor g(beta2) on the surface term")
        if beta2_strict_coverage:
            applied_bits.append("robust: require agreement with direct-only (no-imputation) run")
        applied_text = ", ".join(applied_bits)
        conclusion = (
            f"strict_pass={n_pass}/{len(ok_rows)} over shell variants x A_min cuts. "
            f"This step adds an independently constrained deformation input beta2 (NNDC B(E2) adopted entries) and applies {applied_text} "
            "on top of the frozen radius model + finite-size Coulomb baseline, while keeping the shell refreeze coefficients isospin-dependent "
            "kN(I)=kN0+kN1*I and kZ(I)=kZ0+kZ1*I (frozen on train magic N/Z in {50,82} only). "
            "If strict_pass==0, additional independently frozen structure inputs (beyond beta2) are still required."
        )

    if include_e2plus:
        conclusion = str(conclusion) + " This step also integrates a spectroscopy-based strict cross-check using E(2+_1) local peaks."
    if include_spectro_multi:
        conclusion = (
            str(conclusion)
            + " This step also integrates a spectroscopy-based strict cross-check using multiple NuDat 3.0 metrics (E2+, E4+, E3-, R4/2) via local extrema."
        )
    if include_radii_kink:
        conclusion = (
            str(conclusion)
            + f" This step also integrates a charge-radii kink strict cross-check (|Δ²r|/σ>= {float(kink_sigma_min):g} with step=2)."
        )
    if include_radii_kink_delta2r:
        conclusion = (
            str(conclusion)
            + f" This step also compares charge-radii kink as an observable (Δ²r_pred vs Δ²r_obs; step=2) and applies a fixed residual threshold |Δ²r_pred-Δ²r_obs|/σ_obs <= {float(radii_kink_delta2r_resid_sigma_max):g}."
        )
    if float(shell_s_power_g) != 1.0:
        conclusion = str(conclusion) + f" S_shell normalization: p(p-g)/g^{float(shell_s_power_g):g}."

    out_json = out_dir / f"nuclear_a_dependence_hf_three_body_shellgap_decision_{out_stub}_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": str(step_id),
                "scan": {
                    "domain_min_A_base": int(domain_min_a),
                    "domain_min_A_candidates": scan_a_mins,
                    "shell_variants": shell_variants,
                    "shell_S_power_g": float(shell_s_power_g),
                },
                "baseline": {
                    "radius_model": {
                        "form": radius_model_form,
                        "r0_fm": float(r0),
                        "rI_fm": float(rI),
                        "fit_min_A": int(fit_min_a),
                        "n_fit": int(n_fit),
                        "fit_rms_fm": float(fit_rms),
                        "mean_I_fit": float(mean_I_fit) if math.isfinite(mean_I_fit) else float("nan"),
                        "frozen_from_metrics": str(metrics_71523_path),
                    },
                    "coulomb_finite_size": {
                        "profile": "2pF (fixed a; c from r_rms via bisection)",
                        "a_fm": float(a_diff_fm),
                        "dr_fm": float(dr_fm),
                        "r_max_rule": "max(20, 3*r_rms + 20*a)",
                        "exchange": "Slater (LDA) on 2pF density",
                        "coef_slater": float(coef_slater),
                        "e2_MeV_fm": float(e2_mev_fm),
                        "cache_round_fm": float(cache_round_fm),
                    },
                    **(
                        {
                            "deformation_beta2": {
                                "source": "NNDC B(E2) adopted entries",
                                "extracted_beta2_path": str(beta2_path),
                                "imputation_policy": str(beta2_imputation),
                                "imputation": "direct for even-even when present; otherwise average of available even-even neighbors (Z±1,N±1), else 0",
                                "applied_to": {
                                    "coulomb_shape_factor": True,
                                    "surface_area_factor": bool(beta2_apply_surface),
                                },
                                "counts_in_domain": {"direct": int(n_beta2_direct), "imputed": int(n_beta2_imputed), "missing": int(n_beta2_missing)},
                                **(
                                    {
                                        "strict_coverage": bool(beta2_strict_coverage),
                                        "direct_only_counts_in_domain": beta2_counts_direct_only,
                                        "n_skipped_direct_only": int(n_skipped_direct_only),
                                        "rule": "pass_strict := pass_strict_primary AND pass_strict_direct_only",
                                    }
                                    if bool(beta2_strict_coverage and (beta2_counts_direct_only is not None))
                                    else {}
                                ),
                                "note": "B(E2)-derived β2 is treated as a magnitude; the Coulomb shape factor uses |β2|.",
                            }
                        }
                        if include_beta2
                        else {}
                    ),
                    **(
                        {
                            "spectroscopy_e2plus": {
                                "source": str(e2plus_source_label),
                                "extracted_e2plus_path": str(e2plus_path),
                                "units": {"e2plus_keV": "keV"},
                                "peak_rule": {
                                    "gap_Sn": "E2+(Z,N0) > E2+(Z,N0±2) when neighbors exist (even-even only)",
                                    "gap_Sp": "E2+(Z0,N) > E2+(Z0±2,N) when neighbors exist (even-even only)",
                                },
                                "strict_peaks": bool(e2plus_strict_peaks),
                                "note": str(e2plus_note),
                            }
                        }
                        if include_e2plus
                        else {}
                    ),
                    **(
                        {
                            "spectroscopy_nudat3_multi": {
                                "source": str(spectro_multi_source_label),
                                "extracted_spectroscopy_path": str(spectro_multi_path),
                                "metrics": {
                                    "e2plus_keV": "E(2+_1) energy (keV; peak rule)",
                                    "e4plus_keV": "E(4+_1) energy (keV; peak rule)",
                                    "e3minus_keV": "E(3-_1) energy (keV; peak rule)",
                                    "r42": "R4/2 (dimensionless; valley rule)",
                                },
                                "strict_multi": bool(spectro_multi_strict),
                                "note": str(spectro_multi_note),
                            }
                        }
                        if include_spectro_multi
                        else {}
                    ),
                    **(
                        {
                            "radii_kink": {
                                "source": "IAEA charge_radii.csv",
                                "definition": {
                                    "delta2": "Δ²r = r(x+2) - 2 r(x) + r(x-2)",
                                    "sigma": "σ(Δ²r) = sqrt(σ(x+2)^2 + 4σ(x)^2 + σ(x-2)^2) (independent; no covariance)",
                                    "threshold": float(kink_sigma_min),
                                    "step": 2,
                                    "axes": {"gap_Sn": "x=N at fixed Z", "gap_Sp": "x=Z at fixed N"},
                                },
                                "strict_kink": bool(radii_kink_strict),
                                "counts_in_csv": dict(radii_kink_counts),
                            }
                        }
                        if include_radii_kink
                        else {}
                    ),
                    **(
                        {
                            "radii_kink_delta2r": {
                                "source": "IAEA charge_radii.csv",
                                "definition": {
                                    "delta2": "Δ²r = r(x+2) - 2 r(x) + r(x-2)",
                                    "sigma_obs": "σ_obs(Δ²r) = sqrt(σ(x+2)^2 + 4σ(x)^2 + σ(x-2)^2) (independent; no covariance)",
                                    "resid_sigma": "resid_sigma = (Δ²r_pred - Δ²r_obs) / σ_obs(Δ²r)",
                                    "kink_threshold": float(kink_sigma_min),
                                    "residual_threshold": float(radii_kink_delta2r_resid_sigma_max),
                                    "step": 2,
                                    "axes": {"gap_Sn": "x=N at fixed Z", "gap_Sp": "x=Z at fixed N"},
                                },
                                "strict_delta2r": bool(radii_kink_delta2r_strict),
                                "fit_rms_fm": float(fit_rms),
                                "sigma_model_delta2r_fm": float(sigma_model_delta2r_fm),
                                "counts_in_csv": dict(radii_kink_counts),
                            }
                        }
                        if include_radii_kink_delta2r
                        else {}
                    ),
                },
                "shell_model": {
                    "form": "kN(I)=kN0+kN1*I, kZ(I)=kZ0+kZ1*I (I=(N-Z)/A)",
                    "S_shell": {
                        "form": "x in (Mk,Mk1], p=x-Mk, g=Mk1-Mk; S_shell=p(p-g)/g^power (0 at magic boundaries)",
                        "power_g": float(shell_s_power_g),
                    },
                    "train_magic": sorted(int(x) for x in TRAIN_MAGIC),
                    "note": "All coefficients are frozen using train magic only; other_magic is used for rejection (strict).",
                },
                "diag": {
                    "n_ame_total": int(len(ame_map)),
                    "n_in_domain_base": int(len(a_by_zn_all)),
                    "n_skipped_base": int(n_skipped),
                    "n_cached_r_rms": int(len(finite_cache)),
                    "best_gap_Sp_other_delta": best_sp_other,
                    "conclusion": conclusion,
                },
                "results": rows,
                "inputs": {
                    "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                    "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                    **(
                        {
                            "nndc_be2_adopted_entries_json": {"path": str(beta2_raw_path), "sha256": _sha256(beta2_raw_path)},
                            "nndc_be2_manifest": {"path": str(beta2_manifest_path), "sha256": _sha256(beta2_manifest_path)},
                            **(
                                {"nndc_be2_extracted_beta2": {"path": str(beta2_path), "sha256": _sha256(beta2_path)}}
                                if include_beta2
                                else {}
                            ),
                            **(
                                {"nndc_be2_extracted_e2plus": {"path": str(e2plus_path), "sha256": _sha256(e2plus_path)}}
                                if include_e2plus
                                else {}
                            ),
                        }
                        if (include_beta2 or include_e2plus)
                        else {}
                    ),
                    **(
                        {
                            **(
                                {
                                    "nndc_nudat3_manifest": {
                                        "path": str(Path(spectro_multi_path).parent / "manifest.json"),
                                        "sha256": _sha256(Path(spectro_multi_path).parent / "manifest.json"),
                                    }
                                }
                                if (spectro_multi_path is not None and (Path(spectro_multi_path).parent / "manifest.json").exists())
                                else {}
                            ),
                            "nndc_nudat3_extracted_spectroscopy": {
                                "path": str(spectro_multi_path),
                                "sha256": _sha256(Path(spectro_multi_path)),
                            },
                        }
                        if (include_spectro_multi and spectro_multi_path is not None)
                        else {}
                    ),
                    "metrics_7_13_15": {"path": str(metrics_hf_path), "sha256": _sha256(metrics_hf_path)},
                    "metrics_7_13_15_7": {"path": str(metrics_7157_path), "sha256": _sha256(metrics_7157_path)},
                    "metrics_7_13_15_23": {"path": str(metrics_71523_path), "sha256": _sha256(metrics_71523_path)},
                },
                "outputs": {
                    "png": str(out_png),
                    "csv": str(out_csv),
                    **({"e2plus_png": str(out_e2_png)} if out_e2_png is not None else {}),
                    **({"spectroscopy_png": str(out_spec_png)} if out_spec_png is not None else {}),
                    **({"radii_kink_png": str(out_kink_png)} if out_kink_png is not None else {}),
                    **({"radii_kink_delta2r_png": str(out_kink_delta2r_png)} if out_kink_delta2r_png is not None else {}),
                    **({"radii_kink_delta2r_csv": str(out_kink_delta2r_csv)} if out_kink_delta2r_csv is not None else {}),
                },
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    if out_e2_png is not None:
        print(f"  {out_e2_png}")
    if out_spec_png is not None:
        print(f"  {out_spec_png}")
    if out_kink_png is not None:
        print(f"  {out_kink_png}")
    if out_kink_delta2r_png is not None:
        print(f"  {out_kink_delta2r_png}")
    if out_kink_delta2r_csv is not None:
        print(f"  {out_kink_delta2r_csv}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_28(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.28 (initial): Add an independently constrained structure input (β2) and re-run the
    expanded-set strict shell-gap decision scan.

    This step reuses the Step 7.13.15.27 protocol (isospin-dependent shell refreeze frozen on train magic),
    while applying an additional deformation-dependent Coulomb shape factor f(β2) derived from NNDC B(E2)
    adopted entries (cached under data/quantum/sources/ for offline reproducibility).
    """
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.28",
        out_stub="expanded_shell_i_dep_beta2",
        include_beta2=True,
    )


def _run_step_7_13_15_29(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.29 (initial): Reflect β2 also into the surface term and integrate β2 coverage robustness
    (direct-only vs imputed) into the strict decision.
    """
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.29",
        out_stub="expanded_shell_i_dep_beta2_surface_cov",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
    )


def _run_step_7_13_15_30(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.30 (initial): Add a spectroscopic shell-closure cross-check using E(2+_1) (NNDC; derived from
    the transitionEnergy field in the B(E2) adopted entries) and integrate it as an additional strict rejection
    filter based on local-peak diagnostics.
    """
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.30",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_e2plus",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_e2plus=True,
        e2plus_strict_peaks=True,
    )


def _run_step_7_13_15_31(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.31 (initial): Expand the E(2+_1) coverage using NuDat 3.0 chart JSON (ENSDF-derived) and
    re-run the same strict spectroscopic cross-check protocol as in Step 7.13.15.30.
    """
    root = Path(__file__).resolve().parents[2]
    e2plus_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_e2plus.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.31",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_e2plus_nudat3",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_e2plus=True,
        e2plus_strict_peaks=True,
        e2plus_path_override=e2plus_path,
        e2plus_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.firstTwoPlusEnergy)",
        e2plus_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1); cross-check is based on local peaks along isotopic/isotonic chains.",
        e2plus_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
    )


def _run_step_7_13_15_32(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.32 (initial): Expand the spectroscopy cross-check to multiple NuDat 3.0 observables
    (E(2+_1), E(4+_1), E(3-_1), R4/2) and integrate them as an additional strict rejection filter.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.32",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
    )


def _run_step_7_13_15_33(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.33 (initial): Expanded set (beta2 + NuDat 3.0 multi-metric strict cross-check),
    but switch the shell basis normalization to a fractional-occupancy form:

      S_shell = p(p-g) / g^2

    This removes the linear-in-g amplitude scaling of the legacy S_shell and tests whether
    the same train-only freeze (train magic in {50,82}) can generalize to other magic numbers.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.33",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_shellS_g2",
        shell_s_power_g=2.0,
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
    )


def _run_step_7_13_15_34(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.34 (initial): Expanded set (beta2 + NuDat 3.0 multi-metric strict cross-check),
    plus an independent shell-closure proxy based on charge-radius kinks (isotope/isotone shifts).

    The kink proxy is defined and frozen as:
      - along isotopic chains (fixed Z): x=N, step=2, Δ²r = r(N+2)-2r(N)+r(N-2)
      - along isotonic chains (fixed N): x=Z, step=2, Δ²r = r(Z+2)-2r(Z)+r(Z-2)
      - significance: |Δ²r|/σ(Δ²r), with independent σ propagation
      - strict threshold: >= 3σ
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.34",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink=True,
        radii_kink_strict=True,
        radii_kink_sigma_min=3.0,
    )


def _run_step_7_13_15_35(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.35 (initial): Treat the charge-radii kink as an observable (Δ²r) and compare
    Δ²r_pred (from the frozen r_charge model) directly against Δ²r_obs (IAEA), integrating a
    fixed σ-propagated residual threshold into the strict decision.

    Definitions are frozen (p-hacking avoidance):
      - step=2 second difference: Δ²r = r(x+2)-2r(x)+r(x-2)
      - σ_obs(Δ²r) via independent propagation (no covariance)
      - kink selection: |Δ²r_obs|/σ_obs >= 3
      - strict residual: |Δ²r_pred-Δ²r_obs|/σ_obs <= 3
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.35",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_36(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.36 (initial): Introduce a minimal shell term (one DoF) into the radius mapping and
    re-check the Δ²r (kink) observable under the same fixed strict thresholds as 7.13.15.35.

    Minimal DoF:
      - r_charge = r_base + r_shell*(S(N)+S(Z)), with S=p(p-g)/g^2 on a chosen magic list.
      - r_shell is fit using IAEA radii only (no mass/gap retuning).
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.36",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_shell",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_shell=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_37(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.37 (initial): Introduce a minimal shell term (two DoFs) into the radius mapping and
    re-check the Δ²r (kink) observable under the same fixed strict thresholds as 7.13.15.35.

    Minimal DoF:
      - r_charge = r_base + r_shell_N*S(N) + r_shell_Z*S(Z), with S=p(p-g)/g^2 on a chosen magic list.
      - (r_shell_N, r_shell_Z) are fit using IAEA radii only (no mass/gap retuning).
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.37",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_shell_nz",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_shell_nz=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_38(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.38 (initial): Apply a deformation-aware (beta2-based) radius correction and
    re-check the Δ²r (kink) observable under the same fixed strict thresholds as 7.13.15.35.

    Minimal change:
      - r_charge = r_base * sqrt(1 + (5/(4π))*beta2^2), where beta2 is from NNDC B(E2) adopted entries.
      - Missing beta2 is imputed deterministically from nearest neighbors; otherwise 0.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.38",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_beta2",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_beta2=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_39(*, out_dir: Path) -> None:
    """
    Step 7.13.15.39 (initial): Summarize the strict Δ²r (kink) series (7.13.15.35–.38)
    across radius-mapping variants and freeze a reproducible "no-go" record.
    """
    import csv
    import json
    import math

    import matplotlib.pyplot as plt

    generated_utc = __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat()

    variants: list[tuple[str, str]] = [
        ("radius_base", "expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r"),
        ("radius_shell", "expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_shell"),
        ("radius_shell_nz", "expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_shell_nz"),
        ("radius_beta2", "expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_beta2"),
    ]

    in_paths: dict[str, Path] = {}
    for variant_name, out_stub in variants:
        p = out_dir / f"nuclear_a_dependence_hf_three_body_shellgap_decision_{out_stub}_metrics.json"
        if not p.exists():
            raise SystemExit(
                "[fail] missing inputs for Step 7.13.15.39.\n"
                f"- missing: {p}\n"
                "Run the prerequisite steps:\n"
                "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.35\n"
                "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.36\n"
                "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.37\n"
                "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.38\n"
            )
        in_paths[variant_name] = p

    rows: list[dict[str, object]] = []
    for variant_name, metrics_path in in_paths.items():
        m = _load_json(metrics_path)
        results = m.get("results")
        if not isinstance(results, list) or not results:
            raise SystemExit(f"[fail] invalid metrics (missing/empty results): {metrics_path}")
        for r in results:
            if not isinstance(r, dict):
                continue
            domain_min_a = int(r.get("domain_min_A", 0) or 0)

            shell_variant = r.get("shell_variant")
            shell_variant_name = ""
            if isinstance(shell_variant, dict):
                shell_variant_name = str(shell_variant.get("name", ""))

            decision = r.get("decision")
            pass_strict = False
            pass_delta2r = False
            if isinstance(decision, dict):
                pass_strict = bool(decision.get("pass_strict"))
                pass_delta2r = bool(decision.get("pass_strict_radii_kink_delta2r"))

            d2 = r.get("radii_kink_delta2r")
            gap_sn = d2.get("gap_Sn_delta2r") if isinstance(d2, dict) else None
            gap_sp = d2.get("gap_Sp_delta2r") if isinstance(d2, dict) else None
            max_sn = float(gap_sn.get("max_abs_resid_sigma", float("nan"))) if isinstance(gap_sn, dict) else float("nan")
            max_sp = float(gap_sp.get("max_abs_resid_sigma", float("nan"))) if isinstance(gap_sp, dict) else float("nan")
            rms_sn = float(gap_sn.get("rms_resid_sigma", float("nan"))) if isinstance(gap_sn, dict) else float("nan")
            rms_sp = float(gap_sp.get("rms_resid_sigma", float("nan"))) if isinstance(gap_sp, dict) else float("nan")

            finite_max = [v for v in (max_sn, max_sp) if math.isfinite(float(v))]
            max_overall = max(finite_max) if finite_max else float("nan")
            finite_rms = [v for v in (rms_sn, rms_sp) if math.isfinite(float(v))]
            rms_overall = max(finite_rms) if finite_rms else float("nan")

            worst_axis = "Sp" if (math.isfinite(max_sp) and (not math.isfinite(max_sn) or max_sp >= max_sn)) else "Sn"
            worst_points = []
            if worst_axis == "Sp" and isinstance(gap_sp, dict):
                worst_points = gap_sp.get("worst_points") if isinstance(gap_sp.get("worst_points"), list) else []
            if worst_axis == "Sn" and isinstance(gap_sn, dict):
                worst_points = gap_sn.get("worst_points") if isinstance(gap_sn.get("worst_points"), list) else []
            worst0 = worst_points[0] if worst_points else {}
            worst_key = ""
            worst_abs = float("nan")
            if isinstance(worst0, dict):
                if worst_axis == "Sp":
                    worst_key = f"Z0={int(worst0.get('Z0', -1))},N={int(worst0.get('N', -1))}"
                else:
                    worst_key = f"Z={int(worst0.get('Z', -1))},N0={int(worst0.get('N0', -1))}"
                worst_abs = float(worst0.get("abs_resid_sigma", float("nan")))

            rows.append(
                {
                    "variant": variant_name,
                    "domain_min_A": domain_min_a,
                    "shell_variant": shell_variant_name,
                    "pass_strict": bool(pass_strict),
                    "pass_radii_kink_delta2r": bool(pass_delta2r),
                    "max_abs_resid_sigma": float(max_overall),
                    "rms_resid_sigma": float(rms_overall),
                    "worst_axis": worst_axis,
                    "worst_point": worst_key,
                    "worst_abs_resid_sigma": float(worst_abs),
                    "metrics_path": str(metrics_path),
                }
            )

    rows.sort(key=lambda d: (str(d["variant"]), str(d["shell_variant"]), int(d["domain_min_A"])))

    out_csv = out_dir / "nuclear_a_dependence_hf_three_body_radii_kink_delta2r_strict_summary.csv"
    with out_csv.open("w", encoding="utf-8", newline="") as f:
        w = csv.writer(f)
        w.writerow(
            [
                "variant",
                "shell_variant",
                "domain_min_A",
                "pass_strict",
                "pass_radii_kink_delta2r",
                "max_abs_resid_sigma",
                "rms_resid_sigma",
                "worst_axis",
                "worst_point",
                "worst_abs_resid_sigma",
                "metrics_path",
            ]
        )
        for r in rows:
            w.writerow(
                [
                    str(r["variant"]),
                    str(r["shell_variant"]),
                    int(r["domain_min_A"]),
                    int(bool(r["pass_strict"])),
                    int(bool(r["pass_radii_kink_delta2r"])),
                    f"{float(r['max_abs_resid_sigma']):.12g}",
                    f"{float(r['rms_resid_sigma']):.12g}",
                    str(r["worst_axis"]),
                    str(r["worst_point"]),
                    f"{float(r['worst_abs_resid_sigma']):.12g}",
                    str(r["metrics_path"]),
                ]
            )

    # Summary counts + best rows (closest to the strict threshold).
    strict_threshold = 3.0
    summary: dict[str, object] = {
        "generated_utc": generated_utc,
        "phase": 7,
        "step": "7.13.15.39",
        "inputs": {k: str(v) for k, v in in_paths.items()},
        "strict_threshold": strict_threshold,
        "variants": {},
        "outputs": {"csv": str(out_csv)},
    }
    per_variant: dict[str, list[dict[str, object]]] = {}
    for r in rows:
        per_variant.setdefault(str(r["variant"]), []).append(r)
    for variant_name, vrows in per_variant.items():
        n_total = len(vrows)
        n_pass_strict = sum(1 for r in vrows if bool(r.get("pass_strict")))
        n_pass_delta2r = sum(1 for r in vrows if bool(r.get("pass_radii_kink_delta2r")))
        best = min(
            vrows,
            key=lambda r: float(r.get("max_abs_resid_sigma", float("inf"))),
        )
        summary["variants"][variant_name] = {
            "n_total": int(n_total),
            "n_pass_strict": int(n_pass_strict),
            "n_pass_radii_kink_delta2r": int(n_pass_delta2r),
            "best": {k: best[k] for k in ("shell_variant", "domain_min_A", "max_abs_resid_sigma", "worst_axis", "worst_point")},
        }

    out_json = out_dir / "nuclear_a_dependence_hf_three_body_radii_kink_delta2r_strict_summary_metrics.json"
    with out_json.open("w", encoding="utf-8") as f:
        json.dump(summary, f, ensure_ascii=False, indent=2)
    summary["outputs"]["json"] = str(out_json)

    # Visual summary: one panel per radius-mapping variant.
    fig, axs = plt.subplots(2, 2, figsize=(12, 8), sharex=True, sharey=True)
    axs_list = [axs[0, 0], axs[0, 1], axs[1, 0], axs[1, 1]]
    shell_order = ["model_magic", "obs_magic"]
    for ax, (variant_name, _stub) in zip(axs_list, variants):
        vrows = [r for r in rows if str(r["variant"]) == variant_name]
        for shell_name in shell_order:
            sub = [r for r in vrows if str(r["shell_variant"]) == shell_name]
            sub.sort(key=lambda r: int(r["domain_min_A"]))
            xs = [int(r["domain_min_A"]) for r in sub]
            ys = [float(r["max_abs_resid_sigma"]) for r in sub]
            ax.plot(xs, ys, marker="o", linewidth=1.5, label=shell_name)
        ax.axhline(strict_threshold, color="k", linestyle="--", linewidth=1.0)
        ax.set_title(variant_name)
        ax.set_xlabel("domain_min_A")
        ax.set_ylabel("max |Δ²r_pred-Δ²r_obs| / σ_obs")
        ax.grid(True, alpha=0.25)
        ax.legend(fontsize=9)

    fig.suptitle("Δ²r (kink) strict no-go summary (steps 7.13.15.35–.38)")
    fig.tight_layout(rect=(0, 0, 1, 0.95))
    out_png = out_dir / "nuclear_a_dependence_hf_three_body_radii_kink_delta2r_strict_summary.png"
    fig.savefig(out_png, dpi=160)
    plt.close(fig)
    summary["outputs"]["png"] = str(out_png)

    # Re-write JSON to include PNG path.
    with out_json.open("w", encoding="utf-8") as f:
        json.dump(summary, f, ensure_ascii=False, indent=2)

    print("[ok] Step 7.13.15.39 outputs:")
    print(f"  {out_csv}")
    print(f"  {out_png}")
    print(f"  {out_json}")


def _run_step_7_13_15_40(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.40 (initial): Add a minimal odd-even (pairing-like) radius offset in the
    charge-radius mapping and re-check the Δ²r (kink) observable under the same fixed strict
    thresholds as 7.13.15.35.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.40",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_odd_even",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_odd_even=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_41(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.41 (initial): Combine the NZ-separated shell term with a deformation-aware
    beta2 radius scaling, and re-check the Δ²r (kink) observable under the same fixed strict
    thresholds as 7.13.15.35.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.41",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_shell_nz_beta2",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_shell_nz_beta2=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_42(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.42 (initial): Re-check the Δ²r (kink) observable under the same fixed strict
    thresholds as 7.13.15.35, but restrict evaluation to even-even nuclei (Z even and N even).

    Purpose:
      - Quantify whether the Δ²r strict no-go is dominated by odd-A / odd-odd structure effects
        (e.g., shape coexistence regions) that may be out of scope for the current even-even-driven
        spectroscopy/deformation inputs.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.42",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_even_even_only",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_even_even_only=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_43(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.43 (initial): Add a minimal magic-number offset in the charge-radius mapping and
    re-check the Δ²r (kink) observable under the same fixed strict thresholds as 7.13.15.35.

    Notes:
      - This variant adds discrete offsets at shell closures (magic N/Z), allowing Δ²r spikes at magic numbers.
      - Evaluation is restricted to even-even nuclei (Z even and N even), matching the 7.13.15.42 diagnostic split.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.43",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_magic_offset_even_even_only",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_magic_offset=True,
        radii_kink_delta2r_even_even_only=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_44(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.44 (initial): Re-check the Δ²r (kink) observable under a refined rule:
    only treat kinks whose center is at an observed magic number (shell-closure kinks).

    Notes:
      - This excludes mid-shell/non-closure kinks (e.g., known charge-radius anomalies) from the strict test.
      - Evaluation is restricted to even-even nuclei (Z even and N even).
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.44",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_magic_offset_even_even_center_magic_only",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_magic_offset=True,
        radii_kink_delta2r_even_even_only=True,
        radii_kink_delta2r_center_magic_only=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_45(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.45 (initial): Re-check the shell-closure-only Δ²r (kink) observable using the
    "magic offset neighbors" radius mapping (two DoFs; weighted LS fit on IAEA radii).

    Notes:
      - Uses w_magic spreading to the Δ² stencil neighbors (±2) to reduce Δ²r overshoot.
      - Evaluation is restricted to even-even nuclei (Z even and N even).
      - Only treat kinks whose center is at an observed magic number (shell-closure kinks).
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.45",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_magic_offset_neighbors_even_even_center_magic_only",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_magic_offset_neighbors=True,
        radii_kink_delta2r_even_even_only=True,
        radii_kink_delta2r_center_magic_only=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_46(*, out_dir: Path, domain_min_a: int, radius_fit_min_a: int) -> None:
    """
    Step 7.13.15.46 (initial): Re-check the shell-closure-only Δ²r (kink) observable using a
    per-magic-number radius offset mapping (fit on IAEA radii only).

    Notes:
      - Evaluation is restricted to even-even nuclei (Z even and N even).
      - Only treat kinks whose center is at an observed magic number (shell-closure kinks).
      - This splits the magic offset DoF by magic number to avoid a single global r_magic_N/Z compromise.
    """
    root = Path(__file__).resolve().parents[2]
    spectro_path = root / "data" / "quantum" / "sources" / "nndc_nudat3_primary_secondary" / "extracted_spectroscopy.json"
    _run_step_7_13_15_27(
        out_dir=out_dir,
        domain_min_a=domain_min_a,
        radius_fit_min_a=radius_fit_min_a,
        step_id="7.13.15.46",
        out_stub="expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_magic_offset_per_magic_even_even_center_magic_only",
        include_beta2=True,
        beta2_imputation="neighbors",
        beta2_apply_surface=True,
        beta2_strict_coverage=True,
        include_spectro_multi=True,
        spectro_multi_strict=True,
        spectro_multi_path_override=spectro_path,
        spectro_multi_source_label="NNDC NuDat 3.0 (secondary.json: excitedStateEnergies.*)",
        spectro_multi_note="Uses NuDat 3.0 static chart JSON (ENSDF-derived) for E(2+_1), E(4+_1), E(3-_1) and R4/2; strict cross-check uses local extrema along isotopic/isotonic chains.",
        spectro_multi_fetch_hint="python -B scripts/quantum/fetch_nuclear_spectroscopy_e2plus_sources.py",
        include_radii_kink_delta2r=True,
        radii_kink_delta2r_strict=True,
        radii_kink_delta2r_radius_magic_offset_per_magic=True,
        radii_kink_delta2r_even_even_only=True,
        radii_kink_delta2r_center_magic_only=True,
        radii_kink_sigma_min=3.0,
        radii_kink_delta2r_resid_sigma_max=3.0,
    )


def _run_step_7_13_15_48(*, out_dir: Path) -> None:
    """
    Step 7.13.15.48: Add a minimal series covariance model to σ_obs(Δ²r) and re-evaluate
    the strict (3σ) robustness.

    This step is a robustness check for the Δ²r(kink) strict no-go in Step 7.13.15.44.
    It does not change Δ²r_obs nor Δ²r_pred; it only changes σ_obs(Δ²r) via an AR(1)
    correlation model across the stencil points.
    """
    root = Path(__file__).resolve().parents[2]

    baseline_metrics_path = (
        out_dir
        / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_magic_offset_even_even_center_magic_only_metrics.json"
    )
    if not baseline_metrics_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.44 baseline metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.44\n"
            f"Expected: {baseline_metrics_path}"
        )

    baseline = _load_json(baseline_metrics_path)
    radii_path_s = (
        baseline.get("inputs", {}).get("iaea_charge_radii_csv", {}).get("path")
        if isinstance(baseline.get("inputs"), dict)
        else None
    )
    delta2r_csv_s = baseline.get("outputs", {}).get("radii_kink_delta2r_csv") if isinstance(baseline.get("outputs"), dict) else None
    if not isinstance(radii_path_s, str) or not radii_path_s:
        raise SystemExit(f"[fail] invalid baseline metrics: inputs.iaea_charge_radii_csv.path missing: {baseline_metrics_path}")
    if not isinstance(delta2r_csv_s, str) or not delta2r_csv_s:
        raise SystemExit(f"[fail] invalid baseline metrics: outputs.radii_kink_delta2r_csv missing: {baseline_metrics_path}")

    radii_path = Path(radii_path_s)
    delta2r_csv_path = Path(delta2r_csv_s)
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA radii source csv: {radii_path}")
    if not delta2r_csv_path.exists():
        raise SystemExit(f"[fail] missing baseline delta2r csv: {delta2r_csv_path}")

    def fnum(row: dict[str, str], key: str) -> float | None:
        s = str(row.get(key, "")).strip()
        if not s:
            return None
        try:
            x = float(s)
        except Exception:
            return None
        return float(x) if math.isfinite(x) else None

    # Uncertainties only (fm). Adopted if available, otherwise preliminary.
    sigma_r_by_zn: dict[tuple[int, int], float] = {}
    with radii_path.open("r", encoding="utf-8", newline="") as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            try:
                Z = int(str(row.get("z", "")).strip())
                N = int(str(row.get("n", "")).strip())
            except Exception:
                continue
            if Z < 1 or N < 0:
                continue
            r_val = fnum(row, "radius_val")
            r_unc = fnum(row, "radius_unc")
            if r_val is None or r_unc is None:
                r_val = fnum(row, "radius_preliminary_val")
                r_unc = fnum(row, "radius_preliminary_unc")
            if r_val is None or r_unc is None or not (float(r_val) > 0.0 and float(r_unc) > 0.0):
                continue
            sigma_r_by_zn[(int(Z), int(N))] = float(r_unc)

    delta2r_rows: list[dict[str, object]] = []
    with delta2r_csv_path.open("r", encoding="utf-8", newline="") as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            axis = str(row.get("axis", "")).strip().upper()
            if axis not in {"N", "Z"}:
                continue
            try:
                Z = int(row.get("Z", -1))
                N = int(row.get("N", -1))
            except Exception:
                continue
            d2_obs = fnum(row, "delta2r_obs_fm")
            d2_pred = fnum(row, "delta2r_pred_fm")
            if d2_obs is None or d2_pred is None:
                continue
            if not (math.isfinite(float(d2_obs)) and math.isfinite(float(d2_pred))):
                continue
            delta2r_rows.append({"axis": axis, "Z": int(Z), "N": int(N), "delta2r_obs_fm": float(d2_obs), "delta2r_pred_fm": float(d2_pred)})

    scan = baseline.get("scan") if isinstance(baseline.get("scan"), dict) else {}
    a_mins = scan.get("domain_min_A_candidates") if isinstance(scan.get("domain_min_A_candidates"), list) else [16, 40, 60, 80, 100]
    a_mins_i = sorted({int(x) for x in a_mins if isinstance(x, int) or (isinstance(x, float) and float(x).is_integer())} or {100})

    kink_sigma_min = 3.0
    resid_sigma_max = 3.0
    even_even_only = True
    center_magic_only = True
    obs_magic = {0, 2, 8, 20, 28, 50, 82, 126, 184}

    rho_min = -0.9
    rho_max = 0.9
    rho_step = 0.05
    n_steps = int(round((rho_max - rho_min) / rho_step))
    rho_values = [round(rho_min + i * rho_step, 5) for i in range(n_steps + 1)]

    def sigma_delta2r_ar1(*, sigma_left: float, sigma_center: float, sigma_right: float, rho: float) -> float | None:
        sL = float(sigma_left)
        s0 = float(sigma_center)
        sR = float(sigma_right)
        rr = float(rho)
        if not all(math.isfinite(x) and x > 0.0 for x in (sL, s0, sR)) or not (math.isfinite(rr) and abs(rr) < 1.0):
            return None
        var = sL * sL + 4.0 * s0 * s0 + sR * sR - 4.0 * rr * (sL * s0 + sR * s0) + 2.0 * (rr * rr) * (sL * sR)
        if not math.isfinite(var):
            return None
        if var <= 0.0:
            return None
        return math.sqrt(float(var))

    def eval_axis(*, axis: str, a_min: int, rho: float) -> dict[str, object]:
        n_available = 0
        n_kink = 0
        n_eval = 0
        z2_sum = 0.0
        worst: list[dict[str, object]] = []
        for r in delta2r_rows:
            if str(r["axis"]) != str(axis):
                continue
            Z = int(r["Z"])
            N = int(r["N"])
            if axis == "N":
                Zc = Z
                N0 = N
                if even_even_only and ((Zc % 2 != 0) or (N0 % 2 != 0)):
                    continue
                if int(Zc + N0 - 2) < int(a_min):
                    continue
                s0 = sigma_r_by_zn.get((int(Zc), int(N0)))
                sL = sigma_r_by_zn.get((int(Zc), int(N0) - 2))
                sR = sigma_r_by_zn.get((int(Zc), int(N0) + 2))
                is_center_magic = bool(int(N0) in obs_magic)
                point_id = {"Z": int(Zc), "N0": int(N0)}
            else:
                Z0 = Z
                Nc = N
                if even_even_only and ((Z0 % 2 != 0) or (Nc % 2 != 0)):
                    continue
                if int(Z0 + Nc - 2) < int(a_min):
                    continue
                s0 = sigma_r_by_zn.get((int(Z0), int(Nc)))
                sL = sigma_r_by_zn.get((int(Z0) - 2, int(Nc)))
                sR = sigma_r_by_zn.get((int(Z0) + 2, int(Nc)))
                is_center_magic = bool(int(Z0) in obs_magic)
                point_id = {"Z0": int(Z0), "N": int(Nc)}

            if s0 is None or sL is None or sR is None:
                continue
            n_available += 1
            sig = sigma_delta2r_ar1(sigma_left=float(sL), sigma_center=float(s0), sigma_right=float(sR), rho=float(rho))
            if sig is None:
                continue

            d2_obs = float(r["delta2r_obs_fm"])
            d2_pred = float(r["delta2r_pred_fm"])
            obs_sig = abs(float(d2_obs)) / float(sig)
            if float(obs_sig) < float(kink_sigma_min):
                continue
            if center_magic_only and (not is_center_magic):
                continue
            n_kink += 1

            resid = float(d2_pred) - float(d2_obs)
            z = float(resid) / float(sig)
            if not math.isfinite(z):
                continue
            n_eval += 1
            z2_sum += float(z) ** 2
            worst.append(
                {
                    **point_id,
                    "abs_resid_sigma": abs(float(z)),
                    "delta2r_obs_fm": float(d2_obs),
                    "delta2r_pred_fm": float(d2_pred),
                    "resid_fm": float(resid),
                    "sigma_obs_fm": float(sig),
                    "rho": float(rho),
                }
            )

        worst_sorted = sorted(worst, key=lambda x: float(x["abs_resid_sigma"]), reverse=True)[:10]
        max_abs = float(worst_sorted[0]["abs_resid_sigma"]) if worst_sorted else float("nan")
        rms = math.sqrt(float(z2_sum) / float(n_eval)) if n_eval > 0 and math.isfinite(z2_sum) else float("nan")
        pass_axis = bool(n_eval > 0 and math.isfinite(max_abs) and float(max_abs) <= float(resid_sigma_max))
        return {
            "n_available": int(n_available),
            "n_kink": int(n_kink),
            "n_eval": int(n_eval),
            "rms_resid_sigma": float(rms),
            "max_abs_resid_sigma": float(max_abs),
            "worst_points": worst_sorted,
            "pass": bool(pass_axis),
        }

    results: list[dict[str, object]] = []
    for a_min in a_mins_i:
        sweep: list[dict[str, object]] = []
        for rho in rho_values:
            sn = eval_axis(axis="N", a_min=int(a_min), rho=float(rho))
            sp = eval_axis(axis="Z", a_min=int(a_min), rho=float(rho))
            sweep.append({"rho": float(rho), "gap_Sn_delta2r": sn, "gap_Sp_delta2r": sp, "pass": bool(sn["pass"] and sp["pass"])})
        pass_rhos = [float(x["rho"]) for x in sweep if bool(x.get("pass"))]
        pass_range = {"min": min(pass_rhos), "max": max(pass_rhos), "n": int(len(pass_rhos))} if pass_rhos else None
        results.append({"domain_min_A": int(a_min), "rho_sweep": sweep, "pass_rho_range": pass_range})

    out_stub = "radii_kink_delta2r_radius_magic_offset_even_even_center_magic_only_covariance_ar1_rho_sweep"
    out_json = out_dir / f"nuclear_a_dependence_hf_three_body_{out_stub}_metrics.json"
    out_csv = out_dir / f"nuclear_a_dependence_hf_three_body_{out_stub}.csv"
    out_png = out_dir / f"nuclear_a_dependence_hf_three_body_{out_stub}.png"

    # CSV flattening for quick inspection.
    with out_csv.open("w", encoding="utf-8", newline="") as f:
        fieldnames = [
            "domain_min_A",
            "rho",
            "axis",
            "n_available",
            "n_kink",
            "n_eval",
            "rms_resid_sigma",
            "max_abs_resid_sigma",
            "pass_axis",
            "pass_both_axes",
        ]
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        for pack in results:
            a_min = int(pack["domain_min_A"])
            for r in pack["rho_sweep"]:
                rho = float(r["rho"])
                pass_both = bool(r["pass"])
                for axis, key in [("N", "gap_Sn_delta2r"), ("Z", "gap_Sp_delta2r")]:
                    m = r[key]
                    w.writerow(
                        {
                            "domain_min_A": a_min,
                            "rho": rho,
                            "axis": axis,
                            "n_available": int(m["n_available"]),
                            "n_kink": int(m["n_kink"]),
                            "n_eval": int(m["n_eval"]),
                            "rms_resid_sigma": float(m["rms_resid_sigma"]),
                            "max_abs_resid_sigma": float(m["max_abs_resid_sigma"]),
                            "pass_axis": bool(m["pass"]),
                            "pass_both_axes": bool(pass_both),
                        }
                    )

    # Plot for the key domain_min_A=100 (if available).
    try:
        import matplotlib.pyplot as plt

        pick = next((x for x in results if int(x.get("domain_min_A", -1)) == 100), results[-1] if results else None)
        if pick is not None:
            rho = [float(x["rho"]) for x in pick["rho_sweep"]]
            mx_sn = [float(x["gap_Sn_delta2r"]["max_abs_resid_sigma"]) for x in pick["rho_sweep"]]
            mx_sp = [float(x["gap_Sp_delta2r"]["max_abs_resid_sigma"]) for x in pick["rho_sweep"]]
            fig, ax = plt.subplots(figsize=(9.0, 4.2))
            ax.plot(rho, mx_sn, label="gap_Sn (axis N): max |resid|/sigma")
            ax.plot(rho, mx_sp, label="gap_Sp (axis Z): max |resid|/sigma")
            ax.axhline(float(resid_sigma_max), color="black", linestyle="--", linewidth=1.0, label="strict threshold (3σ)")
            ax.axvline(0.0, color="gray", linestyle=":", linewidth=1.0)
            ax.set_xlabel("rho (AR1 correlation across stencil points)")
            ax.set_ylabel("max_abs_resid_sigma")
            ax.set_title(f"delta2r kink strict robustness vs covariance (domain_min_A={int(pick['domain_min_A'])})")
            ax.grid(True, alpha=0.2)
            ax.legend(loc="best", fontsize=9)
            fig.tight_layout()
            fig.savefig(out_png, dpi=200)
            plt.close(fig)
    except Exception:
        out_png = None

    out_pack: dict[str, object] = {
        "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
        "phase": 7,
        "step": "7.13.15.48",
        "baseline": {
            "step": "7.13.15.44",
            "metrics_path": str(baseline_metrics_path),
            "metrics_sha256": _sha256(baseline_metrics_path),
            "delta2r_csv_path": str(delta2r_csv_path),
            "delta2r_csv_sha256": _sha256(delta2r_csv_path),
            "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
        },
        "covariance_model": {
            "type": "ar1",
            "definition": "cov(i,j)=rho^|i-j| * sigma_i * sigma_j for i,j in (L,0,R); sigma_obs^2=a^T Sigma a with a=[1,-2,1]",
            "rho_range": {"min": float(rho_min), "max": float(rho_max), "step": float(rho_step), "n": int(len(rho_values))},
        },
        "rule_delta2r": {
            "kink_threshold": float(kink_sigma_min),
            "residual_threshold": float(resid_sigma_max),
            "step": 2,
            "even_even_only": bool(even_even_only),
            "center_magic_only": bool(center_magic_only),
            "axes": {"gap_Sn": "x=N at fixed Z", "gap_Sp": "x=Z at fixed N"},
        },
        "results": results,
        "outputs": {"csv": str(out_csv), **({"png": str(out_png)} if out_png is not None else {})},
    }
    out_json.write_text(json.dumps(out_pack, ensure_ascii=False, indent=2), encoding="utf-8")

    print("[ok] wrote:")
    if out_png is not None:
        print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def _run_step_7_13_15_49(*, out_dir: Path) -> None:
    """
    Step 7.13.15.49: Minimal nuclear-structure extension for the Δ²r(kink) strict no-go using
    pairing + deformation (HFB/DFT-like ingredients).

    Protocol (fixed):
      - Baseline radius mapping: Step 7.13.15.23 (r0,rI) + Step 7.13.15.44 magic-offset (r_magic_N/Z).
      - Deformation: β2 from NNDC B(E2), applied as r -> r*sqrt(1 + (5/(4π))*β2^2).
      - Pairing: local OES (3-point) on B_obs (AME2020) gives Δ_n(Z,N) and Δ_p(Z,N), used as
        additive radius corrections: r -> r + k_n*Δ_n + k_p*Δ_p.
      - Freeze (k_n,k_p) by weighted LS on non-magic centers only (A>=40), then evaluate the strict
        shell-closure kink set (even-even, center at observed magic, |Δ²r|/σ>=3, and |resid|/σ<=3).
    """
    root = Path(__file__).resolve().parents[2]

    baseline_7144_path = (
        out_dir
        / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_shell_i_dep_beta2_surface_cov_spectro_multi_nudat3_radii_kink_delta2r_radius_magic_offset_even_even_center_magic_only_metrics.json"
    )
    if not baseline_7144_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.44 baseline metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.44\n"
            f"Expected: {baseline_7144_path}"
        )
    baseline_7144 = _load_json(baseline_7144_path)
    results_7144 = baseline_7144.get("results")
    if not isinstance(results_7144, list) or not results_7144:
        raise SystemExit(f"[fail] invalid 7.13.15.44 metrics: results missing/empty: {baseline_7144_path}")

    # Use a representative run to extract the frozen magic-offset coefficients (obs_magic; A_min=100).
    r_magic_n = float("nan")
    r_magic_z = float("nan")
    magic_list: list[int] = []
    for rr in results_7144:
        if not isinstance(rr, dict) or str(rr.get("status", "")) != "ok":
            continue
        if int(rr.get("domain_min_A", -1)) != 100:
            continue
        sv = rr.get("shell_variant") if isinstance(rr.get("shell_variant"), dict) else {}
        if str(sv.get("name", "")) != "obs_magic":
            continue
        rk = rr.get("radii_kink_delta2r") if isinstance(rr.get("radii_kink_delta2r"), dict) else {}
        mo = rk.get("radius_magic_offset") if isinstance(rk.get("radius_magic_offset"), dict) else {}
        r_magic_n = float(mo.get("r_magic_N_fm", float("nan")))
        r_magic_z = float(mo.get("r_magic_Z_fm", float("nan")))
        magic_list = [int(x) for x in mo.get("magic", [])] if isinstance(mo.get("magic"), list) else []
        break
    if not (math.isfinite(r_magic_n) and math.isfinite(r_magic_z) and magic_list):
        raise SystemExit(f"[fail] could not extract radius_magic_offset coefficients from: {baseline_7144_path}")
    magic_set = {int(x) for x in magic_list if int(x) > 0}

    metrics_71523_path = out_dir / "nuclear_a_dependence_hf_three_body_shellgap_decision_expanded_radii_isospin_metrics.json"
    if not metrics_71523_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.15.23 metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_a_dependence_mean_field.py --step 7.13.15.23\n"
            f"Expected: {metrics_71523_path}"
        )
    m71523 = _load_json(metrics_71523_path)
    radius_model = m71523.get("radius_model") if isinstance(m71523.get("radius_model"), dict) else {}
    r0 = float(radius_model.get("r0_fm", float("nan")))
    rI = float(radius_model.get("rI_fm", float("nan")))
    if not (math.isfinite(r0) and math.isfinite(rI)):
        raise SystemExit(f"[fail] invalid 7.13.15.23 radius_model (r0/rI missing): {metrics_71523_path}")

    # Primary data inputs.
    radii_path = root / "data" / "quantum" / "sources" / "iaea_charge_radii" / "charge_radii.csv"
    ame_path = root / "data" / "quantum" / "sources" / "iaea_amdc_ame2020_mass_1_mas20" / "extracted_values.json"
    beta2_path = root / "data" / "quantum" / "sources" / "nndc_be2_adopted_entries" / "extracted_beta2.json"
    if not radii_path.exists():
        raise SystemExit(f"[fail] missing IAEA charge radii csv: {radii_path}")
    if not ame_path.exists():
        raise SystemExit(f"[fail] missing AME2020 extracted values: {ame_path}")
    if not beta2_path.exists():
        raise SystemExit(
            "[fail] missing NNDC B(E2) deformation beta2 dataset.\n"
            "Run:\n"
            "  python -B scripts/quantum/fetch_nuclear_deformation_be2_sources.py\n"
            f"Expected: {beta2_path}"
        )

    def fnum(x: object) -> float | None:
        s = str(x).strip()
        if not s:
            return None
        try:
            v = float(s)
        except Exception:
            return None
        return float(v) if math.isfinite(v) else None

    # Charge radii (fm) and uncertainties (fm): adopted if present, else preliminary.
    radii_by_zn: dict[tuple[int, int], tuple[float, float]] = {}
    with radii_path.open("r", encoding="utf-8", newline="") as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            try:
                Z = int(str(row.get("z", "")).strip())
                N = int(str(row.get("n", "")).strip())
            except Exception:
                continue
            if Z < 1 or N < 0:
                continue
            r_val = fnum(row.get("radius_val", ""))
            r_unc = fnum(row.get("radius_unc", ""))
            if r_val is None or r_unc is None:
                r_val = fnum(row.get("radius_preliminary_val", ""))
                r_unc = fnum(row.get("radius_preliminary_unc", ""))
            if r_val is None or r_unc is None:
                continue
            if not (float(r_val) > 0.0 and float(r_unc) > 0.0):
                continue
            radii_by_zn[(int(Z), int(N))] = (float(r_val), float(r_unc))
    if not radii_by_zn:
        raise SystemExit(f"[fail] radii map is empty after parsing: {radii_path}")

    # AME2020 binding energies (MeV): B_obs(Z,N).
    ame = _load_json(ame_path)
    ame_rows = ame.get("rows")
    if not isinstance(ame_rows, list) or not ame_rows:
        raise SystemExit(f"[fail] invalid AME2020 extracted values: rows missing/empty: {ame_path}")
    b_obs: dict[tuple[int, int], float] = {}
    a_by_zn: dict[tuple[int, int], int] = {}
    for r in ame_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        A = int(r.get("A", -1))
        if Z < 1 or N < 0 or A < 2:
            continue
        ba_keV = float(r.get("binding_keV_per_A", float("nan")))
        if not math.isfinite(ba_keV):
            continue
        ba_mev = float(ba_keV) / 1000.0
        b_obs[(int(Z), int(N))] = float(A) * float(ba_mev)
        a_by_zn[(int(Z), int(N))] = int(A)
    if not b_obs:
        raise SystemExit(f"[fail] B_obs map is empty after parsing: {ame_path}")

    # NNDC β2 map.
    beta2_extracted = _load_json(beta2_path)
    beta2_rows = beta2_extracted.get("rows")
    if not isinstance(beta2_rows, list) or not beta2_rows:
        raise SystemExit(f"[fail] invalid NNDC beta2 extracted dataset: rows missing/empty: {beta2_path}")
    beta2_by_zn: dict[tuple[int, int], float] = {}
    for r in beta2_rows:
        if not isinstance(r, dict):
            continue
        Z = int(r.get("Z", -1))
        N = int(r.get("N", -1))
        b2 = float(r.get("beta2", float("nan")))
        if Z < 1 or N < 0 or not math.isfinite(b2):
            continue
        beta2_by_zn[(int(Z), int(N))] = float(b2)
    if not beta2_by_zn:
        raise SystemExit(f"[fail] NNDC beta2 map is empty after parsing: {beta2_path}")

    # Pairing indicators (local OES; 3-point) in MeV.
    dn_by_zn: dict[tuple[int, int], float] = {}
    dp_by_zn: dict[tuple[int, int], float] = {}
    for (Z, N), A in a_by_zn.items():
        # Neutron 3-point (uses N±1).
        dn = float("nan")
        if (Z, int(N) - 1) in b_obs and (Z, int(N) + 1) in b_obs:
            dn = ((-1) ** int(N)) * (float(b_obs[(Z, int(N) + 1)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(Z, int(N) - 1)])) / 2.0
        dn_by_zn[(int(Z), int(N))] = abs(float(dn)) if math.isfinite(dn) else float("nan")

        # Proton 3-point (uses Z±1).
        dp = float("nan")
        if (int(Z) - 1, N) in b_obs and (int(Z) + 1, N) in b_obs:
            dp = ((-1) ** int(Z)) * (float(b_obs[(int(Z) + 1, N)]) - 2.0 * float(b_obs[(Z, N)]) + float(b_obs[(int(Z) - 1, N)])) / 2.0
        dp_by_zn[(int(Z), int(N))] = abs(float(dp)) if math.isfinite(dp) else float("nan")

    # Model constants/rules.
    obs_magic = [2, 8, 20, 28, 50, 82, 126, 184]
    obs_magic_set = {int(x) for x in obs_magic}
    kink_sigma_min = 3.0
    resid_sigma_max = 3.0
    k_beta2 = 5.0 / (4.0 * math.pi)

    scan_domain_min_a = [16, 40, 60, 80, 100]
    fit_min_a = 40  # fixed protocol (match 7.13.15.23 fit_min_A)

    def r_pred_base(*, Z: int, N: int) -> float | None:
        A = int(Z) + int(N)
        if A < 2 or int(Z) < 1 or int(N) < 0:
            return None
        I = float(int(N) - int(Z)) / float(A)
        r = (float(r0) + float(rI) * float(I)) * (float(A) ** (1.0 / 3.0))
        if not (math.isfinite(r) and r > 0.0):
            return None
        if int(N) in magic_set:
            r = float(r) + float(r_magic_n)
        if int(Z) in magic_set:
            r = float(r) + float(r_magic_z)
        return float(r) if (math.isfinite(r) and r > 0.0) else None

    def r_pred_deformed(*, Z: int, N: int, use_deformation: bool) -> float | None:
        base = r_pred_base(Z=int(Z), N=int(N))
        if base is None:
            return None
        if not use_deformation:
            return float(base)
        b2, _mode = _beta2_for_zn(Z=int(Z), N=int(N), beta2_by_zn=beta2_by_zn, include_beta2=True, imputation="neighbors")
        b2 = abs(float(b2))
        factor = math.sqrt(1.0 + float(k_beta2) * float(b2) * float(b2))
        out_r = float(base) * float(factor)
        if not (math.isfinite(out_r) and out_r > 0.0):
            return None
        return float(out_r)

    def pair_dn(*, Z: int, N: int) -> float:
        v = dn_by_zn.get((int(Z), int(N)))
        return float(v) if (v is not None and math.isfinite(float(v))) else 0.0

    def pair_dp(*, Z: int, N: int) -> float:
        v = dp_by_zn.get((int(Z), int(N)))
        return float(v) if (v is not None and math.isfinite(float(v))) else 0.0

    # Build Δ²r points (even-even only; step=2), for both axes.
    points: list[dict[str, object]] = []
    for (Z, N0), (r0_obs, s0_obs) in radii_by_zn.items():
        Z = int(Z)
        N0 = int(N0)
        if (Z % 2 != 0) or (N0 % 2 != 0):
            continue
        # Axis N (vary N at fixed Z).
        cL = radii_by_zn.get((int(Z), int(N0) - 2))
        cR = radii_by_zn.get((int(Z), int(N0) + 2))
        if cL is not None and cR is not None:
            rL_obs, sL_obs = cL
            rR_obs, sR_obs = cR
            sig = math.sqrt(float(sR_obs) ** 2 + 4.0 * float(s0_obs) ** 2 + float(sL_obs) ** 2)
            if math.isfinite(sig) and sig > 0.0:
                d2_obs = float(rR_obs) - 2.0 * float(r0_obs) + float(rL_obs)
                obs_sig = abs(float(d2_obs)) / float(sig)
                min_a = min(int(Z + N0 - 2), int(Z + N0), int(Z + N0 + 2))
                is_kink = bool(float(obs_sig) >= float(kink_sigma_min) and int(N0) in obs_magic_set)
                points.append(
                    {
                        "axis": "N",
                        "Z": int(Z),
                        "X0": int(N0),
                        "min_A": int(min_a),
                        "delta2r_obs_fm": float(d2_obs),
                        "sigma_obs_fm": float(sig),
                        "obs_sig": float(obs_sig),
                        "is_kink": bool(is_kink),
                    }
                )

        # Axis Z (vary Z at fixed N).
        cLz = radii_by_zn.get((int(Z) - 2, int(N0)))
        cRz = radii_by_zn.get((int(Z) + 2, int(N0)))
        if cLz is not None and cRz is not None:
            rL_obs, sL_obs = cLz
            rR_obs, sR_obs = cRz
            sig = math.sqrt(float(sR_obs) ** 2 + 4.0 * float(s0_obs) ** 2 + float(sL_obs) ** 2)
            if math.isfinite(sig) and sig > 0.0:
                d2_obs = float(rR_obs) - 2.0 * float(r0_obs) + float(rL_obs)
                obs_sig = abs(float(d2_obs)) / float(sig)
                min_a = min(int((Z - 2) + N0), int(Z + N0), int((Z + 2) + N0))
                is_kink = bool(float(obs_sig) >= float(kink_sigma_min) and int(Z) in obs_magic_set)
                points.append(
                    {
                        "axis": "Z",
                        "Z": int(Z),
                        "X0": int(Z),
                        "N": int(N0),
                        "min_A": int(min_a),
                        "delta2r_obs_fm": float(d2_obs),
                        "sigma_obs_fm": float(sig),
                        "obs_sig": float(obs_sig),
                        "is_kink": bool(is_kink),
                    }
                )

    if not points:
        raise SystemExit("[fail] no Δ²r points constructed from radii dataset")

    def add_model_fields(*, use_deformation: bool) -> None:
        for p in points:
            axis = str(p["axis"])
            Zc = int(p["Z"])
            x0 = int(p["X0"])
            if axis == "N":
                # (Z, N0±2)
                rL = r_pred_deformed(Z=Zc, N=int(x0) - 2, use_deformation=use_deformation)
                r0m = r_pred_deformed(Z=Zc, N=int(x0), use_deformation=use_deformation)
                rR = r_pred_deformed(Z=Zc, N=int(x0) + 2, use_deformation=use_deformation)
                dnL = pair_dn(Z=Zc, N=int(x0) - 2)
                dn0 = pair_dn(Z=Zc, N=int(x0))
                dnR = pair_dn(Z=Zc, N=int(x0) + 2)
                dpL = pair_dp(Z=Zc, N=int(x0) - 2)
                dp0 = pair_dp(Z=Zc, N=int(x0))
                dpR = pair_dp(Z=Zc, N=int(x0) + 2)
            else:
                Nc = int(p["N"])
                # (Z0±2, N)
                rL = r_pred_deformed(Z=int(x0) - 2, N=Nc, use_deformation=use_deformation)
                r0m = r_pred_deformed(Z=int(x0), N=Nc, use_deformation=use_deformation)
                rR = r_pred_deformed(Z=int(x0) + 2, N=Nc, use_deformation=use_deformation)
                dnL = pair_dn(Z=int(x0) - 2, N=Nc)
                dn0 = pair_dn(Z=int(x0), N=Nc)
                dnR = pair_dn(Z=int(x0) + 2, N=Nc)
                dpL = pair_dp(Z=int(x0) - 2, N=Nc)
                dp0 = pair_dp(Z=int(x0), N=Nc)
                dpR = pair_dp(Z=int(x0) + 2, N=Nc)

            d2_pred = float("nan")
            if rL is not None and r0m is not None and rR is not None:
                d2_pred = float(rR) - 2.0 * float(r0m) + float(rL)
            p[f"delta2r_pred_fm__deform_{int(bool(use_deformation))}"] = float(d2_pred)
            p[f"delta2_dn__deform_{int(bool(use_deformation))}"] = float(dnR) - 2.0 * float(dn0) + float(dnL)
            p[f"delta2_dp__deform_{int(bool(use_deformation))}"] = float(dpR) - 2.0 * float(dp0) + float(dpL)

    add_model_fields(use_deformation=False)
    add_model_fields(use_deformation=True)

    def fit_kn_kp(*, use_deformation: bool) -> dict[str, float]:
        key_pred = f"delta2r_pred_fm__deform_{int(bool(use_deformation))}"
        key_dn2 = f"delta2_dn__deform_{int(bool(use_deformation))}"
        key_dp2 = f"delta2_dp__deform_{int(bool(use_deformation))}"
        Snn = 0.0
        Spp = 0.0
        Snp = 0.0
        bn = 0.0
        bp = 0.0
        n_fit = 0
        for p in points:
            if int(p.get("min_A", 0)) < int(fit_min_a):
                continue
            axis = str(p["axis"])
            x0 = int(p["X0"])
            # Train on non-magic centers only (fixed protocol).
            if (axis == "N" and int(x0) in obs_magic_set) or (axis == "Z" and int(x0) in obs_magic_set):
                continue
            d2_pred = float(p.get(key_pred, float("nan")))
            d2_obs = float(p.get("delta2r_obs_fm", float("nan")))
            sig = float(p.get("sigma_obs_fm", float("nan")))
            dn2 = float(p.get(key_dn2, float("nan")))
            dp2 = float(p.get(key_dp2, float("nan")))
            if not (math.isfinite(d2_pred) and math.isfinite(d2_obs) and math.isfinite(sig) and sig > 0.0):
                continue
            if not (math.isfinite(dn2) and math.isfinite(dp2)):
                continue
            w = 1.0 / (float(sig) ** 2)
            resid0 = float(d2_pred) - float(d2_obs)
            Snn += float(w) * float(dn2) * float(dn2)
            Spp += float(w) * float(dp2) * float(dp2)
            Snp += float(w) * float(dn2) * float(dp2)
            bn += float(w) * float(dn2) * float(resid0)
            bp += float(w) * float(dp2) * float(resid0)
            n_fit += 1
        det = float(Snn) * float(Spp) - float(Snp) * float(Snp)
        if not (n_fit > 10 and math.isfinite(det) and det > 0.0):
            raise SystemExit(f"[fail] pairing fit is ill-conditioned (n_fit={n_fit}, det={det})")
        inv00 = float(Spp) / float(det)
        inv11 = float(Snn) / float(det)
        inv01 = -float(Snp) / float(det)
        k_n = -(float(inv00) * float(bn) + float(inv01) * float(bp))
        k_p = -(float(inv01) * float(bn) + float(inv11) * float(bp))
        sig_kn = math.sqrt(float(inv00)) if (math.isfinite(inv00) and inv00 > 0.0) else float("nan")
        sig_kp = math.sqrt(float(inv11)) if (math.isfinite(inv11) and inv11 > 0.0) else float("nan")
        corr = float(inv01) / (float(sig_kn) * float(sig_kp)) if (math.isfinite(sig_kn) and sig_kn > 0 and math.isfinite(sig_kp) and sig_kp > 0) else float("nan")
        return {
            "k_n_fm_per_MeV": float(k_n),
            "k_p_fm_per_MeV": float(k_p),
            "sigma_k_n": float(sig_kn),
            "sigma_k_p": float(sig_kp),
            "corr_k_n_k_p": float(corr),
            "n_fit": int(n_fit),
        }

    fit0 = fit_kn_kp(use_deformation=False)
    fit1 = fit_kn_kp(use_deformation=True)

    strict_points_by_a_min: dict[int, list[dict[str, object]]] = {}
    for a_min in scan_domain_min_a:
        strict_points_by_a_min[int(a_min)] = [p for p in points if bool(p.get("is_kink", False)) and int(p.get("min_A", 0)) >= int(a_min)]

    def eval_strict(
        *,
        use_deformation: bool,
        k_n: float,
        k_p: float,
        strict_points: list[dict[str, object]],
    ) -> dict[str, object]:
        key_pred = f"delta2r_pred_fm__deform_{int(bool(use_deformation))}"
        key_dn2 = f"delta2_dn__deform_{int(bool(use_deformation))}"
        key_dp2 = f"delta2_dp__deform_{int(bool(use_deformation))}"
        worst_n: list[dict[str, object]] = []
        worst_z: list[dict[str, object]] = []
        for p in strict_points:
            d2_pred0 = float(p.get(key_pred, float("nan")))
            d2_obs = float(p.get("delta2r_obs_fm", float("nan")))
            sig = float(p.get("sigma_obs_fm", float("nan")))
            dn2 = float(p.get(key_dn2, float("nan")))
            dp2 = float(p.get(key_dp2, float("nan")))
            if not (math.isfinite(d2_pred0) and math.isfinite(d2_obs) and math.isfinite(sig) and sig > 0.0):
                continue
            resid = (float(d2_pred0) + float(k_n) * float(dn2) + float(k_p) * float(dp2)) - float(d2_obs)
            z = float(resid) / float(sig)
            entry = {
                "axis": str(p["axis"]),
                "Z": int(p["Z"]),
                "X0": int(p["X0"]),
                **({"N": int(p["N"])} if str(p["axis"]) == "Z" else {}),
                "min_A": int(p["min_A"]),
                "abs_resid_sigma": abs(float(z)),
                "resid_sigma": float(z),
                "delta2r_obs_fm": float(d2_obs),
                "delta2r_pred_fm": float(d2_pred0),
                "sigma_obs_fm": float(sig),
                "delta2_dn": float(dn2),
                "delta2_dp": float(dp2),
            }
            if str(p["axis"]) == "N":
                worst_n.append(entry)
            else:
                worst_z.append(entry)
        worst_n = sorted(worst_n, key=lambda x: float(x["abs_resid_sigma"]), reverse=True)
        worst_z = sorted(worst_z, key=lambda x: float(x["abs_resid_sigma"]), reverse=True)
        mx_n = float(worst_n[0]["abs_resid_sigma"]) if worst_n else float("nan")
        mx_z = float(worst_z[0]["abs_resid_sigma"]) if worst_z else float("nan")
        pass_n = bool(worst_n and math.isfinite(mx_n) and mx_n <= float(resid_sigma_max))
        pass_z = bool(worst_z and math.isfinite(mx_z) and mx_z <= float(resid_sigma_max))
        return {
            "n_kink_Sn": int(len(worst_n)),
            "n_kink_Sp": int(len(worst_z)),
            "max_abs_resid_sigma_Sn": float(mx_n),
            "max_abs_resid_sigma_Sp": float(mx_z),
            "pass": bool(pass_n and pass_z),
            "worst_Sn": worst_n[:10],
            "worst_Sp": worst_z[:10],
        }

    def grid_search(
        *,
        use_deformation: bool,
        strict_points: list[dict[str, object]],
        k_fit_n: float,
        k_fit_p: float,
    ) -> dict[str, object]:
        # Search within a fixed plausible window around 0.
        k_min = -0.05
        k_max = 0.05
        step = 0.001
        n = int(round((k_max - k_min) / step))
        ks = [float(k_min + i * step) for i in range(n + 1)]
        best_pass: dict[str, object] | None = None
        best_score = float("inf")
        best_any: dict[str, object] | None = None
        best_any_score = float("inf")
        for kn in ks:
            for kp in ks:
                m = eval_strict(use_deformation=use_deformation, k_n=float(kn), k_p=float(kp), strict_points=strict_points)
                mx = max(float(m["max_abs_resid_sigma_Sn"]), float(m["max_abs_resid_sigma_Sp"]))
                if not math.isfinite(mx):
                    continue
                dist2 = (float(kn) - float(k_fit_n)) ** 2 + (float(kp) - float(k_fit_p)) ** 2
                score = float(dist2)
                if mx < best_any_score:
                    best_any_score = float(mx)
                    best_any = {"k_n": float(kn), "k_p": float(kp), "max_abs": float(mx), "metrics": m}
                if bool(m["pass"]) and score < best_score:
                    best_score = float(score)
                    best_pass = {"k_n": float(kn), "k_p": float(kp), "dist2_to_fit": float(dist2), "metrics": m}
        return {
            "grid": {"k_n_range": [float(k_min), float(k_max)], "k_p_range": [float(k_min), float(k_max)], "step": float(step)},
            "best_pass_near_fit": best_pass,
            "best_any_minimax": best_any,
        }

    summary_rows: list[dict[str, object]] = []
    for a_min in scan_domain_min_a:
        row: dict[str, object] = {"domain_min_A": int(a_min)}
        strict_pts = strict_points_by_a_min.get(int(a_min), [])
        for use_def, fit in [(False, fit0), (True, fit1)]:
            tag = "def1" if use_def else "def0"
            kf_n = float(fit["k_n_fm_per_MeV"])
            kf_p = float(fit["k_p_fm_per_MeV"])
            m0 = eval_strict(use_deformation=use_def, k_n=0.0, k_p=0.0, strict_points=strict_pts)
            mf = eval_strict(use_deformation=use_def, k_n=kf_n, k_p=kf_p, strict_points=strict_pts)
            gs = grid_search(use_deformation=use_def, strict_points=strict_pts, k_fit_n=kf_n, k_fit_p=kf_p)
            row[f"{tag}_baseline"] = m0
            row[f"{tag}_pair_fit"] = {"fit": fit, "metrics": mf, "grid_search": gs}
        summary_rows.append(row)

    out_stub = "radii_kink_delta2r_radius_magic_offset_even_even_center_magic_only_pairing_deformation_minimal"
    out_json = out_dir / f"nuclear_a_dependence_hf_three_body_{out_stub}_metrics.json"
    out_csv = out_dir / f"nuclear_a_dependence_hf_three_body_{out_stub}.csv"
    out_png = out_dir / f"nuclear_a_dependence_hf_three_body_{out_stub}.png"

    # CSV summary (per A_min; deformation off/on).
    with out_csv.open("w", encoding="utf-8", newline="") as f:
        w = csv.writer(f)
        w.writerow(
            [
                "domain_min_A",
                "model",
                "k_n_fm_per_MeV",
                "k_p_fm_per_MeV",
                "n_fit",
                "sigma_k_n",
                "sigma_k_p",
                "corr_k_n_k_p",
                "n_kink_Sn",
                "n_kink_Sp",
                "max_abs_resid_sigma_Sn",
                "max_abs_resid_sigma_Sp",
                "pass",
                "best_pass_k_n",
                "best_pass_k_p",
                "best_any_minimax_k_n",
                "best_any_minimax_k_p",
                "best_any_minimax_max_abs",
            ]
        )
        for r in summary_rows:
            a_min = int(r["domain_min_A"])
            for tag in ["def0", "def1"]:
                base = r[f"{tag}_baseline"]
                fit_pack = r[f"{tag}_pair_fit"]
                fit = fit_pack["fit"]
                met = fit_pack["metrics"]
                gs = fit_pack["grid_search"]
                best_pass = gs.get("best_pass_near_fit") if isinstance(gs, dict) else None
                best_any = gs.get("best_any_minimax") if isinstance(gs, dict) else None
                w.writerow(
                    [
                        a_min,
                        tag,
                        f"{float(fit['k_n_fm_per_MeV']):.12g}",
                        f"{float(fit['k_p_fm_per_MeV']):.12g}",
                        int(fit["n_fit"]),
                        f"{float(fit['sigma_k_n']):.12g}",
                        f"{float(fit['sigma_k_p']):.12g}",
                        f"{float(fit['corr_k_n_k_p']):.12g}",
                        int(met["n_kink_Sn"]),
                        int(met["n_kink_Sp"]),
                        f"{float(met['max_abs_resid_sigma_Sn']):.12g}",
                        f"{float(met['max_abs_resid_sigma_Sp']):.12g}",
                        str(bool(met["pass"])),
                        f"{float(best_pass['k_n']):.12g}" if isinstance(best_pass, dict) else "",
                        f"{float(best_pass['k_p']):.12g}" if isinstance(best_pass, dict) else "",
                        f"{float(best_any['k_n']):.12g}" if isinstance(best_any, dict) else "",
                        f"{float(best_any['k_p']):.12g}" if isinstance(best_any, dict) else "",
                        f"{float(best_any['max_abs']):.12g}" if isinstance(best_any, dict) else "",
                    ]
                )

    # Plot: compare baseline vs pair-fit (max abs z) for A_min.
    try:
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots(figsize=(10.5, 4.6))
        xs = [int(r["domain_min_A"]) for r in summary_rows]
        for tag, label in [("def0", "no deformation"), ("def1", "β2 deformation")]:
            y0 = [max(float(r[f"{tag}_baseline"]["max_abs_resid_sigma_Sn"]), float(r[f"{tag}_baseline"]["max_abs_resid_sigma_Sp"])) for r in summary_rows]
            yf = [
                max(
                    float(r[f"{tag}_pair_fit"]["metrics"]["max_abs_resid_sigma_Sn"]),
                    float(r[f"{tag}_pair_fit"]["metrics"]["max_abs_resid_sigma_Sp"]),
                )
                for r in summary_rows
            ]
            ax.plot(xs, y0, marker="o", linestyle="--", label=f"{label}: baseline (k_n=k_p=0)")
            ax.plot(xs, yf, marker="o", linestyle="-", label=f"{label}: pairing-fit (k_n,k_p frozen)")
        ax.axhline(float(resid_sigma_max), color="k", linewidth=1.0, alpha=0.6, linestyle=":")
        ax.set_xlabel("domain_min_A")
        ax.set_ylabel("max(|Δ²r_pred−Δ²r_obs|/σ_obs) over kink set (Sn & Sp)")
        ax.set_title("Step 7.13.15.49: Δ²r(kink) strict robustness with minimal pairing+deformation extension")
        ax.grid(True, alpha=0.25)
        ax.legend(loc="best", fontsize=9)
        fig.tight_layout()
        fig.savefig(out_png, dpi=200)
        plt.close(fig)
    except Exception:
        out_png = None

    out_pack: dict[str, object] = {
        "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
        "phase": 7,
        "step": "7.13.15.49",
        "baseline": {
            "radius_model": {
                "step": "7.13.15.23",
                "metrics_path": str(metrics_71523_path),
                "metrics_sha256": _sha256(metrics_71523_path),
                "r0_fm": float(r0),
                "rI_fm": float(rI),
                "form": str(radius_model.get("form", "")),
            },
            "radius_magic_offset": {
                "step": "7.13.15.44",
                "metrics_path": str(baseline_7144_path),
                "metrics_sha256": _sha256(baseline_7144_path),
                "magic": [int(x) for x in magic_list],
                "r_magic_N_fm": float(r_magic_n),
                "r_magic_Z_fm": float(r_magic_z),
            },
            "data": {
                "iaea_charge_radii_csv": {"path": str(radii_path), "sha256": _sha256(radii_path)},
                "ame2020_extracted": {"path": str(ame_path), "sha256": _sha256(ame_path)},
                "nndc_beta2_extracted": {"path": str(beta2_path), "sha256": _sha256(beta2_path)},
            },
        },
        "model": {
            "deformation": {"beta2_source": "NNDC B(E2) adopted (beta2)", "k_beta2": float(k_beta2), "imputation": "neighbors"},
            "pairing": {
                "definition": "Δ_n,Δ_p are 3-point OES on B_obs (AME2020): Δ_n=|(-1)^N (B(N+1)-2B(N)+B(N-1))/2|, Δ_p analogous in Z.",
                "radius_correction": "r -> r + k_n*Δ_n + k_p*Δ_p (k_n,k_p frozen by weighted LS on non-magic centers)",
            },
        },
        "rule_delta2r": {
            "delta2": "Δ²r = r(x+2) - 2 r(x) + r(x-2)",
            "sigma_obs": "σ_obs(Δ²r) = sqrt(σ(x+2)^2 + 4σ(x)^2 + σ(x-2)^2) (independent)",
            "kink_threshold": float(kink_sigma_min),
            "residual_threshold": float(resid_sigma_max),
            "step": 2,
            "even_even_only": True,
            "center_magic_only": True,
            "center_magic": list(obs_magic),
        },
        "fit_protocol": {"fit_min_A": int(fit_min_a), "train_centers": "exclude centers at observed magic numbers (axis-specific)"},
        "scan": {"domain_min_A": [int(x) for x in scan_domain_min_a]},
        "results": summary_rows,
        "outputs": {"csv": str(out_csv), **({"png": str(out_png)} if out_png is not None else {})},
    }
    out_json.write_text(json.dumps(out_pack, ensure_ascii=False, indent=2), encoding="utf-8")

    print("[ok] wrote:")
    if out_png is not None:
        print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


def main() -> None:
    root = Path(__file__).resolve().parents[2]
    out_dir = root / "output" / "public" / "quantum"
    out_dir.mkdir(parents=True, exist_ok=True)

    parser = argparse.ArgumentParser(description="Phase 7 / nuclear A-dependence checks")
    parser.add_argument(
        "--step",
        default="7.13.12",
        choices=[
            "7.13.12",
            "7.13.13",
            "7.13.14",
            "7.13.15",
            "7.13.15.2",
            "7.13.15.3",
            "7.13.15.4",
            "7.13.15.5",
            "7.13.15.6",
            "7.13.15.7",
            "7.13.15.8",
            "7.13.15.9",
            "7.13.15.10",
            "7.13.15.11",
            "7.13.15.12",
            "7.13.15.13",
            "7.13.15.14",
            "7.13.15.15",
            "7.13.15.16",
            "7.13.15.17",
            "7.13.15.18",
            "7.13.15.19",
            "7.13.15.20",
            "7.13.15.21",
            "7.13.15.22",
            "7.13.15.23",
            "7.13.15.24",
            "7.13.15.25",
            "7.13.15.26",
            "7.13.15.27",
            "7.13.15.28",
            "7.13.15.29",
            "7.13.15.30",
            "7.13.15.31",
            "7.13.15.32",
            "7.13.15.33",
            "7.13.15.34",
            "7.13.15.35",
            "7.13.15.36",
            "7.13.15.37",
            "7.13.15.38",
            "7.13.15.39",
            "7.13.15.40",
            "7.13.15.41",
            "7.13.15.42",
            "7.13.15.43",
            "7.13.15.44",
            "7.13.15.45",
            "7.13.15.46",
            "7.13.15.48",
            "7.13.15.49",
        ],
        help="roadmap step selector",
    )
    parser.add_argument("--calibrate-key", default="ca40", help="7.13.13: one-point calibration nucleus key (e.g., ca40)")
    parser.add_argument(
        "--pn-triplet-weight",
        type=float,
        default=0.5,
        help="7.13.13/7.13.14: pn triplet mixture weight in the Hartree term (0..1).",
    )
    parser.add_argument("--freeze-min-A", type=int, default=40, help="7.13.14: freeze C using nuclei with A>=this threshold")
    parser.add_argument("--derivative-eps-rel", type=float, default=1e-3, help="7.13.14: relative step for dE/dR central difference")
    parser.add_argument(
        "--domain-min-A",
        type=int,
        default=16,
        help="7.13.15.5/7.13.15.6/7.13.15.7/7.13.15.8/7.13.15.9/7.13.15.10/7.13.15.11/7.13.15.12/7.13.15.13/7.13.15.14/7.13.15.15/7.13.15.16/7.13.15.17/7.13.15.18/7.13.15.21/7.13.15.22/7.13.15.23/7.13.15.24/7.13.15.25/7.13.15.26/7.13.15.27/7.13.15.28/7.13.15.29: applicability domain lower bound (A>=this threshold).",
    )
    parser.add_argument("--max-nuclei", type=int, default=0, help="7.13.15.6: limit joined nuclei count for debugging (0=all).")
    parser.add_argument("--surface-fit-min-A", type=int, default=16, help="7.13.15.7: fit uses nuclei with A>=this threshold.")
    parser.add_argument(
        "--surface-fit-include-preliminary",
        action="store_true",
        help="7.13.15.7: include preliminary radii in the (C3_est vs x) fit (default: published only).",
    )
    parser.add_argument("--surface-fit-clip-k", type=float, default=5.0, help="7.13.15.7: robust MAD clip threshold (k*sigma); 0 disables clipping.")
    args = parser.parse_args()

    if args.step == "7.13.13":
        _run_step_7_13_13(out_dir=out_dir, calibrate_key=str(args.calibrate_key), pn_triplet_weight=float(args.pn_triplet_weight))
        return
    if args.step == "7.13.14":
        _run_step_7_13_14(
            out_dir=out_dir,
            pn_triplet_weight=float(args.pn_triplet_weight),
            freeze_min_a=int(args.freeze_min_A),
            derivative_eps_rel=float(args.derivative_eps_rel),
        )
        return
    if args.step == "7.13.15":
        _run_step_7_13_15(
            out_dir=out_dir,
            pn_triplet_weight=float(args.pn_triplet_weight),
            freeze_min_a=int(args.freeze_min_A),
            derivative_eps_rel=float(args.derivative_eps_rel),
        )
        return
    if args.step == "7.13.15.2":
        _run_step_7_13_15_2(out_dir=out_dir)
        return
    if args.step == "7.13.15.3":
        _run_step_7_13_15_3(out_dir=out_dir)
        return
    if args.step == "7.13.15.4":
        _run_step_7_13_15_4(out_dir=out_dir)
        return
    if args.step == "7.13.15.5":
        _run_step_7_13_15_5(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.6":
        _run_step_7_13_15_6(out_dir=out_dir, domain_min_a=int(args.domain_min_A), max_nuclei=int(args.max_nuclei))
        return
    if args.step == "7.13.15.7":
        _run_step_7_13_15_7(
            out_dir=out_dir,
            domain_min_a=int(args.domain_min_A),
            fit_min_a=int(args.surface_fit_min_A),
            fit_include_preliminary=bool(args.surface_fit_include_preliminary),
            clip_k=float(args.surface_fit_clip_k),
        )
        return
    if args.step == "7.13.15.8":
        _run_step_7_13_15_8(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.9":
        _run_step_7_13_15_9(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.10":
        _run_step_7_13_15_10(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.11":
        _run_step_7_13_15_11(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.12":
        _run_step_7_13_15_12(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.13":
        _run_step_7_13_15_13(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.14":
        _run_step_7_13_15_14(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.15":
        _run_step_7_13_15_15(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.16":
        _run_step_7_13_15_16(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.17":
        _run_step_7_13_15_17(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.18":
        _run_step_7_13_15_18(out_dir=out_dir, domain_min_a=int(args.domain_min_A))
        return
    if args.step == "7.13.15.19":
        _run_step_7_13_15_19(out_dir=out_dir)
        return
    if args.step == "7.13.15.20":
        _run_step_7_13_15_20(out_dir=out_dir)
        return
    if args.step == "7.13.15.21":
        _run_step_7_13_15_21(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.22":
        _run_step_7_13_15_22(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.23":
        _run_step_7_13_15_23(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.24":
        _run_step_7_13_15_24(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.25":
        _run_step_7_13_15_25(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.26":
        _run_step_7_13_15_26(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.27":
        _run_step_7_13_15_27(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.28":
        _run_step_7_13_15_28(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.29":
        _run_step_7_13_15_29(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.30":
        _run_step_7_13_15_30(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.31":
        _run_step_7_13_15_31(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.32":
        _run_step_7_13_15_32(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.33":
        _run_step_7_13_15_33(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.34":
        _run_step_7_13_15_34(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.35":
        _run_step_7_13_15_35(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.36":
        _run_step_7_13_15_36(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.37":
        _run_step_7_13_15_37(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.38":
        _run_step_7_13_15_38(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.39":
        _run_step_7_13_15_39(out_dir=out_dir)
        return
    if args.step == "7.13.15.40":
        _run_step_7_13_15_40(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.41":
        _run_step_7_13_15_41(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.42":
        _run_step_7_13_15_42(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.43":
        _run_step_7_13_15_43(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.44":
        _run_step_7_13_15_44(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.45":
        _run_step_7_13_15_45(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.46":
        _run_step_7_13_15_46(out_dir=out_dir, domain_min_a=int(args.domain_min_A), radius_fit_min_a=int(args.freeze_min_A))
        return
    if args.step == "7.13.15.48":
        _run_step_7_13_15_48(out_dir=out_dir)
        return
    if args.step == "7.13.15.49":
        _run_step_7_13_15_49(out_dir=out_dir)
        return
    if args.step != "7.13.12":
        raise SystemExit(f"[fail] unknown step: {args.step}")

    metrics_7138_path = _resolve_effective_potential_metrics_path(out_dir=out_dir)
    metrics_7138 = _load_json(metrics_7138_path)

    rep_path = out_dir / "nuclear_binding_representative_nuclei_metrics.json"
    if not rep_path.exists():
        raise SystemExit(
            "[fail] missing Step 7.13.11 baseline metrics.\n"
            "Run:\n"
            "  python -B scripts/quantum/nuclear_binding_representative_nuclei.py\n"
            f"Expected: {rep_path}"
        )
    rep = _load_json(rep_path)
    nuclei = rep.get("nuclei")
    if not isinstance(nuclei, list) or not nuclei:
        raise SystemExit(f"[fail] invalid baseline metrics: nuclei missing/empty: {rep_path}")

    # Constants (reuse from 7.13.8)
    consts = metrics_7138.get("constants") if isinstance(metrics_7138.get("constants"), dict) else {}
    hbarc = float(consts.get("hbarc_MeV_fm", 197.3269804))
    mu_c2 = float(consts.get("mu_c2_MeV", 469.4591551497099))
    m_nucleon_c2 = 2.0 * mu_c2

    # Mix rule (no per-nucleus tuning).
    w_triplet = 0.75
    w_singlet = 0.25

    pot_sets = _extract_potential_sets(metrics_7138=metrics_7138)
    eq_labels = sorted(pot_sets.keys())

    rows: list[dict[str, object]] = []
    for nuc in nuclei:
        if not isinstance(nuc, dict):
            continue
        a = int(nuc["A"])
        z = int(nuc["Z"])
        n = int(nuc["N"])
        key = str(nuc["key"])
        label = str(nuc["label"])
        ba_obs = float(nuc["binding_energy_per_nucleon_MeV"])
        r_charge = float(nuc["charge_radius_fm"])

        R_sharp = _sharp_radius_from_rms(r_charge)
        V_sphere = (4.0 / 3.0) * math.pi * R_sharp**3
        rho = float(a) / float(V_sphere)
        kf, t_mev = _fermi_kinetic_energy_per_particle_mev(rho_fm3=rho, hbarc_mev_fm=hbarc, m_nucleon_c2_mev=m_nucleon_c2)

        per_eq: dict[int, dict[str, float]] = {}
        for eq in eq_labels:
            s = pot_sets[eq]
            geom = s["geometry"]
            tri = s["triplet"]
            sin = s["singlet"]

            # Linearly mix channels (weights fixed, no per-nucleus tuning).
            V1 = w_triplet * float(tri["V1_MeV"]) + w_singlet * float(sin["V1_MeV"])
            V2 = w_triplet * float(tri["V2_MeV"]) + w_singlet * float(sin["V2_MeV"])
            Vb = w_triplet * float(tri["Vb_MeV"]) + w_singlet * float(sin["Vb_MeV"])
            Vt = w_triplet * float(tri["Vt_MeV"]) + w_singlet * float(sin["Vt_MeV"])

            u_mev = _mean_field_potential_energy_per_particle_mev(
                R_sharp_fm=R_sharp, rho_fm3=rho, geometry=geom, V1_MeV=V1, V2_MeV=V2, Vb_MeV=Vb, Vt_MeV=Vt
            )
            e_total = float(t_mev) + float(u_mev)
            ba_pred = -float(e_total)
            per_eq[int(eq)] = {
                "kf_fm1": float(kf),
                "T_kin_MeV_per_A": float(t_mev),
                "U_pot_MeV_per_A": float(u_mev),
                "E_total_MeV_per_A": float(e_total),
                "B_over_A_pred_MeV": float(ba_pred),
                "B_over_A_residual_MeV": float(ba_pred - ba_obs),
            }

        rows.append(
            {
                "key": key,
                "label": label,
                "A": a,
                "Z": z,
                "N": n,
                "r_charge_fm": r_charge,
                "R_sharp_fm": R_sharp,
                "rho_fm3": rho,
                "B_over_A_obs_MeV": ba_obs,
                "per_eq": per_eq,
            }
        )

    # Aggregate stats
    stats: dict[int, dict[str, float]] = {}
    for eq in eq_labels:
        res = [float(r["per_eq"][eq]["B_over_A_residual_MeV"]) for r in rows]
        rms = math.sqrt(sum(x * x for x in res) / len(res)) if res else float("nan")
        mean = sum(res) / len(res) if res else float("nan")
        stats[int(eq)] = {"residual_mean_MeV": float(mean), "residual_rms_MeV": float(rms)}

    # Plot
    try:
        import matplotlib.pyplot as plt
    except Exception as e:
        raise SystemExit(f"[fail] matplotlib is required for plotting: {e}") from e

    a_vals = [int(r["A"]) for r in rows]
    a13 = [a ** (1.0 / 3.0) for a in a_vals]
    ba_obs_vals = [float(r["B_over_A_obs_MeV"]) for r in rows]
    labels = [str(r["label"]) for r in rows]

    fig, axes = plt.subplots(2, 2, figsize=(14, 7), constrained_layout=True)

    ax = axes[0][0]
    ax.scatter(a13, ba_obs_vals, s=45, label="obs (AME2020)")
    for eq in eq_labels:
        ba_pred = [float(r["per_eq"][eq]["B_over_A_pred_MeV"]) for r in rows]
        ax.plot(a13, ba_pred, marker="o", linestyle="--", label=f"pred (mean-field; eq{eq})")
    ax.set_title("Binding energy per nucleon: obs vs mean-field pred")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("B/A (MeV)")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8)
    for x, y, lab in zip(a13, ba_obs_vals, labels, strict=True):
        ax.annotate(lab, (x, y), textcoords="offset points", xytext=(5, 4), fontsize=8)

    ax = axes[0][1]
    for eq in eq_labels:
        t_vals = [float(r["per_eq"][eq]["T_kin_MeV_per_A"]) for r in rows]
        u_vals = [float(r["per_eq"][eq]["U_pot_MeV_per_A"]) for r in rows]
        ax.plot(a13, t_vals, marker=".", linestyle="-", label=f"T (eq{eq})")
        ax.plot(a13, u_vals, marker=".", linestyle="--", label=f"U (eq{eq})")
    ax.set_title("Mean-field contributions")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("MeV per nucleon")
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=8, ncol=2)

    ax = axes[1][0]
    rho_vals = [float(r["rho_fm3"]) for r in rows]
    ax.plot(a13, rho_vals, marker="o", linestyle="-", color="tab:purple")
    ax.set_title("Density estimate from charge radii")
    ax.set_xlabel("A^(1/3)")
    ax.set_ylabel("ρ (fm^-3)")
    ax.grid(True, alpha=0.3)

    ax = axes[1][1]
    ax.axis("off")
    lines = [
        "Model: uniform-sphere mean-field (pairwise V(r))",
        f"Mix: w_triplet={w_triplet:.2f}, w_singlet={w_singlet:.2f}",
        f"Inputs: Step 7.13.8 potential (eq{eq_labels[0]}–eq{eq_labels[-1]}) + Step 7.13.11 targets",
        "",
        "Notes:",
        "  - Minimal A-dependence consistency check (not a full many-body solve).",
        "  - Uses charge radii to set an effective density (no fitting to B/A).",
    ]
    for eq in eq_labels:
        s = stats[eq]
        lines.append(f"  - residual RMS (eq{eq}): {s['residual_rms_MeV']:.3g} MeV")
    ax.text(0.0, 1.0, "\n".join(lines), va="top", family="monospace", fontsize=9)

    out_png = out_dir / "nuclear_a_dependence_mean_field.png"
    fig.suptitle("Phase 7 / Step 7.13.12: A-dependence mean-field check (fixed u-profile class)", fontsize=12)
    fig.savefig(out_png, bbox_inches="tight")
    plt.close(fig)

    # CSV
    out_csv = out_dir / "nuclear_a_dependence_mean_field.csv"
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        header = [
            "key",
            "label",
            "A",
            "Z",
            "N",
            "r_charge_fm",
            "R_sharp_fm",
            "rho_fm3",
            "B_over_A_obs_MeV",
        ]
        for eq in eq_labels:
            header.extend(
                [
                    f"kf_eq{eq}_fm^-1",
                    f"T_kin_eq{eq}_MeV_per_A",
                    f"U_pot_eq{eq}_MeV_per_A",
                    f"B_over_A_pred_eq{eq}_MeV",
                    f"residual_eq{eq}_MeV",
                ]
            )
        w.writerow(header)
        for r in rows:
            row = [
                r["key"],
                r["label"],
                int(r["A"]),
                int(r["Z"]),
                int(r["N"]),
                f"{float(r['r_charge_fm']):.12g}",
                f"{float(r['R_sharp_fm']):.12g}",
                f"{float(r['rho_fm3']):.12g}",
                f"{float(r['B_over_A_obs_MeV']):.12g}",
            ]
            for eq in eq_labels:
                pe = r["per_eq"][eq]
                row.extend(
                    [
                        f"{float(pe['kf_fm1']):.12g}",
                        f"{float(pe['T_kin_MeV_per_A']):.12g}",
                        f"{float(pe['U_pot_MeV_per_A']):.12g}",
                        f"{float(pe['B_over_A_pred_MeV']):.12g}",
                        f"{float(pe['B_over_A_residual_MeV']):.12g}",
                    ]
                )
            w.writerow(row)

    # Metrics
    out_json = out_dir / "nuclear_a_dependence_mean_field_metrics.json"
    out_json.write_text(
        json.dumps(
            {
                "generated_utc": __import__("datetime").datetime.now(__import__("datetime").timezone.utc).isoformat(),
                "phase": 7,
                "step": "7.13.12",
                "inputs": {
                    "potential_metrics": _potential_metrics_input_entry(metrics_path=metrics_7138_path, metrics_obj=metrics_7138),
                    "potential_metrics_7_13_8": _potential_metrics_input_entry(metrics_path=metrics_7138_path, metrics_obj=metrics_7138),
                    "targets_7_13_11": {"path": str(rep_path), "sha256": _sha256(rep_path)},
                },
                "model": {
                    "type": "uniform_sphere_mean_field",
                    "positioning": "consistency check (declared approximation), not a full many-body solve",
                    "mix": {"w_triplet": w_triplet, "w_singlet": w_singlet},
                    "density": "from charge radii (uniform sphere R=sqrt(5/3) r_rms)",
                    "kinetic": "nonrelativistic symmetric Fermi gas (g=4)",
                    "units": {"length": "fm", "energy": "MeV"},
                },
                "constants": {"hbarc_MeV_fm": hbarc, "m_nucleon_c2_MeV": m_nucleon_c2},
                "stats": stats,
                "rows": rows,
                "falsification": {
                    "reject_examples": [
                        "If B/A_pred is non-positive across most A (no binding), the approximation class is insufficient.",
                        "If residuals show a monotonic divergence with A under both eq18/eq19 potentials, the fixed u-profile class likely cannot explain A-saturation without additional physics.",
                    ]
                },
                "outputs": {"png": str(out_png), "csv": str(out_csv)},
            },
            ensure_ascii=False,
            indent=2,
        ),
        encoding="utf-8",
    )

    print("[ok] wrote:")
    print(f"  {out_png}")
    print(f"  {out_csv}")
    print(f"  {out_json}")


if __name__ == "__main__":
    main()
